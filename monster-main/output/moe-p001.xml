<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1465</anchor>  <taxon>Part</taxon> <addr>moe-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Monadic Expansions/moe-p001.tree</source-path> <route>moe-p001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Monadic Expansions</title> </frontmatter> <mainmatter><p>Model Theory of Monadic Expansions</p>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb></trail> <anchor>1466</anchor>  <taxon>Section</taxon> <addr>moe-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Monadic Expansions/Mutually Algebraic Theories/moe-s001.tree</source-path> <route>moe-s001.xml</route> <date><year>2024</year> <month>2</month> <day>9</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Definition of </title> </frontmatter> <mainmatter/> </tree>
</mainmatter> <backmatter><contributions/> <context><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="true"><frontmatter> <anchor>1467</anchor>   <addr>mon-0001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/mon-0001.tree</source-path> <route>index.xml</route>  <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> <contributor><link href="gpeters.xml" type="local">Garrett Peters</link></contributor></authors> <title>The Model Companion</title> </frontmatter> <mainmatter><p>This is the potential start of a new online resource on model theory, replacing the (now defunct) model theory wiki.</p><p>This website is made with the software Forester (http://www.jonmsterling.com/jms-005P.xml). Forester allows you to explore the site in many interesting ways, we have provided a structured starting off points as in below but you may search for any page using Command K</p><p>The site is nonlinear in its arrangement of information. At the high level, the website is broken into parts which are comprised of sections. Currently parts correspond to large themes or subjects in model theory and the sections subdivide these themes further. These parts and sections may not be disjoint but the nature of forester is well suited to navigating these overlaps since definitions and theorems can be transcluded easily. </p><p>In the future it would be nice to have parts which organize the material as one would encounter it as a course or set of lecture notes intended for self study but for now, we intend to set up the backbone as a wikipedia or stacks project reference document and then reassemble the information after a critical mass has been achieved. </p><strong>Here are the parts which currently exist or are being worked on</strong>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb></trail> <anchor>1468</anchor>  <taxon>Part</taxon> <addr>BMT-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-p001.tree</source-path> <route>BMT-p001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> <contributor><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></contributor><contributor><link href="gpeters.xml" type="local">Garrett Peters</link></contributor></authors> <title>Basic Model Theory</title> </frontmatter> <mainmatter><p>We give the common definitions and theorems for basic/introductory model theory</p>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>1</crumb></trail> <anchor>1469</anchor>  <taxon>Section</taxon> <addr>BMT-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s001.tree</source-path> <route>BMT-s001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Structures, Isomorphisms, Substructures</title> </frontmatter> <mainmatter><p>In this section we give the basic notions and theorems for structures, isomorphisms, and substructures</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>1</crumb> <crumb>1</crumb></trail> <anchor>1470</anchor>  <taxon>Definition</taxon> <addr>BMT-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d001.tree</source-path> <route>BMT-d001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of a language</title> </frontmatter> <mainmatter><p>A language, also called a vocabulary or signature by different authors, is a set <tex>\mathcal {L}</tex> consisting of symbols for constants, relations, and functions, 
often denoted by <tex>c</tex>, <tex>R</tex>, and <tex>f</tex> respectively. Languages may have any cardinality.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>1</crumb> <crumb>2</crumb></trail> <anchor>1471</anchor>  <taxon>Definition</taxon> <addr>BMT-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d002.tree</source-path> <route>BMT-d002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of a Structure</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Definition of a language">language</link> <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-structure <tex>\mathcal {M}</tex> in this language has a universe <tex>M</tex> (often, the structure and its universe 
are written the same, by abuse of notation). The structure <tex>\mathcal {M}</tex> &quot;interprets&quot; the symbols of <tex>\mathcal {L}</tex> as follows:</p><p>For a constant symbol <tex>c \in   \mathcal {L}</tex>, the interpretation of <tex>c</tex> in <tex>\mathcal {M}</tex>, denoted <tex>c^{ \mathcal {M}}</tex> represents a fixed 
element of <tex>M</tex></p><p>For an <tex>n</tex>-ary function symbol <tex>f \in   \mathcal {L}</tex>, the interpretation of <tex>f</tex> in <tex>\mathcal {M}</tex>, denoted <tex>f^{ \mathcal {M}}</tex>,
is a function from <tex>M^n</tex> to <tex>M</tex></p><p>For an <tex>n</tex>-ary relation symbol <tex>R \in   \mathcal {L}</tex>, the interpretation of <tex>R</tex> in <tex>\mathcal {M}</tex>, denoted <tex>R^{ \mathcal {M}}</tex>,
is a subset <tex>M^n</tex></p><p>Often, we are interested in the cardinality of a structure, denoted <tex>| \mathcal {M}|</tex>, which is defined to be the cardinality of its universe.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>1</crumb> <crumb>3</crumb></trail> <anchor>1472</anchor>  <taxon>Definition</taxon> <addr>BMT-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d003.tree</source-path> <route>BMT-d003.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of a Homomorphism</title> </frontmatter> <mainmatter><p>Given two <link href="BMT-d002.xml" type="local" title="Definition of a Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Definition of a language">language</link> <tex>\mathcal {L}</tex>, a <em>homomorphism</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a function between the universes <tex>A</tex> and <tex>B</tex> of <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> respectively such that:</p><p> For every n-ary function <tex>f \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n \in  A</tex>, <tex>\varphi (f^{ \mathcal {A}}(a_1, \dots , a_n)) = f^{ \mathcal {B}}( \varphi (a_1), \dots ,  \varphi (a_n))</tex></p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Rightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>For every constant symbol <tex>c  \in   \mathcal {L}</tex>, <tex>\varphi (c^{ \mathcal {A}}) =c^{ \mathcal {B}}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>1</crumb> <crumb>4</crumb></trail> <anchor>1473</anchor>  <taxon>Definition</taxon> <addr>BMT-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d004.tree</source-path> <route>BMT-d004.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of an embedding of <tex>L</tex>-structures</title> </frontmatter> <mainmatter><p>Given two structures in a language <tex>\mathcal {L}</tex> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex>, an <em>embedding</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a <link href="BMT-d003.xml" type="local" title="Definition of a Homomorphism">homomorphism</link> such that:</p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Leftrightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>This is stronger than a homomorphism because we now require a two way implication in the above property.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>1</crumb> <crumb>5</crumb></trail> <anchor>1474</anchor>  <taxon>Definition</taxon> <addr>BMT-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d005.tree</source-path> <route>BMT-d005.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of an isomorphism</title> </frontmatter> <mainmatter><p>An <link href="BMT-d004.xml" type="local" title="Definition of an embedding of L-structures">embedding</link> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex> between <tex>\mathcal {L}</tex>-structures is a <em>isomorphism</em> if it is surjective.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>1</crumb> <crumb>6</crumb></trail> <anchor>1475</anchor>  <taxon>Definition</taxon> <addr>BMT-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d006.tree</source-path> <route>BMT-d006.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of a Substructure</title> </frontmatter> <mainmatter><p>Given a <tex>\mathcal {L}</tex>-structure <tex>\mathcal {A}</tex>, a subset <tex>B  \subseteq  A</tex> is called a <em>substructure</em> of <tex>\mathcal {A}</tex> if:</p><p>For every constant <tex>c \in   \mathcal {L}</tex>, <tex>c^{ \mathcal {A}}  \in  B</tex></p><p>For every n-ary function <tex>f \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, <tex>f^{ \mathcal {A}}(b_1, \dots ,b_n)  \in  B</tex></p><p>For every n-ary relation, <tex>R \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, we write <tex>R^B = R^{ \mathcal {A}} \cap   \mathcal {P}(B^n)</tex> and require that
<tex>R^{B}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{B}</tex>)  if and only if <tex>R^{ \mathcal {A}}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{ \mathcal {A}}</tex>) 
Note that this condition is vacuously true, so only the first two conditions need to be checked when verifying a substructure.</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>2</crumb></trail> <anchor>1476</anchor>  <taxon>Section</taxon> <addr>BMT-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s002.tree</source-path> <route>BMT-s002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Formulas and Models</title> </frontmatter> <mainmatter><p>In this section we define formulas, elementary equivalence, elementary substructures, theories, and models</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>2</crumb> <crumb>1</crumb></trail> <anchor>1477</anchor>  <taxon>Definition</taxon> <addr>BMT-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d007.tree</source-path> <route>BMT-d007.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of a term</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, we define a <em>term</em> to be any of the following:</p><p>If <tex>c \in   \mathcal {L}</tex> is a constant symbol, then <tex>c</tex> is a term</p><p>If <tex>x</tex> is a variable symbol, then <tex>x</tex> is a term. We generally assume we have countably infinitely many variable symbols</p><p>If <tex>t_1,..., t_n</tex> are terms, and <tex>f \in   \mathcal {L}</tex> is an <tex>n</tex>-ary function, then <tex>f(t_1,..., t_n)</tex> is a term.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>2</crumb> <crumb>2</crumb></trail> <anchor>1478</anchor>  <taxon>Definition</taxon> <addr>BMT-d008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d008.tree</source-path> <route>BMT-d008.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of an atomic formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <em>atomic formula</em> is defined as follows:</p><p>If <tex>R \in   \mathcal {L}</tex> is an n-ary relation symbol, and <tex>t_1, \dots , t_n</tex> are <link href="BMT-d007.xml" type="local" title="Definition of a term">terms</link>, then <tex>R(t_1, \dots , t_n)</tex> is an atomic formula.</p><p>If <tex>t_1</tex> and <tex>t_2</tex> are <tex>\mathcal {L}</tex>-terms, then <tex>t_1 = t_2</tex> is an atomic formula. </p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>2</crumb> <crumb>3</crumb></trail> <anchor>1479</anchor>  <taxon>Definition</taxon> <addr>BMT-d009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d009.tree</source-path> <route>BMT-d009.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of an <tex>\mathcal {L}</tex>-formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-formula is defined inductively as follows:</p><p>If <tex>\phi</tex> is an <tex>\mathcal {L}</tex>-<link href="BMT-d008.xml" type="local" title="Definition of an atomic formula">atomic formula</link> then <tex>\phi</tex> is a formula</p><p>If <tex>\phi</tex> and <tex>\psi</tex> are both formulas, then <tex>\neg \phi</tex>, <tex>\phi   \land   \psi</tex>, and <tex>\phi \lor \phi</tex> are formulas, where <tex>\lor , \neg , \land</tex> are the usual <link href="BMT-d010.xml" type="local" title="Definition of Logical Connectives">logical connectives</link></p><p>If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link></p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>3</crumb></trail> <anchor>1480</anchor>  <taxon>Section</taxon> <addr>BMT-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s003.tree</source-path> <route>BMT-s003.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Quantifier Elimination</title> </frontmatter> <mainmatter><p>Quantifier Elimination is a part of a broader technique in Model Theory where for a structure in a given language, an arbitrary formula can be written as a boolean combination of perhaps simpler formulas</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>3</crumb> <crumb>1</crumb></trail> <anchor>1481</anchor>  <taxon>Definition</taxon> <addr>BMT-d014</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d014.tree</source-path> <route>BMT-d014.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Definition of an Elimination Set</title> </frontmatter> <mainmatter><p>An <em>Elimination Set</em> for a language <tex>\mathcal {L}</tex> and class <tex>K</tex> of <tex>\mathcal {L}</tex>-structures, then a set <tex>\Gamma</tex> of formulas <tex>\phi</tex> is an elimination set for <tex>K</tex> if for every formula <tex>\phi ( \bar {x})</tex> of <tex>\mathcal {L}</tex> there is a formula <tex>\phi ^*( \bar {x})</tex> which is a boolean combinations of formulas in <tex>\Gamma</tex> and <tex>\phi</tex> is equivalent to <tex>\phi ^*</tex> in every structure in <tex>K</tex></p></mainmatter> </tree><p>In particular, we will be most interested in elimination sets that are comprised of the set of quantifier free formulas. It is worth noting that, in some cases it is not possible to have a full quantifier elimination down to the level of a quantifier free set but perhaps we can restrict ourself to some reasonable set of formulas.</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>4</crumb></trail> <anchor>1482</anchor>  <taxon>Section</taxon> <addr>BMT-s004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s004.tree</source-path> <route>BMT-s004.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Back and Forth</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for quantifier Elimination</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>5</crumb></trail> <anchor>1483</anchor>  <taxon>Section</taxon> <addr>BMT-s005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s005.tree</source-path> <route>BMT-s005.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Types</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for types.</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>6</crumb></trail> <anchor>1484</anchor>  <taxon>Section</taxon> <addr>BMT-s006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s006.tree</source-path> <route>BMT-s006.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Saturation</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for saturation of models.</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>7</crumb></trail> <anchor>1485</anchor>  <taxon>Section</taxon> <addr>BMT-s007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s007.tree</source-path> <route>BMT-s007.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> <contributor><link href="gpeters.xml" type="local">Garrett Peters</link></contributor></authors> <title>Ultraproducts</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for the use of ultraproducts in model theory.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>7</crumb> <crumb>1</crumb></trail> <anchor>1486</anchor>  <taxon>Definition</taxon> <addr>BMT-d071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d071.tree</source-path> <route>BMT-d071.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Definition of a Filter</title> </frontmatter> <mainmatter><p>Let <tex>I</tex> be any set. Then a filter <tex>\mathcal {F}</tex> on the power set <tex>\mathcal {P}(I)</tex> is a collection of subsets of <tex>I</tex> with the following properties:</p><p>1: <tex>I \in \mathcal {F}</tex>.</p><p>2: If <tex>A \in   \mathcal {F}</tex> and <tex>A \subseteq  B</tex>, then <tex>B \in   \mathcal {F}</tex>.</p><p>3: If <tex>A,B  \in   \mathcal {F}</tex>, then we have <tex>A \cap  B \in   \mathcal {F}</tex>.</p><p>Furthermore, a filter is proper if <tex>\emptyset \notin \mathcal {F}</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>7</crumb> <crumb>2</crumb></trail> <anchor>1487</anchor>  <taxon>Definition</taxon> <addr>BMT-d072</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d072.tree</source-path> <route>BMT-d072.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Definition of an Ultrafilter</title> </frontmatter> <mainmatter><p>Let <tex>I</tex> be any set. Then an ultrafilter <tex>\mathcal {U}</tex> on <tex>\mathcal {P}(I)</tex> is a proper <link href="BMT-d071.xml" type="local" title="Definition of a Filter">filter</link> on <tex>I</tex> with the additional property:</p><p>For every <tex>A \subseteq  I</tex>, either <tex>A \in \mathcal {U}</tex> or <tex>I \backslash  A \in \mathcal {U}</tex>.</p><p>Every proper filter can be extended into an ultrafilter.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>7</crumb> <crumb>3</crumb></trail> <anchor>1488</anchor>  <taxon>Example</taxon> <addr>BMT-e071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e071.tree</source-path> <route>BMT-e071.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Principal Ultrafilters</title> </frontmatter> <mainmatter><p>Fix any <tex>i \in  I</tex>. Then <tex>\mathcal {U}_i :=  \{ A \subseteq  I: i \in  A \}</tex> is an <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link>. This is referred to as the principal ultrafilter concentrated at <tex>i</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>7</crumb> <crumb>4</crumb></trail> <anchor>1489</anchor>  <taxon>Example</taxon> <addr>BMT-e072</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e072.tree</source-path> <route>BMT-e072.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>The Fréchet Filter</title> </frontmatter> <mainmatter><p>For any set <tex>I</tex> of infinite cardinality, the family of cofinite sets forms a proper <link href="BMT-d071.xml" type="local" title="Definition of a Filter">filter</link>. This filter is referred to as the Fréchet filter.</p><p>When extending the Fréchet filter to an <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link>, the result is not <link href="BMT-e071.xml" type="local" title="Principal Ultrafilters">principal</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>7</crumb> <crumb>5</crumb></trail> <anchor>1490</anchor>  <taxon>Definition</taxon> <addr>BMT-d073</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d073.tree</source-path> <route>BMT-d073.xml</route> <date><year>2024</year> <month>3</month> <day>7</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Ultraproduct</title> </frontmatter> <mainmatter><p>Fix an index set <tex>I</tex> and a <link href="BMT-d001.xml" type="local" title="Definition of a language">language</link> <tex>L</tex>. Let <tex>\{ \mathcal {A}_i: i \in  I \}</tex> be a family of <tex>L</tex>-<link href="BMT-d002.xml" type="local" title="Definition of a Structure">structures</link>, and let <tex>\mathcal {U}</tex> be any <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link> on <tex>\mathcal {P}(I)</tex>. Then the ultraproduct is the <tex>L</tex>-structure <tex>\mathcal {A}_* :=  \prod _{i \in  I} A_i / \mathcal {U}</tex>. </p><p>In <tex>\mathcal {A}_*</tex>, the elements of the universe of <tex>\mathcal {A}_*</tex> are functions <tex>\underline {a}</tex> with domain <tex>I</tex> and <tex>\underline {a}(i) \in  A_i</tex> under the equivalence class <tex>\sim _{ \mathcal {U}}</tex>, where <tex display="block">\underline {a} \sim _{ \mathcal {U}} \underline {b}  \text { if and only if } \{ i \in  I:  \underline {a}(i)= \underline {b}(i) \}   \in   \mathcal {U}.</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb> <crumb>7</crumb> <crumb>6</crumb></trail> <anchor>1491</anchor>  <taxon>Theorem</taxon> <addr>BMT-t071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t071.tree</source-path> <route>BMT-t071.xml</route> <date><year>2024</year> <month>3</month> <day>7</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>ŁOś's Theorem</title> </frontmatter> <mainmatter><p>Let <tex>\mathcal {A}_* =  \prod \limits _{i \in  I}  \mathcal {A}_i /  \mathcal {U}</tex> be an <link href="BMT-d073.xml" type="local" title="Ultraproduct">ultraproduct</link>. Then for any <tex>L</tex>-formula <tex>\phi (x_1, \dots ,x_n)</tex>, we have <tex display="block">\mathcal {A}_* \models   \phi ( \underline {a}_1, \dots , \underline {a}_n)  \text { if and only if }  \{ i \in  I: A_i \models \phi ( \underline {a}_1(i), \dots ,  \underline {a}_n(i)) \} \in \mathcal {U}.</tex></p></mainmatter> </tree></mainmatter> </tree>
</mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb></trail> <anchor>1492</anchor>  <taxon>Part</taxon> <addr>Fra-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-p001.tree</source-path> <route>Fra-p001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse Classes and Variants</title> </frontmatter> <mainmatter><p>We present Fraisse Classes, Smooth classes, and related results and variants.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>1</crumb></trail> <anchor>1493</anchor>  <taxon>Section</taxon> <addr>Fra-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s001.tree</source-path> <route>Fra-s001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse Classes</title> </frontmatter> <mainmatter><p>We define Fraisse constructions and their properties. Most of the concepts can be referred to in <link href="Ref-0001.xml" type="local" title="Model Theory by Wilfred Hodges">Wilfred Hodges' Model Theory</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>1</crumb> <crumb>1</crumb></trail> <anchor>1494</anchor>  <taxon>Definition</taxon> <addr>Fra-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d001.tree</source-path> <route>Fra-d001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of a class</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, a class <tex>K</tex> is defined to be a set of <tex>\mathcal {L}</tex>-structures</p><p>Often, we want there to be a relation <tex>\leq</tex> acting on the structures in <tex>K</tex>, and when we do, we write the class and relation as a pair <tex>(K,  \leq )</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>1</crumb> <crumb>2</crumb></trail> <anchor>1495</anchor>  <taxon>Definition</taxon> <addr>Fra-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d002.tree</source-path> <route>Fra-d002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of an Age</title> </frontmatter> <mainmatter><p>Given a structure <tex>A</tex> in a language <tex>\mathcal {L}</tex>, the <em>Age</em> (pronounced ah-zh) of <tex>A</tex> is <tex display="block">\{ B \subseteq  A: B  \text { is finitely generated } \}</tex></p><p>The age of a structure is itself a class, often under the relation of substructure</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>1</crumb> <crumb>3</crumb></trail> <anchor>1496</anchor>  <taxon>Definition</taxon> <addr>Fra-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d003.tree</source-path> <route>Fra-d003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Amalgamation Property (AP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex> and <tex>h_2(f(A)) = h_1(g(A))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>1</crumb> <crumb>4</crumb></trail> <anchor>1497</anchor>  <taxon>Definition</taxon> <addr>Fra-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d004.tree</source-path> <route>Fra-d004.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Joint Embedding Property (JEP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B  \in  K</tex>, there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex></p><p><link href="Fra-d003.xml" type="local" title="Definition of Amalgamation Property (AP)">Amalgamation Property</link> does NOT necessarily imply JEP, unless the empty set <tex>\emptyset</tex> is in <tex>K</tex> and for all <tex>A \in  K</tex>, we have that <tex>\emptyset   \leq  A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>1</crumb> <crumb>5</crumb></trail> <anchor>1498</anchor>  <taxon>Definition</taxon> <addr>Fra-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d005.tree</source-path> <route>Fra-d005.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Hereditary Property (HP)</title> </frontmatter> <mainmatter><p>A class <tex>(K, \leq )</tex> has the hereditary property if for every <tex>A \in  K</tex>, and any <tex>B \subseteq  A</tex> finitely generated, then there is some <tex>C \in  K</tex> such that <tex>C \cong  B</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>1</crumb> <crumb>6</crumb></trail> <anchor>1499</anchor>  <taxon>Theorem</taxon> <addr>Fra-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t001.tree</source-path> <route>Fra-t001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \subset )</tex> a class of finitely generated structures has the <link href="Fra-d003.xml" type="local" title="Definition of Amalgamation Property (AP)">amalgamation property</link>, the <link href="Fra-d004.xml" type="local" title="Definition of Joint Embedding Property (JEP)">joint embedding property</link>, and the <link href="Fra-d005.xml" type="local" title="Definition of Hereditary Property (HP)">hereditary property</link>, 
Then there is a unique, countable structure <tex>\mathcal {M}</tex> whose <link href="Fra-d002.xml" type="local" title="Definition of an Age">age</link> is <tex>K</tex> with the property that any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \subseteq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>The structure <tex>\mathcal {M}</tex> is the <em>Fraisse limit</em> of <tex>K</tex>.</p><p>We call a class <tex>(K, \subseteq )</tex> satisfying AP, HP, and JEP a Fraisse class</p><p>When a structure has the above isomorphism extension property, we say it is <em>ultrahomogeneous</em> (or <em>homogeneous</em>). 
The converse of Fraisse's Theorem is also true in the sense that if we have a structure which is ultrahomogeneous with respect to its age, then its age is a Fraisse class.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>1</crumb> <crumb>7</crumb></trail> <anchor>1500</anchor>  <taxon>Theorem</taxon> <addr>Fra-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t002.tree</source-path> <route>Fra-t002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Properties of a Fraisse Limit</title> </frontmatter> <mainmatter><p>If <tex>M</tex> is the <link href="Fra-t001.xml" type="local" title="Fraisse's Theorem">Fraisse Limit</link> of a class <tex>(K,  \leq )</tex>, then <tex>Th(M)</tex> has quantifier elimination and is <tex>\omega</tex>-categorical</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>1</crumb> <crumb>8</crumb></trail> <anchor>1501</anchor>  <taxon>Example</taxon> <addr>Fra-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e001.tree</source-path> <route>Fra-e001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ex: The Random Graph</title> </frontmatter> <mainmatter><p>Rado's famous random graph is indeed the Fraisse Limit of the class of finite graphs in the language <tex>\mathcal {L} =  \{ E \}</tex> where <tex>E</tex> is a binary relation representing &quot;there is an edge&quot; between two points.</p><p>More precisely, a graph is an <tex>\mathcal {L}-</tex>structure for which <tex>E</tex> is anti-reflexive and symmetric.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>1</crumb> <crumb>9</crumb></trail> <anchor>1502</anchor>  <taxon>Example</taxon> <addr>Fra-e002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e002.tree</source-path> <route>Fra-e002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ex: <tex>( \mathbb {Q},  \leq )</tex></title> </frontmatter> <mainmatter><p>The Dense Linear Order <tex>( \mathbb {Q},  \leq )</tex> is the Fraisse Limit of the class of all finite linear orders</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>2</crumb></trail> <anchor>1503</anchor>  <taxon>Section</taxon> <addr>Fra-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s002.tree</source-path> <route>Fra-s002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Other Properties of Classes</title> </frontmatter> <mainmatter><p>We define other common properties and variants of the set up shown in the <link href="Fra-s001.xml" type="local" title="Fraisse Classes">Fraisse section</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>2</crumb> <crumb>1</crumb></trail> <anchor>1504</anchor>  <taxon>Definition</taxon> <addr>Fra-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d006.tree</source-path> <route>Fra-d006.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Disjoint Amalgamation Property (dAP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Disjoint Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex> such that <tex>B \cap  C =A</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex>, <tex>h_2(f(A)) = h_1(g(A))</tex>, and <tex>h_2(C)  \cap  h_1(B) = h_1(A)</tex></p><p>An example of a class which has the dAP is the <link href="Fra-e001.xml" type="local" title="Ex: The Random Graph">Fraisse class of finite graphs</link></p><p>An example of a smooth class which does not have the dAP is <link href="Smc-e001.xml" type="local" title="Ex: Initial Segments">The class of initial segments</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>2</crumb> <crumb>2</crumb></trail> <anchor>1505</anchor>  <taxon>Definition</taxon> <addr>Fra-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d007.tree</source-path> <route>Fra-d007.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Ramsey Class</title> </frontmatter> <mainmatter><p>For structures <tex>A,B</tex>, let <tex display="block">\binom {B}{A} =  \{ A_0: A_0 \leq  B &amp; ; A_0 \cong  B \}</tex></p><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the Ramsey property if for every <tex>A \leq  B  \in  K</tex>, there is some <tex>C \in  K</tex> with <tex>B \leq  C</tex>
such that for every <tex>k</tex>-coloring <tex>c:  \binom {C}{A} \rightarrow  k</tex>, there is some <tex>B'  \in   \binom {C}{B}</tex> with <tex display="block">c|_{ \binom {B'}{A}}</tex> constant.</p><p>Ramsey classes are highly related to descriptive set theory, in particular, extremely amenable sets.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>3</crumb></trail> <anchor>1506</anchor>  <taxon>Section</taxon> <addr>Smc-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-s001.tree</source-path> <route>Smc-s001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes</title> </frontmatter> <mainmatter><p>We define Smooth class constructions and their properties. Sources for this section are the papers <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic Structures</link> and <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Stable generic structures</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>3</crumb> <crumb>1</crumb></trail> <anchor>1507</anchor>  <taxon>Definition</taxon> <addr>Smc-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-d001.tree</source-path> <route>Smc-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of a Smooth Class</title> </frontmatter> <mainmatter><p>We assume the language <tex>\mathcal {L}</tex> is countable and only relational.</p><p>A class <tex>(K, \leq )</tex> of finite <tex>\mathcal {L}</tex>-structures (closed under isomorphism) is called <em>a smooth class</em> if <tex>\leq</tex> is transitive, <tex>A \leq  B  \Rightarrow  A \subsetq  B</tex>, and for each <tex>A \in  K</tex>, there is a set of universal formulas <tex>\Phi _A</tex> such that:
<tex display="block">A \leq  B  \Leftrightarrow  B \models   \Phi _A(A)</tex>
and we require that <tex>A \cong  A'  \Leftrightarrow   \Phi _A =  \Phi _{A'}</tex></p><p>This definition comes from <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic structures</link></p><p>An alternative definition, or characterization, from <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Baldwin and Shi</link>, is a class that satisfies the following:</p><p>If <tex>A \in  K</tex>, <tex>A \leq  A</tex></p><p>If <tex>A \leq  B</tex>, then <tex>A \subseteq  B</tex></p><p><tex>\leq</tex> is transitive</p><p>If <tex>A \leq  C</tex>, and <tex>A \subseteq  B \subseteq  C</tex>, then <tex>A \leq  B</tex> for <tex>A,B,C  \in  K</tex></p><p><tex>\emptyset \in  K</tex> and <tex>\emptyset   \leq  A</tex> for all <tex>A \in  K</tex></p><p>The only difference between these two characterizations is that in the first definition, we essentially stipulate that <tex>\leq</tex> is definable/determined by a 
set of universal formulas. This turns out to be an advantage in working with these classes. Certainly, classes satisfying the first definition will satisfy Baldwin-Shi's. In this way,
it is perhaps wiser to regard the second definition as a characterization as opposed to an actual definition.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>3</crumb> <crumb>2</crumb></trail> <anchor>1508</anchor>  <taxon>Example</taxon> <addr>Smc-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-e001.tree</source-path> <route>Smc-e001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ex: Initial Segments</title> </frontmatter> <mainmatter><p> Let <tex>(K, \leq _*)</tex> be the class of be finite, initial segements of the linear order <tex>( \omega , \leq )</tex>, where <tex>A \leq _* B</tex> is &quot;<tex>A</tex> is an initial segment of <tex>B</tex>&quot;.</p><p>It is clear that <tex>\leq</tex> fits into the definition of a smooth class, simply by the universal formula <tex>\Phi _A(y_1, \dots , y_n) =  \forall  x(( x=y_1 \lor \dots \lor  x=y_n)  \lor   \bigwedge _i^n x \geq  y_i)</tex></p><p>This class has <link href="Fra-d003.xml" type="local" title="Definition of Amalgamation Property (AP)">AP</link> and <link href="Fra-d004.xml" type="local" title="Definition of Joint Embedding Property (JEP)">JEP</link>, but not <link href="Fra-d005.xml" type="local" title="Definition of Hereditary Property (HP)">HP</link> or <link href="Fra-d006.xml" type="local" title="Definition of Disjoint Amalgamation Property (dAP)">dAP</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>3</crumb> <crumb>3</crumb></trail> <anchor>1509</anchor>  <taxon>Theorem</taxon> <addr>Smc-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t001.tree</source-path> <route>Smc-t001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Extension of Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \leq )</tex> is a smooth class of finite structures has the <link href="Fra-d003.xml" type="local" title="Definition of Amalgamation Property (AP)">amalgamation property</link> and the <link href="Fra-d004.xml" type="local" title="Definition of Joint Embedding Property (JEP)">joint embedding property</link>, 
then there is a unique, countable structure <tex>\mathcal {M}</tex>  with the following properties:</p><p>1. Any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \leq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>2. <tex>\mathcal {M} =  \bigcup ^ \omega _n A_n</tex> where <tex>A_n  \leq  A_{n+1}</tex> and for all <tex>n</tex>, <tex>A_n \in  K</tex></p><p>3. <tex>For every  A \in  K , there is an embedding  f:A \rightarrow  M  of  A  into  M  such that  f(A)  \leq  M</tex></p><p>The structure <tex>\mathcal {M}</tex> is the <em>generic</em>, or sometimes, the <em>limit</em> of <tex>K</tex>.</p><p>An equivalent characterization of a generic is properties 2 and 3 and the following property:</p><p>4. If <tex>A \leq  M</tex> and <tex>A \leq  B</tex> for <tex>B \in  K</tex>, then there is an isomorphism <tex>f: B \rightarrow  M</tex> extending the identity map <tex>id: A \rightarrow  M</tex> 
such that <tex>f(B)  \leq  M</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>3</crumb> <crumb>4</crumb></trail> <anchor>1510</anchor>  <taxon>Theorem</taxon> <addr>Smc-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t002.tree</source-path> <route>Smc-t002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes and Saturation</title> </frontmatter> <mainmatter><p>The following theorem first appears in <link href="" type="external">this paper</link> by Laskowski and Kueker</p><p>Let <tex>(K,  \leq )</tex> be a smooth class with a <link href="" type="external">generic</link> <tex>\mathcal {A}</tex>. If <tex>\mathcal {A}</tex> is weakly saturated, then <tex>\mathcal {A}</tex> is indeed saturated</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>3</crumb> <crumb>5</crumb></trail> <anchor>1511</anchor>  <taxon>Theorem</taxon> <addr>Smc-t003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t003.tree</source-path> <route>Smc-t003.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Generic of Smooth Class (Kueker &amp; Laskowski)</title> </frontmatter> <mainmatter><p>Let <tex>(K, \leq )</tex> be a smooth class with a generic <tex>\mathcal {A}</tex>. If for every <tex>A  \in  K</tex>, <tex>\Phi _A</tex> (see <link href="Smc-d001.xml" type="local" title="Definition of a Smooth Class">here</link>) consists of a single universal formula,
then <tex>\mathcal {A}</tex> is an atomic model.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb> <crumb>4</crumb></trail> <anchor>1512</anchor>  <taxon>Section</taxon> <addr>Fra-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s003.tree</source-path> <route>Fra-s003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Abstract Elementary Classes (AEC)s</title> </frontmatter> <mainmatter><p>We define AEC constructions and their properties</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb></trail> <anchor>1513</anchor>  <taxon>Part</taxon> <addr>mon-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-p001.tree</source-path> <route>mon-p001.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> <contributor><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></contributor></authors> <title>Dividing lines</title> </frontmatter> <mainmatter><p>Dividing lines play a fundamental role in model theory. They form the basis of Shelah's approach to classification theory and have been a central influence on model theory since their conception. Here is an interactive (though not complete) map of the <link href="https://forkinganddividing.com" type="external">model theoretic universe</link>, maintained by Gabriel Conant. Important examples of dividing lines include stability, NIP, and o-minimality.</p>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb> <crumb>1</crumb></trail> <anchor>1514</anchor>  <taxon>Section</taxon> <addr>mon-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/Stability/mon-s002.tree</source-path> <route>mon-s002.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Stability Theory</title> </frontmatter> <mainmatter><p><strong>Stable theories</strong></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb> <crumb>1</crumb> <crumb>1</crumb></trail> <anchor>1515</anchor>  <taxon>Subsection</taxon> <addr>mon-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/Stability/mon-s003.tree</source-path> <route>mon-s003.xml</route> <date><year>2024</year> <month>2</month> <day>10</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Forking and Dividing</title> </frontmatter> <mainmatter><p><strong>Forking and Dividing</strong></p></mainmatter> </tree></mainmatter> </tree>

    
    <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb> <crumb>2</crumb></trail> <anchor>1516</anchor>  <taxon>Section</taxon> <addr>mon-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-s001.tree</source-path> <route>mon-s001.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>NIP Theories</title> </frontmatter> <mainmatter><p><strong>NIP theories</strong> are a class of theories generalizing stable
theories, but allowing for an ordering. Aside from stable theories,
important examples are real closed fields, ACVF, <tex>p</tex>-adically closed
fields, and o-minimal theories</p><p>Fix a complete theory <tex>T</tex> with monster model <tex>\mathbb {M}</tex>.
Also fix a formula <tex>\varphi (x;y)</tex> with a fixed partitioning into
the two tuples <tex>x</tex> and <tex>y</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb> <crumb>2</crumb> <crumb>1</crumb></trail> <anchor>1517</anchor>  <taxon>Definition</taxon> <addr>mon-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d004.tree</source-path> <route>mon-d004.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Definition of the independence property</title> </frontmatter> <mainmatter><p>The formula <tex>\varphi (x;y)</tex> has the <em>independence property</em> if there
are sequences of tuples <tex>(a_i : i  \in   \omega )</tex> and
<tex>(b_S : S  \subseteq   \omega )</tex> such that for every subset <tex>S  \subseteq   \omega</tex>
<tex display="block">i  \in  S  \Longleftrightarrow   \mathbb {M}  \models   \varphi (a_i; b_S).</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb> <crumb>2</crumb> <crumb>2</crumb></trail> <anchor>1518</anchor>  <taxon>Definition</taxon> <addr>mon-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d005.tree</source-path> <route>mon-d005.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Definition of NIP</title> </frontmatter> <mainmatter><p>The formula <tex>\varphi (x;y)</tex> is said to be <em>NIP</em> if it does not have
the <link href="mon-0004" type="external">independence property</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb> <crumb>2</crumb> <crumb>3</crumb></trail> <anchor>1519</anchor>  <taxon>Theorem</taxon> <addr>mon-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-t001.tree</source-path> <route>mon-t001.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Characterizations of NIP for a formula</title> </frontmatter> <mainmatter><p>The following conditions are equivalent:
<ol><li> The formula <tex>\varphi (x;y)</tex> has the independence property.</li>
  <li> The formula <tex>\varphi ^{ \vee }(y;x)</tex> has the independence property,
	where <tex>\varphi ^{ \vee }(y;x)</tex> is the formula <tex>\varphi (x;y)</tex> with the
	opposite partition.</li>
	<li> For any two finite sets <tex>U</tex> and <tex>V</tex>, and any subset <tex>R  \subseteq  U  \times  V</tex>, there are <tex>(a_i : i  \in  U)</tex> and <tex>(b_j : j  \in  U)</tex> such that <tex>\mathbb   \models   \varphi (a_i;b_j)  \Longleftrightarrow  (i,j)  \in  R</tex>.</li>
	<li> There is an indiscernible sequence <tex>(a_i : i  \in   \omega )</tex>
	and some <tex>b</tex> such that <tex>\mathbb  M  \models   \varphi (a_i;b)  \Longleftrightarrow  i</tex>
	is even.</li></ol></p><p>We are also interested in the following characterization, which is more amenable to computations.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb> <crumb>2</crumb> <crumb>3</crumb> <crumb>1</crumb></trail> <anchor>1520</anchor>  <taxon>Definition</taxon> <addr>mon-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d007.tree</source-path> <route>mon-d007.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Alternation Number</title> </frontmatter> <mainmatter><p>The <em>alternation number</em> of a formula <tex>\varphi (x;y)</tex>, denoted <tex>\operatorname {alt}( \varphi (x;y))</tex> is the maximal number <tex>n  \in   \omega</tex> (if it exists) such that there is an indiscernible sequence <tex>(a_i : i  \in   \omega )</tex>, some <tex>b</tex>, and indices <tex>i_0 &lt;  \dots  &lt; i_n</tex> with <tex>\mathbb  M  \models   \varphi (a_i,b)  \Longleftrightarrow  i  \text { is even}</tex>. If no such maximum exists, we let <tex>\operatorname {alt}( \varphi (x;y)) =  \infty</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb> <crumb>2</crumb> <crumb>3</crumb> <crumb>2</crumb></trail> <anchor>1521</anchor>  <taxon>Lemma</taxon> <addr>mon-d008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d008.tree</source-path> <route>mon-d008.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Alternation Lemma</title> </frontmatter> <mainmatter><p>A formula <tex>\varphi (x;y)</tex> is NIP if and only if <tex>\operatorname {alt}( \varphi (x;y)) &lt;  \infty</tex>.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree>
</mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>5</crumb></trail> <anchor>1522</anchor>  <taxon>Part</taxon> <addr>inf-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Infinitary Logic/inf-p001.tree</source-path> <route>inf-p001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Infinitary Model Theory</title> </frontmatter> <mainmatter><p>We present the fundamentals of infinitary model theory. The main reference will be David Marker's book Lectures on Infinitary Logic</p></mainmatter> </tree>

  
  
</mainmatter> </tree></context> <related/> <backlinks/> <references/></backmatter></tree>