<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2622</anchor>  <taxon>Person</taxon> <addr>mbryant</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Authors/mbryant.tree</source-path> <route>mbryant.xml</route>   <title>Morgan Bryant</title> </frontmatter> <mainmatter><p>Doctorate student with interests in classical model theory, set theory, computability, and infinitary logic</p></mainmatter> <backmatter><contributions><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2623</anchor>  <taxon>Definition</taxon> <addr>Fra-d011</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d011.tree</source-path> <route>Fra-d011.xml</route> <date><year>2024</year> <month>4</month> <day>23</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Indivisible Property (Class version) on Embeddings (InvPE)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the indivisibility property on embeddings if for every <tex>A  \in  K</tex>, there is some <tex>C \in  K</tex>
such that for every <tex>k</tex>-coloring <tex>c: C \rightarrow  k</tex>, there is some strong embedding <tex>f:A \rightarrow  C</tex> such that <tex>c \circ  f</tex> is constant.</p><p>Citations Needed***</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2624</anchor>  <taxon>Definition</taxon> <addr>Fra-d010</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d010.tree</source-path> <route>Fra-d010.xml</route> <date><year>2024</year> <month>4</month> <day>23</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Indivisible Property (Class version) on Substructures (InvP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the indivisibility property on substructures if for every <tex>A  \in  K</tex>, there is some <tex>C \in  K</tex>
such that for every <tex>k</tex>-coloring <tex>c: C \rightarrow  k</tex>, there is some <tex>A' \leq  C</tex> such that <tex>A'  \cong  A</tex> with <tex display="block">c|_{A'}</tex> constant.</p><p>Indivisibility is a weakening of the Ramsey property. In some explicit cases, RPS implies InvP.</p><p>Citations Needed***</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2625</anchor>  <taxon>Theorem</taxon> <addr>Fra-t013</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-t013.tree</source-path> <route>Fra-t013.xml</route> <date><year>2024</year> <month>4</month> <day>23</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Kechris-Pestov-Todorcevic Theorem</title> </frontmatter> <mainmatter><p>For an an <link href="Fra-d012.xml" type="local" title="Order Class">order class</link> <tex>K</tex> which is Fraisse with limit <tex>M</tex>, the following are equivalent:</p><p>Aut(M) is extremely amenable</p><p><tex>K</tex> has the Ramsey Property.</p><p>Citations Needed***</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2626</anchor>  <taxon>Definition</taxon> <addr>Fra-d012</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d012.tree</source-path> <route>Fra-d012.xml</route> <date><year>2024</year> <month>4</month> <day>23</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Order Class</title> </frontmatter> <mainmatter><p>A class <tex>K</tex> in a language <tex>\mathcal {L}  \supseteq   \{ \leq \}</tex> is an <em>Order Class</em> if for every <tex>A \in  K</tex>, <tex>\leq</tex> is a linear ordering on <tex>A</tex></p><p>Citations Needed***</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2627</anchor>  <taxon>Section</taxon> <addr>Fra-ss01</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-ss01.tree</source-path> <route>Fra-ss01.xml</route> <date><year>2024</year> <month>4</month> <day>23</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ramsey Properties</title> </frontmatter> <mainmatter><p>We define different Ramsey properties on classes. </p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb></trail> <anchor>2628</anchor>  <taxon>Definition</taxon> <addr>Fra-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d007.tree</source-path> <route>Fra-d007.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ramsey Property on Substructures (RPS)</title> </frontmatter> <mainmatter><p>For structures <tex>A,B</tex>, let <tex>\binom {B}{A} =  \{ A_0: A_0 \leq  B &amp; ; A_0 \cong  B \}</tex></p><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the Ramsey property on substructures if for every <tex>A \leq  B  \in  K</tex>, there is some <tex>C \in  K</tex> with <tex>B \leq  C</tex>
such that for every <tex>k</tex>-coloring <tex>c:  \binom {C}{A} \rightarrow  k</tex>, there is some <tex>B'  \in   \binom {C}{B}</tex> with <tex display="block">c|_{ \binom {B'}{A}}</tex> constant.</p><p>Ramsey classes are highly related to descriptive set theory, in particular, extremely amenable sets.</p><p>Take care not to mix up RPS and <link href="Fra-d008.xml" type="local" title="Ramsey Property on Embeddings (RPE)">RPE</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb></trail> <anchor>2629</anchor>  <taxon>Definition</taxon> <addr>Fra-d008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d008.tree</source-path> <route>Fra-d008.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ramsey Property on Embeddings (RPE)</title> </frontmatter> <mainmatter><p>For structures <tex>A,B</tex>, let <tex>\binom {B}{A} =  \{ f:A \rightarrow  B : f  \;   \text {is an embedding } \}</tex></p><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the Ramsey property on embeddings if for every <tex>A \leq  B  \in  K</tex>, there is some <tex>C \in  K</tex> with <tex>B \leq  C</tex>
such that for every <tex>k</tex>-coloring <tex>c:  \binom {C}{A} \rightarrow  k</tex>, there is some <tex>B'  \in   \binom {C}{B}</tex> with <tex display="block">c|_{ \binom {B'}{A}}</tex> constant.</p><p>Ramsey classes are highly related to descriptive set theory, in particular, extremely amenable sets.</p><p>Take care not to mix up <link href="Fra-d007.xml" type="local" title="Ramsey Property on Substructures (RPS)">RPS</link> and RPE</p><p>The fundamental difference between RPS and RPE is that <tex>RPE  \Rightarrow  RPS</tex>, but the reverse implication is not true. Notice that if 
a class has RPE, then all structures are <link href="Fra-d009.xml" type="local" title="Rigid Structures">rigid</link>. There exist classes of structures which have RPS but not RPE, as they contain non-rigid structures. 
e.g., The class of structures with an equivalence relation, where the class is ordered by <tex>\subset</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb></trail> <anchor>2630</anchor>  <taxon>Definition</taxon> <addr>Fra-d009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d009.tree</source-path> <route>Fra-d009.xml</route> <date><year>2024</year> <month>4</month> <day>23</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Rigid Structures</title> </frontmatter> <mainmatter><p>A structure <tex>A</tex> in a language <tex>\mathcal {L}</tex> is called <em>rigid</em> if <tex>Aut(A)</tex> is trivial. I.e., the only automorphism of <tex>A</tex> is the identity.</p><p>Ex. Finite linear orders are rigid structures.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb></trail> <anchor>2631</anchor>  <taxon>Definition</taxon> <addr>Fra-d010</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d010.tree</source-path> <route>Fra-d010.xml</route> <date><year>2024</year> <month>4</month> <day>23</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Indivisible Property (Class version) on Substructures (InvP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the indivisibility property on substructures if for every <tex>A  \in  K</tex>, there is some <tex>C \in  K</tex>
such that for every <tex>k</tex>-coloring <tex>c: C \rightarrow  k</tex>, there is some <tex>A' \leq  C</tex> such that <tex>A'  \cong  A</tex> with <tex display="block">c|_{A'}</tex> constant.</p><p>Indivisibility is a weakening of the Ramsey property. In some explicit cases, RPS implies InvP.</p><p>Citations Needed***</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>5</crumb></trail> <anchor>2632</anchor>  <taxon>Definition</taxon> <addr>Fra-d011</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d011.tree</source-path> <route>Fra-d011.xml</route> <date><year>2024</year> <month>4</month> <day>23</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Indivisible Property (Class version) on Embeddings (InvPE)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the indivisibility property on embeddings if for every <tex>A  \in  K</tex>, there is some <tex>C \in  K</tex>
such that for every <tex>k</tex>-coloring <tex>c: C \rightarrow  k</tex>, there is some strong embedding <tex>f:A \rightarrow  C</tex> such that <tex>c \circ  f</tex> is constant.</p><p>Citations Needed***</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb></trail> <anchor>2633</anchor>  <taxon>Definition</taxon> <addr>Fra-d012</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d012.tree</source-path> <route>Fra-d012.xml</route> <date><year>2024</year> <month>4</month> <day>23</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Order Class</title> </frontmatter> <mainmatter><p>A class <tex>K</tex> in a language <tex>\mathcal {L}  \supseteq   \{ \leq \}</tex> is an <em>Order Class</em> if for every <tex>A \in  K</tex>, <tex>\leq</tex> is a linear ordering on <tex>A</tex></p><p>Citations Needed***</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>7</crumb></trail> <anchor>2634</anchor>  <taxon>Theorem</taxon> <addr>Fra-t013</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-t013.tree</source-path> <route>Fra-t013.xml</route> <date><year>2024</year> <month>4</month> <day>23</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Kechris-Pestov-Todorcevic Theorem</title> </frontmatter> <mainmatter><p>For an an <link href="Fra-d012.xml" type="local" title="Order Class">order class</link> <tex>K</tex> which is Fraisse with limit <tex>M</tex>, the following are equivalent:</p><p>Aut(M) is extremely amenable</p><p><tex>K</tex> has the Ramsey Property.</p><p>Citations Needed***</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2635</anchor>  <taxon>Definition</taxon> <addr>Fra-d009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d009.tree</source-path> <route>Fra-d009.xml</route> <date><year>2024</year> <month>4</month> <day>23</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Rigid Structures</title> </frontmatter> <mainmatter><p>A structure <tex>A</tex> in a language <tex>\mathcal {L}</tex> is called <em>rigid</em> if <tex>Aut(A)</tex> is trivial. I.e., the only automorphism of <tex>A</tex> is the identity.</p><p>Ex. Finite linear orders are rigid structures.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2636</anchor>  <taxon>Definition</taxon> <addr>Set-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d001.tree</source-path> <route>Set-d001.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Existentionality (AE)</title> </frontmatter> <mainmatter><p>The axiom of existentionality is as follows:</p><p><tex>\forall  x  \forall  y( x = y  \Leftrightarrow  ( \forall  z (z \in  x  \leftrightarrow  z \in  y)))</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2637</anchor>  <taxon>Definition</taxon> <addr>Set-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d005.tree</source-path> <route>Set-d005.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Infinity</title> </frontmatter> <mainmatter><p>The axiom of infinity is as follows:</p><p>*****</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2638</anchor>  <taxon>Definition</taxon> <addr>Set-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d002.tree</source-path> <route>Set-d002.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Pairing (PA)</title> </frontmatter> <mainmatter><p>The Pairing Axiom is as follows:</p><p><tex>\forall  x  \forall  y  \exists  z ( \forall  w(w \in  z  \leftrightarrow  (w= x \lor  w=y)))</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2639</anchor>  <taxon>Definition</taxon> <addr>Set-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d004.tree</source-path> <route>Set-d004.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Seperation (SA)</title> </frontmatter> <mainmatter><p>The axiom of seperation, or the seperation schema, is as follows:</p><p>If <tex>\varphi (x_1, \dots , x_n,z)</tex> is any formula in the appropriate language, then there exists a set <tex> y =  \{ z:  \varphi (x_1, \dots , x_n, z)</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2640</anchor>  <taxon>Definition</taxon> <addr>Set-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d003.tree</source-path> <route>Set-d003.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Union (UA)</title> </frontmatter> <mainmatter><p>The Union Axiom is as follows:</p><p><tex>\forall  x  \exists  z( \forall  y( y \in  z  \leftrightarrow  ( \exists  w  \in  x (y \in  w))))</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2641</anchor>  <taxon>Definition</taxon> <addr>DST-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-s001.tree</source-path> <route>DST-s001.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Basic DST</title> </frontmatter> <mainmatter><p>We give basic definitions of Borel sets, topology, polish spaces, Baire spaces, etc.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>8</crumb></trail> <anchor>2642</anchor>  <taxon>Definition</taxon> <addr>DST-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d001.tree</source-path> <route>DST-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Borel Sets</title> </frontmatter> <mainmatter><p>Given a topology, the Borel sets are the sets generated by closing the open sets under complementation and countable union.</p><p>A <tex>G_ \delta</tex> set is a Borel set formed by a countable intersection of open sets.</p><p>A <tex>F_ \sigma</tex> set is a Borel set formed by a countable union of closed sets.</p><p>(Recall a countable union of open sets is open, and a countable intersection is closed.)</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb></trail> <anchor>2643</anchor>  <taxon>Definition</taxon> <addr>DST-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d002.tree</source-path> <route>DST-d002.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Borel Hierarchy</title> </frontmatter> <mainmatter><p>Building off of the <link href="DST-d001.xml" type="local" title="Definition of Borel Sets">Borel sets</link>, welet <tex>\Sigma _0</tex> denote open sets, <tex>\Pi _0</tex> the closed sets, and then 
<tex display="block">\Sigma _n =  \{ \bigcup _i^ \omega  A_i : A_i  \in   \Pi _{n-1} \}</tex>
<tex display="block">\Pi _n =  \{ \bigcap _i^ \omega  A_i : A_i  \in   \Sigma _{n-1} \}</tex></p><p>This is the Borel Hierarchy, and it mirrors similar hierarchies in recursion theory. 
Notice in particular <tex>\Sigma _1</tex> is the set of <tex>F_ \sigma</tex> sets, <tex>\Pi _1</tex> is the set of <tex>G_ \delta</tex> sets. </p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>10</crumb></trail> <anchor>2644</anchor>  <taxon>Definition</taxon> <addr>DST-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d003.tree</source-path> <route>DST-d003.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Polish Space</title> </frontmatter> <mainmatter><p>Given a topological space <tex>X</tex>, <tex>X</tex> is a Polish space if <tex>X</tex> is completely metrisable and seperable</p><p>(Seperable = Second Countable = There is a dense, countable set in <tex>X</tex>)</p><p>(Completely metrisable = there is a metric on <tex>X</tex> which is complete = there is a metric on <tex>X</tex> so that every cauchy sequence 
has a limit)</p><p>Closed subsets of Polish spaces are themselves Polish (closed = the restricted metric is complete), Product and sums of topologies of Polish spaces are Polish</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>11</crumb></trail> <anchor>2645</anchor>  <taxon>Definition</taxon> <addr>DST-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d004.tree</source-path> <route>DST-d004.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Meagre and Comeagre Sets</title> </frontmatter> <mainmatter><p>Given a topological space <tex>X</tex>, <tex>A \subseteq  X</tex> is meagre if <tex display="block">A =  \bigcup _i^ \omega  A_i</tex> where the closure of <tex>A_i</tex> has empty interior (i.e., nowhere dense)</p><p>Comeagre sets are the complements of meagre sets</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2646</anchor>  <taxon>Part</taxon> <addr>DST-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/DST-p001.tree</source-path> <route>DST-p001.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Basics of Descriptive Set Theory and Relations to Model Theory</title> </frontmatter> <mainmatter><p>We present the basics of descriptive set theory (DST) and its relationship to model theory.</p><p>The main resource will be <link href="DST-r001.xml" type="local" title="Classical Descriptive Set Theory">Kechris's Classical Descriptive Set Theory</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>12</crumb></trail> <anchor>2647</anchor>  <taxon>Definition</taxon> <addr>DST-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-s001.tree</source-path> <route>DST-s001.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Basic DST</title> </frontmatter> <mainmatter><p>We give basic definitions of Borel sets, topology, polish spaces, Baire spaces, etc.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>12</crumb> <crumb>1</crumb></trail> <anchor>2648</anchor>  <taxon>Definition</taxon> <addr>DST-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d001.tree</source-path> <route>DST-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Borel Sets</title> </frontmatter> <mainmatter><p>Given a topology, the Borel sets are the sets generated by closing the open sets under complementation and countable union.</p><p>A <tex>G_ \delta</tex> set is a Borel set formed by a countable intersection of open sets.</p><p>A <tex>F_ \sigma</tex> set is a Borel set formed by a countable union of closed sets.</p><p>(Recall a countable union of open sets is open, and a countable intersection is closed.)</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>12</crumb> <crumb>2</crumb></trail> <anchor>2649</anchor>  <taxon>Definition</taxon> <addr>DST-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d002.tree</source-path> <route>DST-d002.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Borel Hierarchy</title> </frontmatter> <mainmatter><p>Building off of the <link href="DST-d001.xml" type="local" title="Definition of Borel Sets">Borel sets</link>, welet <tex>\Sigma _0</tex> denote open sets, <tex>\Pi _0</tex> the closed sets, and then 
<tex display="block">\Sigma _n =  \{ \bigcup _i^ \omega  A_i : A_i  \in   \Pi _{n-1} \}</tex>
<tex display="block">\Pi _n =  \{ \bigcap _i^ \omega  A_i : A_i  \in   \Sigma _{n-1} \}</tex></p><p>This is the Borel Hierarchy, and it mirrors similar hierarchies in recursion theory. 
Notice in particular <tex>\Sigma _1</tex> is the set of <tex>F_ \sigma</tex> sets, <tex>\Pi _1</tex> is the set of <tex>G_ \delta</tex> sets. </p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>12</crumb> <crumb>3</crumb></trail> <anchor>2650</anchor>  <taxon>Definition</taxon> <addr>DST-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d003.tree</source-path> <route>DST-d003.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Polish Space</title> </frontmatter> <mainmatter><p>Given a topological space <tex>X</tex>, <tex>X</tex> is a Polish space if <tex>X</tex> is completely metrisable and seperable</p><p>(Seperable = Second Countable = There is a dense, countable set in <tex>X</tex>)</p><p>(Completely metrisable = there is a metric on <tex>X</tex> which is complete = there is a metric on <tex>X</tex> so that every cauchy sequence 
has a limit)</p><p>Closed subsets of Polish spaces are themselves Polish (closed = the restricted metric is complete), Product and sums of topologies of Polish spaces are Polish</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>12</crumb> <crumb>4</crumb></trail> <anchor>2651</anchor>  <taxon>Definition</taxon> <addr>DST-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d004.tree</source-path> <route>DST-d004.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Meagre and Comeagre Sets</title> </frontmatter> <mainmatter><p>Given a topological space <tex>X</tex>, <tex>A \subseteq  X</tex> is meagre if <tex display="block">A =  \bigcup _i^ \omega  A_i</tex> where the closure of <tex>A_i</tex> has empty interior (i.e., nowhere dense)</p><p>Comeagre sets are the complements of meagre sets</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2652</anchor>  <taxon>Definition</taxon> <addr>DST-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d002.tree</source-path> <route>DST-d002.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Borel Hierarchy</title> </frontmatter> <mainmatter><p>Building off of the <link href="DST-d001.xml" type="local" title="Definition of Borel Sets">Borel sets</link>, welet <tex>\Sigma _0</tex> denote open sets, <tex>\Pi _0</tex> the closed sets, and then 
<tex display="block">\Sigma _n =  \{ \bigcup _i^ \omega  A_i : A_i  \in   \Pi _{n-1} \}</tex>
<tex display="block">\Pi _n =  \{ \bigcap _i^ \omega  A_i : A_i  \in   \Sigma _{n-1} \}</tex></p><p>This is the Borel Hierarchy, and it mirrors similar hierarchies in recursion theory. 
Notice in particular <tex>\Sigma _1</tex> is the set of <tex>F_ \sigma</tex> sets, <tex>\Pi _1</tex> is the set of <tex>G_ \delta</tex> sets. </p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2653</anchor>  <taxon>Definition</taxon> <addr>DST-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d004.tree</source-path> <route>DST-d004.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Meagre and Comeagre Sets</title> </frontmatter> <mainmatter><p>Given a topological space <tex>X</tex>, <tex>A \subseteq  X</tex> is meagre if <tex display="block">A =  \bigcup _i^ \omega  A_i</tex> where the closure of <tex>A_i</tex> has empty interior (i.e., nowhere dense)</p><p>Comeagre sets are the complements of meagre sets</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2654</anchor>  <taxon>Definition</taxon> <addr>DST-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d003.tree</source-path> <route>DST-d003.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Polish Space</title> </frontmatter> <mainmatter><p>Given a topological space <tex>X</tex>, <tex>X</tex> is a Polish space if <tex>X</tex> is completely metrisable and seperable</p><p>(Seperable = Second Countable = There is a dense, countable set in <tex>X</tex>)</p><p>(Completely metrisable = there is a metric on <tex>X</tex> which is complete = there is a metric on <tex>X</tex> so that every cauchy sequence 
has a limit)</p><p>Closed subsets of Polish spaces are themselves Polish (closed = the restricted metric is complete), Product and sums of topologies of Polish spaces are Polish</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2655</anchor>  <taxon>Definition</taxon> <addr>Fra-d008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d008.tree</source-path> <route>Fra-d008.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ramsey Property on Embeddings (RPE)</title> </frontmatter> <mainmatter><p>For structures <tex>A,B</tex>, let <tex>\binom {B}{A} =  \{ f:A \rightarrow  B : f  \;   \text {is an embedding } \}</tex></p><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the Ramsey property on embeddings if for every <tex>A \leq  B  \in  K</tex>, there is some <tex>C \in  K</tex> with <tex>B \leq  C</tex>
such that for every <tex>k</tex>-coloring <tex>c:  \binom {C}{A} \rightarrow  k</tex>, there is some <tex>B'  \in   \binom {C}{B}</tex> with <tex display="block">c|_{ \binom {B'}{A}}</tex> constant.</p><p>Ramsey classes are highly related to descriptive set theory, in particular, extremely amenable sets.</p><p>Take care not to mix up <link href="Fra-d007.xml" type="local" title="Ramsey Property on Substructures (RPS)">RPS</link> and RPE</p><p>The fundamental difference between RPS and RPE is that <tex>RPE  \Rightarrow  RPS</tex>, but the reverse implication is not true. Notice that if 
a class has RPE, then all structures are <link href="Fra-d009.xml" type="local" title="Rigid Structures">rigid</link>. There exist classes of structures which have RPS but not RPE, as they contain non-rigid structures. 
e.g., The class of structures with an equivalence relation, where the class is ordered by <tex>\subset</tex>.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2656</anchor>  <taxon>Definition</taxon> <addr>Fra-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d007.tree</source-path> <route>Fra-d007.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ramsey Property on Substructures (RPS)</title> </frontmatter> <mainmatter><p>For structures <tex>A,B</tex>, let <tex>\binom {B}{A} =  \{ A_0: A_0 \leq  B &amp; ; A_0 \cong  B \}</tex></p><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the Ramsey property on substructures if for every <tex>A \leq  B  \in  K</tex>, there is some <tex>C \in  K</tex> with <tex>B \leq  C</tex>
such that for every <tex>k</tex>-coloring <tex>c:  \binom {C}{A} \rightarrow  k</tex>, there is some <tex>B'  \in   \binom {C}{B}</tex> with <tex display="block">c|_{ \binom {B'}{A}}</tex> constant.</p><p>Ramsey classes are highly related to descriptive set theory, in particular, extremely amenable sets.</p><p>Take care not to mix up RPS and <link href="Fra-d008.xml" type="local" title="Ramsey Property on Embeddings (RPE)">RPE</link></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2657</anchor>  <taxon>Theorem</taxon> <addr>Smc-t003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t003.tree</source-path> <route>Smc-t003.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Generic of Smooth Class (Kueker &amp; Laskowski)</title> </frontmatter> <mainmatter><p>Let <tex>(K, \leq )</tex> be a smooth class with a generic <tex>\mathcal {A}</tex>. If for every <tex>A  \in  K</tex>, <tex>\Phi _A</tex> (see <link href="Smc-d001.xml" type="local" title="Smooth Class">here</link>) consists of a single universal formula,
then <tex>\mathcal {A}</tex> is an atomic model.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2658</anchor>  <taxon>Section</taxon> <addr>Set-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-s001.tree</source-path> <route>Set-s001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axioms of Set Theory</title> </frontmatter> <mainmatter><p>We describe the different set theory axioms and different accepted sets of these axioms, such as ZFC, ZFC+, etc.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>13</crumb></trail> <anchor>2659</anchor>  <taxon>Definition</taxon> <addr>Set-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d001.tree</source-path> <route>Set-d001.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Existentionality (AE)</title> </frontmatter> <mainmatter><p>The axiom of existentionality is as follows:</p><p><tex>\forall  x  \forall  y( x = y  \Leftrightarrow  ( \forall  z (z \in  x  \leftrightarrow  z \in  y)))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>14</crumb></trail> <anchor>2660</anchor>  <taxon>Definition</taxon> <addr>Set-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d002.tree</source-path> <route>Set-d002.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Pairing (PA)</title> </frontmatter> <mainmatter><p>The Pairing Axiom is as follows:</p><p><tex>\forall  x  \forall  y  \exists  z ( \forall  w(w \in  z  \leftrightarrow  (w= x \lor  w=y)))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>15</crumb></trail> <anchor>2661</anchor>  <taxon>Definition</taxon> <addr>Set-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d003.tree</source-path> <route>Set-d003.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Union (UA)</title> </frontmatter> <mainmatter><p>The Union Axiom is as follows:</p><p><tex>\forall  x  \exists  z( \forall  y( y \in  z  \leftrightarrow  ( \exists  w  \in  x (y \in  w))))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>16</crumb></trail> <anchor>2662</anchor>  <taxon>Definition</taxon> <addr>Set-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d004.tree</source-path> <route>Set-d004.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Seperation (SA)</title> </frontmatter> <mainmatter><p>The axiom of seperation, or the seperation schema, is as follows:</p><p>If <tex>\varphi (x_1, \dots , x_n,z)</tex> is any formula in the appropriate language, then there exists a set <tex> y =  \{ z:  \varphi (x_1, \dots , x_n, z)</tex></p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2663</anchor>  <taxon>Part</taxon> <addr>Set-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Set-p001.tree</source-path> <route>Set-p001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Basic Set Theory</title> </frontmatter> <mainmatter><p>In this part, we give some of the basic notions of set theory that are necessary to studying model theory. Topics include definitions of ZFC, set theory axioms, cardinals and ordinals, partial/linear orders,....</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>17</crumb></trail> <anchor>2664</anchor>  <taxon>Section</taxon> <addr>Set-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-s001.tree</source-path> <route>Set-s001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axioms of Set Theory</title> </frontmatter> <mainmatter><p>We describe the different set theory axioms and different accepted sets of these axioms, such as ZFC, ZFC+, etc.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>17</crumb> <crumb>1</crumb></trail> <anchor>2665</anchor>  <taxon>Definition</taxon> <addr>Set-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d001.tree</source-path> <route>Set-d001.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Existentionality (AE)</title> </frontmatter> <mainmatter><p>The axiom of existentionality is as follows:</p><p><tex>\forall  x  \forall  y( x = y  \Leftrightarrow  ( \forall  z (z \in  x  \leftrightarrow  z \in  y)))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>17</crumb> <crumb>2</crumb></trail> <anchor>2666</anchor>  <taxon>Definition</taxon> <addr>Set-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d002.tree</source-path> <route>Set-d002.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Pairing (PA)</title> </frontmatter> <mainmatter><p>The Pairing Axiom is as follows:</p><p><tex>\forall  x  \forall  y  \exists  z ( \forall  w(w \in  z  \leftrightarrow  (w= x \lor  w=y)))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>17</crumb> <crumb>3</crumb></trail> <anchor>2667</anchor>  <taxon>Definition</taxon> <addr>Set-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d003.tree</source-path> <route>Set-d003.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Union (UA)</title> </frontmatter> <mainmatter><p>The Union Axiom is as follows:</p><p><tex>\forall  x  \exists  z( \forall  y( y \in  z  \leftrightarrow  ( \exists  w  \in  x (y \in  w))))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>17</crumb> <crumb>4</crumb></trail> <anchor>2668</anchor>  <taxon>Definition</taxon> <addr>Set-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d004.tree</source-path> <route>Set-d004.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Seperation (SA)</title> </frontmatter> <mainmatter><p>The axiom of seperation, or the seperation schema, is as follows:</p><p>If <tex>\varphi (x_1, \dots , x_n,z)</tex> is any formula in the appropriate language, then there exists a set <tex> y =  \{ z:  \varphi (x_1, \dots , x_n, z)</tex></p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2669</anchor>  <taxon>Definition</taxon> <addr>DST-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d001.tree</source-path> <route>DST-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Borel Sets</title> </frontmatter> <mainmatter><p>Given a topology, the Borel sets are the sets generated by closing the open sets under complementation and countable union.</p><p>A <tex>G_ \delta</tex> set is a Borel set formed by a countable intersection of open sets.</p><p>A <tex>F_ \sigma</tex> set is a Borel set formed by a countable union of closed sets.</p><p>(Recall a countable union of open sets is open, and a countable intersection is closed.)</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2670</anchor>  <taxon>Definition</taxon> <addr>Fra-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d006.tree</source-path> <route>Fra-d006.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Disjoint Amalgamation Property (dAP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Disjoint Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex> such that <tex>B \cap  C =A</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex>, <tex>h_2(f(A)) = h_1(g(A))</tex>, and <tex>h_2(C)  \cap  h_1(B) = h_1(A)</tex></p><p>An example of a class which has the dAP is the <link href="Fra-e001.xml" type="local" title="The Random Graph">Fraisse class of finite graphs</link></p><p>An example of a smooth class which does not have the dAP is <link href="Smc-e001.xml" type="local" title="Initial Segments">The class of initial segments</link></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2671</anchor>  <taxon>Example</taxon> <addr>Smc-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-e001.tree</source-path> <route>Smc-e001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Initial Segments</title> </frontmatter> <mainmatter><p> Let <tex>(K, \leq _*)</tex> be the class of be finite, initial segements of the linear order <tex>( \omega , \leq )</tex>, where <tex>A \leq _* B</tex> is &quot;<tex>A</tex> is an initial segment of <tex>B</tex>&quot;.</p><p>It is clear that <tex>\leq</tex> fits into the definition of a smooth class, simply by the universal formula <tex>\Phi _A(y_1, \dots , y_n) =  \forall  x(( x=y_1 \lor \dots \lor  x=y_n)  \lor   \bigwedge _i^n x \geq  y_i)</tex></p><p>This class has <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">AP</link> and <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">JEP</link>, but not <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">HP</link> or <link href="Fra-d006.xml" type="local" title="Disjoint Amalgamation Property (dAP)">dAP</link></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2672</anchor>  <taxon>Section</taxon> <addr>Fra-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s002.tree</source-path> <route>Fra-s002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Other Properties of Classes</title> </frontmatter> <mainmatter><p>We define other common properties and variants of the set up shown in the <link href="Fra-s001.xml" type="local" title="Fraisse Classes">Fraisse section</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>18</crumb></trail> <anchor>2673</anchor>  <taxon>Definition</taxon> <addr>Fra-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d006.tree</source-path> <route>Fra-d006.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Disjoint Amalgamation Property (dAP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Disjoint Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex> such that <tex>B \cap  C =A</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex>, <tex>h_2(f(A)) = h_1(g(A))</tex>, and <tex>h_2(C)  \cap  h_1(B) = h_1(A)</tex></p><p>An example of a class which has the dAP is the <link href="Fra-e001.xml" type="local" title="The Random Graph">Fraisse class of finite graphs</link></p><p>An example of a smooth class which does not have the dAP is <link href="Smc-e001.xml" type="local" title="Initial Segments">The class of initial segments</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>19</crumb></trail> <anchor>2674</anchor>  <taxon>Definition</taxon> <addr>Fra-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d007.tree</source-path> <route>Fra-d007.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ramsey Property on Substructures (RPS)</title> </frontmatter> <mainmatter><p>For structures <tex>A,B</tex>, let <tex>\binom {B}{A} =  \{ A_0: A_0 \leq  B &amp; ; A_0 \cong  B \}</tex></p><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the Ramsey property on substructures if for every <tex>A \leq  B  \in  K</tex>, there is some <tex>C \in  K</tex> with <tex>B \leq  C</tex>
such that for every <tex>k</tex>-coloring <tex>c:  \binom {C}{A} \rightarrow  k</tex>, there is some <tex>B'  \in   \binom {C}{B}</tex> with <tex display="block">c|_{ \binom {B'}{A}}</tex> constant.</p><p>Ramsey classes are highly related to descriptive set theory, in particular, extremely amenable sets.</p><p>Take care not to mix up RPS and <link href="Fra-d008.xml" type="local" title="Ramsey Property on Embeddings (RPE)">RPE</link></p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2675</anchor>  <taxon>Definition</taxon> <addr>Smc-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-d001.tree</source-path> <route>Smc-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Class</title> </frontmatter> <mainmatter><p>We assume the language <tex>\mathcal {L}</tex> is countable and only relational.</p><p>A class <tex>(K, \leq )</tex> of finite <tex>\mathcal {L}</tex>-structures (closed under isomorphism) is called <em>a smooth class</em> if <tex>\leq</tex> is transitive, <tex>A \leq  B  \Rightarrow  A \subsetq  B</tex>, and for each <tex>A \in  K</tex>, there is a set of universal formulas <tex>\Phi _A</tex> such that:
<tex display="block">A \leq  B  \Leftrightarrow  B \models   \Phi _A(A)</tex>
and we require that <tex>A \cong  A'  \Leftrightarrow   \Phi _A =  \Phi _{A'}</tex></p><p>This definition comes from <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic structures</link></p><p>An alternative definition, or characterization, from <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Baldwin and Shi</link>, is a class that satisfies the following:</p><p>If <tex>A \in  K</tex>, <tex>A \leq  A</tex></p><p>If <tex>A \leq  B</tex>, then <tex>A \subseteq  B</tex></p><p><tex>\leq</tex> is transitive</p><p>If <tex>A \leq  C</tex>, and <tex>A \subseteq  B \subseteq  C</tex>, then <tex>A \leq  B</tex> for <tex>A,B,C  \in  K</tex></p><p><tex>\emptyset \in  K</tex> and <tex>\emptyset   \leq  A</tex> for all <tex>A \in  K</tex></p><p>The only difference between these two characterizations is that in the first definition, we essentially stipulate that <tex>\leq</tex> is definable/determined by a 
set of universal formulas. This turns out to be an advantage in working with these classes. Certainly, classes satisfying the first definition will satisfy Baldwin-Shi's. In this way,
it is perhaps wiser to regard the second definition as a characterization as opposed to an actual definition.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2676</anchor>  <taxon>Theorem</taxon> <addr>Smc-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t002.tree</source-path> <route>Smc-t002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes and Saturation</title> </frontmatter> <mainmatter><p>The following theorem first appears in <link href="" type="external">this paper</link> by Laskowski and Kueker</p><p>Let <tex>(K,  \leq )</tex> be a smooth class with a <link href="" type="external">generic</link> <tex>\mathcal {A}</tex>. If <tex>\mathcal {A}</tex> is weakly saturated, then <tex>\mathcal {A}</tex> is indeed saturated</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2677</anchor>  <taxon>Theorem</taxon> <addr>Smc-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t001.tree</source-path> <route>Smc-t001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Extension of Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \leq )</tex> is a smooth class of finite structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link> and the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, 
then there is a unique, countable structure <tex>\mathcal {M}</tex>  with the following properties:</p><p>1. Any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \leq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>2. <tex>\mathcal {M} =  \bigcup ^ \omega _n A_n</tex> where <tex>A_n  \leq  A_{n+1}</tex> and for all <tex>n</tex>, <tex>A_n \in  K</tex></p><p>3. For every <tex>A \in  K</tex>, there is an embedding <tex>f:A \rightarrow  M</tex> of <tex>A</tex> into <tex>M</tex> such that <tex>f(A)  \leq  M</tex></p><p>The structure <tex>\mathcal {M}</tex> is the <em>generic</em>, or sometimes, the <em>limit</em> of <tex>K</tex>.</p><p>An equivalent characterization of a generic is properties 2 and 3 and the following property:</p><p>4. If <tex>A \leq  M</tex> and <tex>A \leq  B</tex> for <tex>B \in  K</tex>, then there is an isomorphism <tex>f: B \rightarrow  M</tex> extending the identity map <tex>id: A \rightarrow  M</tex> 
such that <tex>f(B)  \leq  M</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2678</anchor>  <taxon>Example</taxon> <addr>Fra-e002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e002.tree</source-path> <route>Fra-e002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>( \mathbb {Q},  \leq )</tex></title> </frontmatter> <mainmatter><p>The Dense Linear Order <tex>( \mathbb {Q},  \leq )</tex> is the Fraisse Limit of the class of all finite linear orders</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2679</anchor>  <taxon>Section</taxon> <addr>Fra-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s003.tree</source-path> <route>Fra-s003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Abstract Elementary Classes (AEC)s</title> </frontmatter> <mainmatter><p>We define AEC constructions and their properties</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2680</anchor>  <taxon>Definition</taxon> <addr>Fra-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d002.tree</source-path> <route>Fra-d002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Age</title> </frontmatter> <mainmatter><p>Given a structure <tex>A</tex> in a language <tex>\mathcal {L}</tex>, the <em>Age</em> (pronounced ah-zh) of <tex>A</tex> is <tex display="block">\{ B \subseteq  A: B  \text { is finitely generated } \}</tex></p><p>The age of a structure is itself a class, often under the relation of substructure</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2681</anchor>  <taxon>Definition</taxon> <addr>Fra-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d003.tree</source-path> <route>Fra-d003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Amalgamation Property (AP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex> and <tex>h_2(f(A)) = h_1(g(A))</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2682</anchor>  <taxon>Definition</taxon> <addr>Fra-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d001.tree</source-path> <route>Fra-d001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Class of Structures</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, a class <tex>K</tex> is defined to be a set of <tex>\mathcal {L}</tex>-structures</p><p>Often, we want there to be a relation <tex>\leq</tex> acting on the structures in <tex>K</tex>, and when we do, we write the class and relation as a pair <tex>(K,  \leq )</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2683</anchor>  <taxon>Section</taxon> <addr>Fra-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s001.tree</source-path> <route>Fra-s001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse Classes</title> </frontmatter> <mainmatter><p>We define Fraisse constructions and their properties. Most of the concepts can be referred to in <link href="Ref-0001.xml" type="local" title="Model Theory by Wilfred Hodges">Wilfred Hodges' Model Theory</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>20</crumb></trail> <anchor>2684</anchor>  <taxon>Definition</taxon> <addr>Fra-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d001.tree</source-path> <route>Fra-d001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Class of Structures</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, a class <tex>K</tex> is defined to be a set of <tex>\mathcal {L}</tex>-structures</p><p>Often, we want there to be a relation <tex>\leq</tex> acting on the structures in <tex>K</tex>, and when we do, we write the class and relation as a pair <tex>(K,  \leq )</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>21</crumb></trail> <anchor>2685</anchor>  <taxon>Definition</taxon> <addr>Fra-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d002.tree</source-path> <route>Fra-d002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Age</title> </frontmatter> <mainmatter><p>Given a structure <tex>A</tex> in a language <tex>\mathcal {L}</tex>, the <em>Age</em> (pronounced ah-zh) of <tex>A</tex> is <tex display="block">\{ B \subseteq  A: B  \text { is finitely generated } \}</tex></p><p>The age of a structure is itself a class, often under the relation of substructure</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>22</crumb></trail> <anchor>2686</anchor>  <taxon>Definition</taxon> <addr>Fra-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d003.tree</source-path> <route>Fra-d003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Amalgamation Property (AP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex> and <tex>h_2(f(A)) = h_1(g(A))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>23</crumb></trail> <anchor>2687</anchor>  <taxon>Definition</taxon> <addr>Fra-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d004.tree</source-path> <route>Fra-d004.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Joint Embedding Property (JEP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B  \in  K</tex>, there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex></p><p><link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">Amalgamation Property</link> does NOT necessarily imply JEP, unless the empty set <tex>\emptyset</tex> is in <tex>K</tex> and for all <tex>A \in  K</tex>, we have that <tex>\emptyset   \leq  A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>24</crumb></trail> <anchor>2688</anchor>  <taxon>Definition</taxon> <addr>Fra-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d005.tree</source-path> <route>Fra-d005.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Hereditary Property (HP)</title> </frontmatter> <mainmatter><p>A class <tex>(K, \leq )</tex> has the hereditary property if for every <tex>A \in  K</tex>, and any <tex>B \subseteq  A</tex> finitely generated, then there is some <tex>C \in  K</tex> such that <tex>C \cong  B</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>25</crumb></trail> <anchor>2689</anchor>  <taxon>Theorem</taxon> <addr>Fra-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t001.tree</source-path> <route>Fra-t001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \subset )</tex> a class of finitely generated structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link>, the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, and the <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">hereditary property</link>, 
Then there is a unique, countable structure <tex>\mathcal {M}</tex> whose <link href="Fra-d002.xml" type="local" title="Age">age</link> is <tex>K</tex> with the property that any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \subseteq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>The structure <tex>\mathcal {M}</tex> is the <em>Fraisse limit</em> of <tex>K</tex>.</p><p>We call a class <tex>(K, \subseteq )</tex> satisfying AP, HP, and JEP a Fraisse class</p><p>When a structure has the above isomorphism extension property, we say it is <em>ultrahomogeneous</em> (or <em>homogeneous</em>). 
The converse of Fraisse's Theorem is also true in the sense that if we have a structure which is ultrahomogeneous with respect to its age, then its age is a Fraisse class.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>26</crumb></trail> <anchor>2690</anchor>  <taxon>Theorem</taxon> <addr>Fra-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t002.tree</source-path> <route>Fra-t002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Properties of a Fraisse Limit</title> </frontmatter> <mainmatter><p>If <tex>M</tex> is the <link href="Fra-t001.xml" type="local" title="Fraisse's Theorem">Fraisse Limit</link> of a class <tex>(K,  \leq )</tex>, then <tex>Th(M)</tex> has quantifier elimination and is <tex>\omega</tex>-categorical</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>27</crumb></trail> <anchor>2691</anchor>  <taxon>Example</taxon> <addr>Fra-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e001.tree</source-path> <route>Fra-e001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>The Random Graph</title> </frontmatter> <mainmatter><p>Rado's famous random graph is indeed the Fraisse Limit of the class of finite graphs in the language <tex>\mathcal {L} =  \{ E \}</tex> where <tex>E</tex> is a binary relation representing &quot;there is an edge&quot; between two points.</p><p>More precisely, a graph is an <tex>\mathcal {L}-</tex>structure for which <tex>E</tex> is anti-reflexive and symmetric.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>28</crumb></trail> <anchor>2692</anchor>  <taxon>Example</taxon> <addr>Fra-e002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e002.tree</source-path> <route>Fra-e002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>( \mathbb {Q},  \leq )</tex></title> </frontmatter> <mainmatter><p>The Dense Linear Order <tex>( \mathbb {Q},  \leq )</tex> is the Fraisse Limit of the class of all finite linear orders</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2693</anchor>  <taxon>Part</taxon> <addr>Fra-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-p001.tree</source-path> <route>Fra-p001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse Classes and Variants</title> </frontmatter> <mainmatter><p>We present Fraisse Classes, Smooth classes, and related results and variants.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>29</crumb></trail> <anchor>2694</anchor>  <taxon>Section</taxon> <addr>Fra-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s001.tree</source-path> <route>Fra-s001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse Classes</title> </frontmatter> <mainmatter><p>We define Fraisse constructions and their properties. Most of the concepts can be referred to in <link href="Ref-0001.xml" type="local" title="Model Theory by Wilfred Hodges">Wilfred Hodges' Model Theory</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>29</crumb> <crumb>1</crumb></trail> <anchor>2695</anchor>  <taxon>Definition</taxon> <addr>Fra-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d001.tree</source-path> <route>Fra-d001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Class of Structures</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, a class <tex>K</tex> is defined to be a set of <tex>\mathcal {L}</tex>-structures</p><p>Often, we want there to be a relation <tex>\leq</tex> acting on the structures in <tex>K</tex>, and when we do, we write the class and relation as a pair <tex>(K,  \leq )</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>29</crumb> <crumb>2</crumb></trail> <anchor>2696</anchor>  <taxon>Definition</taxon> <addr>Fra-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d002.tree</source-path> <route>Fra-d002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Age</title> </frontmatter> <mainmatter><p>Given a structure <tex>A</tex> in a language <tex>\mathcal {L}</tex>, the <em>Age</em> (pronounced ah-zh) of <tex>A</tex> is <tex display="block">\{ B \subseteq  A: B  \text { is finitely generated } \}</tex></p><p>The age of a structure is itself a class, often under the relation of substructure</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>29</crumb> <crumb>3</crumb></trail> <anchor>2697</anchor>  <taxon>Definition</taxon> <addr>Fra-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d003.tree</source-path> <route>Fra-d003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Amalgamation Property (AP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex> and <tex>h_2(f(A)) = h_1(g(A))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>29</crumb> <crumb>4</crumb></trail> <anchor>2698</anchor>  <taxon>Definition</taxon> <addr>Fra-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d004.tree</source-path> <route>Fra-d004.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Joint Embedding Property (JEP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B  \in  K</tex>, there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex></p><p><link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">Amalgamation Property</link> does NOT necessarily imply JEP, unless the empty set <tex>\emptyset</tex> is in <tex>K</tex> and for all <tex>A \in  K</tex>, we have that <tex>\emptyset   \leq  A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>29</crumb> <crumb>5</crumb></trail> <anchor>2699</anchor>  <taxon>Definition</taxon> <addr>Fra-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d005.tree</source-path> <route>Fra-d005.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Hereditary Property (HP)</title> </frontmatter> <mainmatter><p>A class <tex>(K, \leq )</tex> has the hereditary property if for every <tex>A \in  K</tex>, and any <tex>B \subseteq  A</tex> finitely generated, then there is some <tex>C \in  K</tex> such that <tex>C \cong  B</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>29</crumb> <crumb>6</crumb></trail> <anchor>2700</anchor>  <taxon>Theorem</taxon> <addr>Fra-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t001.tree</source-path> <route>Fra-t001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \subset )</tex> a class of finitely generated structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link>, the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, and the <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">hereditary property</link>, 
Then there is a unique, countable structure <tex>\mathcal {M}</tex> whose <link href="Fra-d002.xml" type="local" title="Age">age</link> is <tex>K</tex> with the property that any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \subseteq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>The structure <tex>\mathcal {M}</tex> is the <em>Fraisse limit</em> of <tex>K</tex>.</p><p>We call a class <tex>(K, \subseteq )</tex> satisfying AP, HP, and JEP a Fraisse class</p><p>When a structure has the above isomorphism extension property, we say it is <em>ultrahomogeneous</em> (or <em>homogeneous</em>). 
The converse of Fraisse's Theorem is also true in the sense that if we have a structure which is ultrahomogeneous with respect to its age, then its age is a Fraisse class.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>29</crumb> <crumb>7</crumb></trail> <anchor>2701</anchor>  <taxon>Theorem</taxon> <addr>Fra-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t002.tree</source-path> <route>Fra-t002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Properties of a Fraisse Limit</title> </frontmatter> <mainmatter><p>If <tex>M</tex> is the <link href="Fra-t001.xml" type="local" title="Fraisse's Theorem">Fraisse Limit</link> of a class <tex>(K,  \leq )</tex>, then <tex>Th(M)</tex> has quantifier elimination and is <tex>\omega</tex>-categorical</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>29</crumb> <crumb>8</crumb></trail> <anchor>2702</anchor>  <taxon>Example</taxon> <addr>Fra-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e001.tree</source-path> <route>Fra-e001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>The Random Graph</title> </frontmatter> <mainmatter><p>Rado's famous random graph is indeed the Fraisse Limit of the class of finite graphs in the language <tex>\mathcal {L} =  \{ E \}</tex> where <tex>E</tex> is a binary relation representing &quot;there is an edge&quot; between two points.</p><p>More precisely, a graph is an <tex>\mathcal {L}-</tex>structure for which <tex>E</tex> is anti-reflexive and symmetric.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>29</crumb> <crumb>9</crumb></trail> <anchor>2703</anchor>  <taxon>Example</taxon> <addr>Fra-e002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e002.tree</source-path> <route>Fra-e002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>( \mathbb {Q},  \leq )</tex></title> </frontmatter> <mainmatter><p>The Dense Linear Order <tex>( \mathbb {Q},  \leq )</tex> is the Fraisse Limit of the class of all finite linear orders</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>30</crumb></trail> <anchor>2704</anchor>  <taxon>Section</taxon> <addr>Fra-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s002.tree</source-path> <route>Fra-s002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Other Properties of Classes</title> </frontmatter> <mainmatter><p>We define other common properties and variants of the set up shown in the <link href="Fra-s001.xml" type="local" title="Fraisse Classes">Fraisse section</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>30</crumb> <crumb>1</crumb></trail> <anchor>2705</anchor>  <taxon>Definition</taxon> <addr>Fra-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d006.tree</source-path> <route>Fra-d006.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Disjoint Amalgamation Property (dAP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Disjoint Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex> such that <tex>B \cap  C =A</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex>, <tex>h_2(f(A)) = h_1(g(A))</tex>, and <tex>h_2(C)  \cap  h_1(B) = h_1(A)</tex></p><p>An example of a class which has the dAP is the <link href="Fra-e001.xml" type="local" title="The Random Graph">Fraisse class of finite graphs</link></p><p>An example of a smooth class which does not have the dAP is <link href="Smc-e001.xml" type="local" title="Initial Segments">The class of initial segments</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>30</crumb> <crumb>2</crumb></trail> <anchor>2706</anchor>  <taxon>Definition</taxon> <addr>Fra-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d007.tree</source-path> <route>Fra-d007.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ramsey Property on Substructures (RPS)</title> </frontmatter> <mainmatter><p>For structures <tex>A,B</tex>, let <tex>\binom {B}{A} =  \{ A_0: A_0 \leq  B &amp; ; A_0 \cong  B \}</tex></p><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the Ramsey property on substructures if for every <tex>A \leq  B  \in  K</tex>, there is some <tex>C \in  K</tex> with <tex>B \leq  C</tex>
such that for every <tex>k</tex>-coloring <tex>c:  \binom {C}{A} \rightarrow  k</tex>, there is some <tex>B'  \in   \binom {C}{B}</tex> with <tex display="block">c|_{ \binom {B'}{A}}</tex> constant.</p><p>Ramsey classes are highly related to descriptive set theory, in particular, extremely amenable sets.</p><p>Take care not to mix up RPS and <link href="Fra-d008.xml" type="local" title="Ramsey Property on Embeddings (RPE)">RPE</link></p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>31</crumb></trail> <anchor>2707</anchor>  <taxon>Section</taxon> <addr>Smc-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-s001.tree</source-path> <route>Smc-s001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes</title> </frontmatter> <mainmatter><p>We define Smooth class constructions and their properties. Sources for this section are the papers <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic Structures</link> and <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Stable generic structures</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>31</crumb> <crumb>1</crumb></trail> <anchor>2708</anchor>  <taxon>Definition</taxon> <addr>Smc-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-d001.tree</source-path> <route>Smc-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Class</title> </frontmatter> <mainmatter><p>We assume the language <tex>\mathcal {L}</tex> is countable and only relational.</p><p>A class <tex>(K, \leq )</tex> of finite <tex>\mathcal {L}</tex>-structures (closed under isomorphism) is called <em>a smooth class</em> if <tex>\leq</tex> is transitive, <tex>A \leq  B  \Rightarrow  A \subsetq  B</tex>, and for each <tex>A \in  K</tex>, there is a set of universal formulas <tex>\Phi _A</tex> such that:
<tex display="block">A \leq  B  \Leftrightarrow  B \models   \Phi _A(A)</tex>
and we require that <tex>A \cong  A'  \Leftrightarrow   \Phi _A =  \Phi _{A'}</tex></p><p>This definition comes from <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic structures</link></p><p>An alternative definition, or characterization, from <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Baldwin and Shi</link>, is a class that satisfies the following:</p><p>If <tex>A \in  K</tex>, <tex>A \leq  A</tex></p><p>If <tex>A \leq  B</tex>, then <tex>A \subseteq  B</tex></p><p><tex>\leq</tex> is transitive</p><p>If <tex>A \leq  C</tex>, and <tex>A \subseteq  B \subseteq  C</tex>, then <tex>A \leq  B</tex> for <tex>A,B,C  \in  K</tex></p><p><tex>\emptyset \in  K</tex> and <tex>\emptyset   \leq  A</tex> for all <tex>A \in  K</tex></p><p>The only difference between these two characterizations is that in the first definition, we essentially stipulate that <tex>\leq</tex> is definable/determined by a 
set of universal formulas. This turns out to be an advantage in working with these classes. Certainly, classes satisfying the first definition will satisfy Baldwin-Shi's. In this way,
it is perhaps wiser to regard the second definition as a characterization as opposed to an actual definition.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>31</crumb> <crumb>2</crumb></trail> <anchor>2709</anchor>  <taxon>Example</taxon> <addr>Smc-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-e001.tree</source-path> <route>Smc-e001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Initial Segments</title> </frontmatter> <mainmatter><p> Let <tex>(K, \leq _*)</tex> be the class of be finite, initial segements of the linear order <tex>( \omega , \leq )</tex>, where <tex>A \leq _* B</tex> is &quot;<tex>A</tex> is an initial segment of <tex>B</tex>&quot;.</p><p>It is clear that <tex>\leq</tex> fits into the definition of a smooth class, simply by the universal formula <tex>\Phi _A(y_1, \dots , y_n) =  \forall  x(( x=y_1 \lor \dots \lor  x=y_n)  \lor   \bigwedge _i^n x \geq  y_i)</tex></p><p>This class has <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">AP</link> and <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">JEP</link>, but not <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">HP</link> or <link href="Fra-d006.xml" type="local" title="Disjoint Amalgamation Property (dAP)">dAP</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>31</crumb> <crumb>3</crumb></trail> <anchor>2710</anchor>  <taxon>Theorem</taxon> <addr>Smc-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t001.tree</source-path> <route>Smc-t001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Extension of Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \leq )</tex> is a smooth class of finite structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link> and the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, 
then there is a unique, countable structure <tex>\mathcal {M}</tex>  with the following properties:</p><p>1. Any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \leq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>2. <tex>\mathcal {M} =  \bigcup ^ \omega _n A_n</tex> where <tex>A_n  \leq  A_{n+1}</tex> and for all <tex>n</tex>, <tex>A_n \in  K</tex></p><p>3. For every <tex>A \in  K</tex>, there is an embedding <tex>f:A \rightarrow  M</tex> of <tex>A</tex> into <tex>M</tex> such that <tex>f(A)  \leq  M</tex></p><p>The structure <tex>\mathcal {M}</tex> is the <em>generic</em>, or sometimes, the <em>limit</em> of <tex>K</tex>.</p><p>An equivalent characterization of a generic is properties 2 and 3 and the following property:</p><p>4. If <tex>A \leq  M</tex> and <tex>A \leq  B</tex> for <tex>B \in  K</tex>, then there is an isomorphism <tex>f: B \rightarrow  M</tex> extending the identity map <tex>id: A \rightarrow  M</tex> 
such that <tex>f(B)  \leq  M</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>31</crumb> <crumb>4</crumb></trail> <anchor>2711</anchor>  <taxon>Theorem</taxon> <addr>Smc-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t002.tree</source-path> <route>Smc-t002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes and Saturation</title> </frontmatter> <mainmatter><p>The following theorem first appears in <link href="" type="external">this paper</link> by Laskowski and Kueker</p><p>Let <tex>(K,  \leq )</tex> be a smooth class with a <link href="" type="external">generic</link> <tex>\mathcal {A}</tex>. If <tex>\mathcal {A}</tex> is weakly saturated, then <tex>\mathcal {A}</tex> is indeed saturated</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>31</crumb> <crumb>5</crumb></trail> <anchor>2712</anchor>  <taxon>Theorem</taxon> <addr>Smc-t003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t003.tree</source-path> <route>Smc-t003.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Generic of Smooth Class (Kueker &amp; Laskowski)</title> </frontmatter> <mainmatter><p>Let <tex>(K, \leq )</tex> be a smooth class with a generic <tex>\mathcal {A}</tex>. If for every <tex>A  \in  K</tex>, <tex>\Phi _A</tex> (see <link href="Smc-d001.xml" type="local" title="Smooth Class">here</link>) consists of a single universal formula,
then <tex>\mathcal {A}</tex> is an atomic model.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>32</crumb></trail> <anchor>2713</anchor>  <taxon>Section</taxon> <addr>Fra-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s003.tree</source-path> <route>Fra-s003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Abstract Elementary Classes (AEC)s</title> </frontmatter> <mainmatter><p>We define AEC constructions and their properties</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2714</anchor>  <taxon>Theorem</taxon> <addr>Fra-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t001.tree</source-path> <route>Fra-t001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \subset )</tex> a class of finitely generated structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link>, the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, and the <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">hereditary property</link>, 
Then there is a unique, countable structure <tex>\mathcal {M}</tex> whose <link href="Fra-d002.xml" type="local" title="Age">age</link> is <tex>K</tex> with the property that any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \subseteq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>The structure <tex>\mathcal {M}</tex> is the <em>Fraisse limit</em> of <tex>K</tex>.</p><p>We call a class <tex>(K, \subseteq )</tex> satisfying AP, HP, and JEP a Fraisse class</p><p>When a structure has the above isomorphism extension property, we say it is <em>ultrahomogeneous</em> (or <em>homogeneous</em>). 
The converse of Fraisse's Theorem is also true in the sense that if we have a structure which is ultrahomogeneous with respect to its age, then its age is a Fraisse class.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2715</anchor>  <taxon>Definition</taxon> <addr>Fra-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d005.tree</source-path> <route>Fra-d005.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Hereditary Property (HP)</title> </frontmatter> <mainmatter><p>A class <tex>(K, \leq )</tex> has the hereditary property if for every <tex>A \in  K</tex>, and any <tex>B \subseteq  A</tex> finitely generated, then there is some <tex>C \in  K</tex> such that <tex>C \cong  B</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2716</anchor>  <taxon>Definition</taxon> <addr>Fra-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d004.tree</source-path> <route>Fra-d004.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Joint Embedding Property (JEP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B  \in  K</tex>, there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex></p><p><link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">Amalgamation Property</link> does NOT necessarily imply JEP, unless the empty set <tex>\emptyset</tex> is in <tex>K</tex> and for all <tex>A \in  K</tex>, we have that <tex>\emptyset   \leq  A</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2717</anchor>  <taxon>Theorem</taxon> <addr>Fra-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t002.tree</source-path> <route>Fra-t002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Properties of a Fraisse Limit</title> </frontmatter> <mainmatter><p>If <tex>M</tex> is the <link href="Fra-t001.xml" type="local" title="Fraisse's Theorem">Fraisse Limit</link> of a class <tex>(K,  \leq )</tex>, then <tex>Th(M)</tex> has quantifier elimination and is <tex>\omega</tex>-categorical</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2718</anchor>  <taxon>Section</taxon> <addr>Smc-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-s001.tree</source-path> <route>Smc-s001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes</title> </frontmatter> <mainmatter><p>We define Smooth class constructions and their properties. Sources for this section are the papers <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic Structures</link> and <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Stable generic structures</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>33</crumb></trail> <anchor>2719</anchor>  <taxon>Definition</taxon> <addr>Smc-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-d001.tree</source-path> <route>Smc-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Class</title> </frontmatter> <mainmatter><p>We assume the language <tex>\mathcal {L}</tex> is countable and only relational.</p><p>A class <tex>(K, \leq )</tex> of finite <tex>\mathcal {L}</tex>-structures (closed under isomorphism) is called <em>a smooth class</em> if <tex>\leq</tex> is transitive, <tex>A \leq  B  \Rightarrow  A \subsetq  B</tex>, and for each <tex>A \in  K</tex>, there is a set of universal formulas <tex>\Phi _A</tex> such that:
<tex display="block">A \leq  B  \Leftrightarrow  B \models   \Phi _A(A)</tex>
and we require that <tex>A \cong  A'  \Leftrightarrow   \Phi _A =  \Phi _{A'}</tex></p><p>This definition comes from <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic structures</link></p><p>An alternative definition, or characterization, from <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Baldwin and Shi</link>, is a class that satisfies the following:</p><p>If <tex>A \in  K</tex>, <tex>A \leq  A</tex></p><p>If <tex>A \leq  B</tex>, then <tex>A \subseteq  B</tex></p><p><tex>\leq</tex> is transitive</p><p>If <tex>A \leq  C</tex>, and <tex>A \subseteq  B \subseteq  C</tex>, then <tex>A \leq  B</tex> for <tex>A,B,C  \in  K</tex></p><p><tex>\emptyset \in  K</tex> and <tex>\emptyset   \leq  A</tex> for all <tex>A \in  K</tex></p><p>The only difference between these two characterizations is that in the first definition, we essentially stipulate that <tex>\leq</tex> is definable/determined by a 
set of universal formulas. This turns out to be an advantage in working with these classes. Certainly, classes satisfying the first definition will satisfy Baldwin-Shi's. In this way,
it is perhaps wiser to regard the second definition as a characterization as opposed to an actual definition.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>34</crumb></trail> <anchor>2720</anchor>  <taxon>Example</taxon> <addr>Smc-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-e001.tree</source-path> <route>Smc-e001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Initial Segments</title> </frontmatter> <mainmatter><p> Let <tex>(K, \leq _*)</tex> be the class of be finite, initial segements of the linear order <tex>( \omega , \leq )</tex>, where <tex>A \leq _* B</tex> is &quot;<tex>A</tex> is an initial segment of <tex>B</tex>&quot;.</p><p>It is clear that <tex>\leq</tex> fits into the definition of a smooth class, simply by the universal formula <tex>\Phi _A(y_1, \dots , y_n) =  \forall  x(( x=y_1 \lor \dots \lor  x=y_n)  \lor   \bigwedge _i^n x \geq  y_i)</tex></p><p>This class has <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">AP</link> and <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">JEP</link>, but not <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">HP</link> or <link href="Fra-d006.xml" type="local" title="Disjoint Amalgamation Property (dAP)">dAP</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>35</crumb></trail> <anchor>2721</anchor>  <taxon>Theorem</taxon> <addr>Smc-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t001.tree</source-path> <route>Smc-t001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Extension of Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \leq )</tex> is a smooth class of finite structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link> and the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, 
then there is a unique, countable structure <tex>\mathcal {M}</tex>  with the following properties:</p><p>1. Any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \leq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>2. <tex>\mathcal {M} =  \bigcup ^ \omega _n A_n</tex> where <tex>A_n  \leq  A_{n+1}</tex> and for all <tex>n</tex>, <tex>A_n \in  K</tex></p><p>3. For every <tex>A \in  K</tex>, there is an embedding <tex>f:A \rightarrow  M</tex> of <tex>A</tex> into <tex>M</tex> such that <tex>f(A)  \leq  M</tex></p><p>The structure <tex>\mathcal {M}</tex> is the <em>generic</em>, or sometimes, the <em>limit</em> of <tex>K</tex>.</p><p>An equivalent characterization of a generic is properties 2 and 3 and the following property:</p><p>4. If <tex>A \leq  M</tex> and <tex>A \leq  B</tex> for <tex>B \in  K</tex>, then there is an isomorphism <tex>f: B \rightarrow  M</tex> extending the identity map <tex>id: A \rightarrow  M</tex> 
such that <tex>f(B)  \leq  M</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>36</crumb></trail> <anchor>2722</anchor>  <taxon>Theorem</taxon> <addr>Smc-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t002.tree</source-path> <route>Smc-t002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes and Saturation</title> </frontmatter> <mainmatter><p>The following theorem first appears in <link href="" type="external">this paper</link> by Laskowski and Kueker</p><p>Let <tex>(K,  \leq )</tex> be a smooth class with a <link href="" type="external">generic</link> <tex>\mathcal {A}</tex>. If <tex>\mathcal {A}</tex> is weakly saturated, then <tex>\mathcal {A}</tex> is indeed saturated</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>37</crumb></trail> <anchor>2723</anchor>  <taxon>Theorem</taxon> <addr>Smc-t003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t003.tree</source-path> <route>Smc-t003.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Generic of Smooth Class (Kueker &amp; Laskowski)</title> </frontmatter> <mainmatter><p>Let <tex>(K, \leq )</tex> be a smooth class with a generic <tex>\mathcal {A}</tex>. If for every <tex>A  \in  K</tex>, <tex>\Phi _A</tex> (see <link href="Smc-d001.xml" type="local" title="Smooth Class">here</link>) consists of a single universal formula,
then <tex>\mathcal {A}</tex> is an atomic model.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2724</anchor>  <taxon>Example</taxon> <addr>Fra-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e001.tree</source-path> <route>Fra-e001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>The Random Graph</title> </frontmatter> <mainmatter><p>Rado's famous random graph is indeed the Fraisse Limit of the class of finite graphs in the language <tex>\mathcal {L} =  \{ E \}</tex> where <tex>E</tex> is a binary relation representing &quot;there is an edge&quot; between two points.</p><p>More precisely, a graph is an <tex>\mathcal {L}-</tex>structure for which <tex>E</tex> is anti-reflexive and symmetric.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2725</anchor>  <taxon>Definition</taxon> <addr>Inf-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Infinitary Logic/Inf-d001.tree</source-path> <route>Inf-d001.xml</route> <date><year>2024</year> <month>2</month> <day>9</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of <tex>\mathcal {L}_{ \kappa ,  \omega }</tex></title> </frontmatter> <mainmatter/> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2726</anchor>  <taxon>Definition</taxon> <addr>BMT-d010</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d010.tree</source-path> <route>BMT-d010.xml</route> <date><year>2024</year> <month>2</month> <day>9</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Logical Connectives</title> </frontmatter> <mainmatter><p>We use logical connectives to assess truth value of a formula in propositional and first order logic.</p><p>The symbol <tex>\lor</tex> corresponds to the English word &quot;or&quot;. We say <tex>A  \lor  B</tex> is true if <tex>A</tex> or <tex>B</tex> is true under their respective truth assignments****.</p><p>The symbol <tex>\land</tex> corresponds to the English word &quot;and&quot;. We say <tex>A \land  B</tex> is true if <tex>A</tex> and <tex>B</tex> are both true under their respective truth assignments.</p><p>The symbol <tex>\neg</tex> corresponds to the English word &quot;not&quot;. We say <tex>\neg  A</tex> is true if <tex>A</tex> is false.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2727</anchor>  <taxon>Definition</taxon> <addr>BMT-d011</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d011.tree</source-path> <route>BMT-d011.xml</route> <date><year>2024</year> <month>2</month> <day>9</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Quantifiers</title> </frontmatter> <mainmatter><p>We use <em>quantifiers</em> to bound variables in a formula in first order logic.</p><p>If <tex>\phi (x)</tex> is a <link href="BMT-d009.xml" type="local" title="{L}-Formula">formula</link>, then <tex>\exists  x ( \phi (x))</tex> should be translated as &quot;there is an interpretation of <tex>x</tex> such that <tex>\phi (x)</tex> holds.</p><p>If <tex>\phi (x)</tex> is a <link href="BMT-d009.xml" type="local" title="{L}-Formula">formula</link>, then <tex>\forall  x ( \phi (x))</tex> should be translated as &quot;for all interpretations of <tex>x</tex>, <tex>\phi (x)</tex> holds.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2728</anchor>  <taxon>Definition</taxon> <addr>BMT-d009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d009.tree</source-path> <route>BMT-d009.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>\mathcal {L}</tex>-Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-formula is defined inductively as follows:</p><p><ul><li>
            If <tex>\phi</tex> is an <tex>\mathcal {L}</tex>-<link href="BMT-d008.xml" type="local" title="Atomic Formula">atomic formula</link> then <tex>\phi</tex> is a formula.
        </li>
        <li>
            If <tex>\phi</tex> and <tex>\psi</tex> are both formulas, then <tex>\neg \phi</tex>, <tex>\phi   \land   \psi</tex>, and 
            <tex>\phi \lor \phi</tex> are formulas, where <tex>\lor , \neg , \land</tex> are the usual <link href="BMT-d010.xml" type="local" title="Definition of Logical Connectives">logical connectives</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li></ul></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2729</anchor>  <taxon>Definition</taxon> <addr>BMT-d008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d008.tree</source-path> <route>BMT-d008.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <em>atomic formula</em> is defined as follows:</p><p>If <tex>R \in   \mathcal {L}</tex> is an n-ary relation symbol, and <tex>t_1, \dots , t_n</tex> are <link href="BMT-d007.xml" type="local" title="Term">terms</link>, then <tex>R(t_1, \dots , t_n)</tex> is an atomic formula.</p><p>If <tex>t_1</tex> and <tex>t_2</tex> are <tex>\mathcal {L}</tex>-terms, then <tex>t_1 = t_2</tex> is an atomic formula. </p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2730</anchor>  <taxon>Part</taxon> <addr>BMT-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-p001.tree</source-path> <route>BMT-p001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> <contributor><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></contributor><contributor><link href="francis-westhead.xml" type="local">Francis Westhead</link></contributor><contributor><link href="gpeters.xml" type="local">Garrett Peters</link></contributor><contributor><link href="oscarc.xml" type="local">Oscar Coppola</link></contributor><contributor><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></contributor></authors> <title>Basic Model Theory</title> </frontmatter> <mainmatter><p>We give the common definitions and theorems for basic/introductory model theory</p>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>38</crumb></trail> <anchor>2731</anchor>  <taxon>Section</taxon> <addr>BMT-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s001.tree</source-path> <route>BMT-s001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Structures, Isomorphisms, Substructures</title> </frontmatter> <mainmatter><p>In this section we give the basic notions and theorems for structures, isomorphisms, and substructures</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>38</crumb> <crumb>1</crumb></trail> <anchor>2732</anchor>  <taxon>Definition</taxon> <addr>BMT-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d001.tree</source-path> <route>BMT-d001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Language</title> </frontmatter> <mainmatter><p>A language, also called a vocabulary or signature by different authors, is a set <tex>\mathcal {L}</tex> consisting of symbols for constants, relations, and functions, 
often denoted by <tex>c</tex>, <tex>R</tex>, and <tex>f</tex> respectively. Languages may have any cardinality.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>38</crumb> <crumb>2</crumb></trail> <anchor>2733</anchor>  <taxon>Definition</taxon> <addr>BMT-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d002.tree</source-path> <route>BMT-d002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Structure</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-structure <tex>\mathcal {M}</tex> in this language has a universe <tex>M</tex> (often, the structure and its universe 
are written the same, by abuse of notation). The structure <tex>\mathcal {M}</tex> &quot;interprets&quot; the symbols of <tex>\mathcal {L}</tex> as follows:</p><p>For a constant symbol <tex>c \in   \mathcal {L}</tex>, the interpretation of <tex>c</tex> in <tex>\mathcal {M}</tex>, denoted <tex>c^{ \mathcal {M}}</tex> represents a fixed 
element of <tex>M</tex></p><p>For an <tex>n</tex>-ary function symbol <tex>f \in   \mathcal {L}</tex>, the interpretation of <tex>f</tex> in <tex>\mathcal {M}</tex>, denoted <tex>f^{ \mathcal {M}}</tex>,
is a function from <tex>M^n</tex> to <tex>M</tex></p><p>For an <tex>n</tex>-ary relation symbol <tex>R \in   \mathcal {L}</tex>, the interpretation of <tex>R</tex> in <tex>\mathcal {M}</tex>, denoted <tex>R^{ \mathcal {M}}</tex>,
is a subset <tex>M^n</tex></p><p>Often, we are interested in the cardinality of a structure, denoted <tex>| \mathcal {M}|</tex>, which is defined to be the cardinality of its universe.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>38</crumb> <crumb>3</crumb></trail> <anchor>2734</anchor>  <taxon>Definition</taxon> <addr>BMT-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d003.tree</source-path> <route>BMT-d003.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Homomorphism</title> </frontmatter> <mainmatter><p>Given two <link href="BMT-d002.xml" type="local" title="Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, a <em>homomorphism</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a function between the universes <tex>A</tex> and <tex>B</tex> of <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> respectively such that:</p><p> For every n-ary function <tex>f \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n \in  A</tex>, <tex>\varphi (f^{ \mathcal {A}}(a_1, \dots , a_n)) = f^{ \mathcal {B}}( \varphi (a_1), \dots ,  \varphi (a_n))</tex></p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Rightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>For every constant symbol <tex>c  \in   \mathcal {L}</tex>, <tex>\varphi (c^{ \mathcal {A}}) =c^{ \mathcal {B}}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>38</crumb> <crumb>4</crumb></trail> <anchor>2735</anchor>  <taxon>Definition</taxon> <addr>BMT-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d004.tree</source-path> <route>BMT-d004.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Embedding of <tex>L</tex>-structures</title> </frontmatter> <mainmatter><p>Given two structures in a language <tex>\mathcal {L}</tex> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex>, an <em>embedding</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a <link href="BMT-d003.xml" type="local" title="Homomorphism">homomorphism</link> such that:</p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Leftrightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>This is stronger than a homomorphism because we now require a two way implication in the above property.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>38</crumb> <crumb>5</crumb></trail> <anchor>2736</anchor>  <taxon>Definition</taxon> <addr>BMT-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d005.tree</source-path> <route>BMT-d005.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Isomorphism</title> </frontmatter> <mainmatter><p>An <link href="BMT-d004.xml" type="local" title="Embedding of L-structures">embedding</link> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex> between <tex>\mathcal {L}</tex>-structures is a <em>isomorphism</em> if it is surjective.

An automorphism of a <link href="BMT-d002.xml" type="local" title="Structure">structure</link> <tex>\mathcal {A}</tex> is an isomorphism to itself.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>38</crumb> <crumb>6</crumb></trail> <anchor>2737</anchor>  <taxon>Definition</taxon> <addr>BMT-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d006.tree</source-path> <route>BMT-d006.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Substructure</title> </frontmatter> <mainmatter><p>Given a <tex>\mathcal {L}</tex>-structure <tex>\mathcal {A}</tex>, a subset <tex>B  \subseteq  A</tex> is called a <em>substructure</em> of <tex>\mathcal {A}</tex> if:</p><p>For every constant <tex>c \in   \mathcal {L}</tex>, <tex>c^{ \mathcal {A}}  \in  B</tex></p><p>For every n-ary function <tex>f \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, <tex>f^{ \mathcal {A}}(b_1, \dots ,b_n)  \in  B</tex></p><p>For every n-ary relation, <tex>R \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, we write <tex>R^B = R^{ \mathcal {A}} \cap   \mathcal {P}(B^n)</tex> and require that
<tex>R^{B}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{B}</tex>)  if and only if <tex>R^{ \mathcal {A}}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{ \mathcal {A}}</tex>) 
Note that this condition is vacuously true, so only the first two conditions need to be checked when verifying a substructure.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>38</crumb> <crumb>7</crumb></trail> <anchor>2738</anchor>  <taxon>Definition</taxon> <addr>BMT-d030</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d030.tree</source-path> <route>BMT-d030.xml</route> <date><year>2024</year> <month>9</month> <day>19</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Elementary Embedding of <tex>L</tex>-structures</title> </frontmatter> <mainmatter><p>
    Given two <link href="BMT-d002.xml" type="local" title="Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>,
    a <link href="BMT-d003.xml" type="local" title="Homomorphism">homomorphism</link> <tex>\Phi \colon \mathcal {A}  \to   \mathcal {B}</tex> is an <em>elementary embedding</em> when
    for every <tex>\mathcal  L</tex>-formula <tex>\varphi (x_1, \dots ,x_n)</tex> and <tex>a_1, \dots ,a_n \in  A</tex>,
    we have <tex>\mathcal  A \vDash \varphi (a_1, \dots ,a_n)</tex> if and only if <tex>\mathcal  B \vDash \varphi ( \Phi (a_1), \dots , \Phi (a_n))</tex>.

    A partial homomorphism <tex>\Phi : \mathcal {A} \to \mathcal {B}</tex> can also be said to be an elementary embedding when
    for every <tex>\mathcal  L</tex>-formula <tex>\varphi (x_1, \dots ,x_n)</tex> and <tex>a_1, \dots ,a_n \in  dom \Phi</tex>,
    we have <tex>\mathcal  A \vDash \varphi (a_1, \dots ,a_n)</tex> if and only if <tex>\mathcal  B \vDash \varphi ( \Phi (a_1), \dots , \Phi (a_n))</tex>.


</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>38</crumb> <crumb>8</crumb></trail> <anchor>2739</anchor>  <taxon>Definition</taxon> <addr>BMT-d031</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d031.tree</source-path> <route>BMT-d031.xml</route> <date><year>2024</year> <month>9</month> <day>19</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Elementary Substructures</title> </frontmatter> <mainmatter><p>
    Given two <link href="BMT-d002.xml" type="local" title="Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>
    such that <tex>\mathcal  A</tex> is a <link href="BMT-d006.xml" type="local" title="Substructure">substructure</link> of <tex>\mathcal  B</tex>,
    <tex>\mathcal  A</tex> is an <em>elementary substructure</em> of <tex>\mathcal  B</tex> when the inclusion map <tex>\mathcal  A \hookrightarrow \mathcal  B</tex>
    is an <link href="BMT-d030.xml" type="local" title="Elementary Embedding of L-structures">elementary embedding</link>.
    Conversely, <tex>\mathcal  B</tex> is called an elementary extension of <tex>\mathcal  A</tex>.
</p><p>
    One writes <tex>\mathcal  A \preceq \mathcal  B</tex> to mean <tex>\mathcal  A</tex> is an elementary substructure of <tex>\mathcal  B</tex>.
</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>39</crumb></trail> <anchor>2740</anchor>  <taxon>Section</taxon> <addr>BMT-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s002.tree</source-path> <route>BMT-s002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> <contributor><link href="francis-westhead.xml" type="local">Francis Westhead</link></contributor><contributor><link href="oscarc.xml" type="local">Oscar Coppola</link></contributor></authors> <title>Formulas and Models</title> </frontmatter> <mainmatter><p>In this section we define formulas, elementary equivalence, elementary substructures, theories, and models</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>39</crumb> <crumb>1</crumb></trail> <anchor>2741</anchor>  <taxon>Definition</taxon> <addr>BMT-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d007.tree</source-path> <route>BMT-d007.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Term</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, we define a <em>term</em> to be any of the following:</p><p>If <tex>c \in   \mathcal {L}</tex> is a constant symbol, then <tex>c</tex> is a term</p><p>If <tex>x</tex> is a variable symbol, then <tex>x</tex> is a term. We generally assume we have countably infinitely many variable symbols</p><p>If <tex>t_1,..., t_n</tex> are terms, and <tex>f \in   \mathcal {L}</tex> is an <tex>n</tex>-ary function, then <tex>f(t_1,..., t_n)</tex> is a term.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>39</crumb> <crumb>2</crumb></trail> <anchor>2742</anchor>  <taxon>Definition</taxon> <addr>BMT-d008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d008.tree</source-path> <route>BMT-d008.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <em>atomic formula</em> is defined as follows:</p><p>If <tex>R \in   \mathcal {L}</tex> is an n-ary relation symbol, and <tex>t_1, \dots , t_n</tex> are <link href="BMT-d007.xml" type="local" title="Term">terms</link>, then <tex>R(t_1, \dots , t_n)</tex> is an atomic formula.</p><p>If <tex>t_1</tex> and <tex>t_2</tex> are <tex>\mathcal {L}</tex>-terms, then <tex>t_1 = t_2</tex> is an atomic formula. </p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>39</crumb> <crumb>3</crumb></trail> <anchor>2743</anchor>  <taxon>Definition</taxon> <addr>BMT-d009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d009.tree</source-path> <route>BMT-d009.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>\mathcal {L}</tex>-Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-formula is defined inductively as follows:</p><p><ul><li>
            If <tex>\phi</tex> is an <tex>\mathcal {L}</tex>-<link href="BMT-d008.xml" type="local" title="Atomic Formula">atomic formula</link> then <tex>\phi</tex> is a formula.
        </li>
        <li>
            If <tex>\phi</tex> and <tex>\psi</tex> are both formulas, then <tex>\neg \phi</tex>, <tex>\phi   \land   \psi</tex>, and 
            <tex>\phi \lor \phi</tex> are formulas, where <tex>\lor , \neg , \land</tex> are the usual <link href="BMT-d010.xml" type="local" title="Definition of Logical Connectives">logical connectives</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li></ul></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>39</crumb> <crumb>4</crumb></trail> <anchor>2744</anchor>  <taxon>Definition</taxon> <addr>BMT-d017</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d017.tree</source-path> <route>BMT-d017.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Definition of an <tex>\mathcal {L}</tex>-theory</title> </frontmatter> <mainmatter><p>
    Given a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, a <em><tex>\mathcal {L}</tex>-theory</em> is a set of <link href="BMT-d013.xml" type="local" title="Definition of Sentences"><tex>\mathcal {L}</tex>-sentences</link>.
    Sometimes it is notationally convenient to assume that theories are deductively closed.
</p><p>
    An <tex>\mathcal  L</tex>-theory is <em>complete</em> when for every <link href="BMT-d009.xml" type="local" title="{L}-Formula"><tex>\mathcal  L</tex>-formula</link> <tex>\phi</tex> we have that
    <tex>\phi</tex> may be deduced from <tex>T</tex> or <tex>\neg \phi</tex> may be deduced from <tex>T</tex>.
</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>40</crumb></trail> <anchor>2745</anchor>  <taxon>Section</taxon> <addr>BMT-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s003.tree</source-path> <route>BMT-s003.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> <contributor><link href="oscarc.xml" type="local">Oscar Coppola</link></contributor></authors> <title>Quantifier Elimination</title> </frontmatter> <mainmatter><p>Quantifier Elimination is a part of a broader technique in Model Theory where for a structure in a given language, an arbitrary formula can be written as a boolean combination of perhaps simpler formulas</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>40</crumb> <crumb>1</crumb></trail> <anchor>2746</anchor>  <taxon>Definition</taxon> <addr>BMT-d014</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d014.tree</source-path> <route>BMT-d014.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Elimination Set</title> </frontmatter> <mainmatter><p>An <em>Elimination Set</em> for a language <tex>\mathcal {L}</tex> and class <tex>K</tex> of <tex>\mathcal {L}</tex>-structures, then a set <tex>\Gamma</tex> of formulas <tex>\phi</tex> is an elimination set for <tex>K</tex> if for every formula <tex>\phi ( \bar {x})</tex> of <tex>\mathcal {L}</tex> there is a formula <tex>\phi ^*( \bar {x})</tex> which is a boolean combinations of formulas in <tex>\Gamma</tex> and <tex>\phi</tex> is equivalent to <tex>\phi ^*</tex> in every structure in <tex>K</tex></p></mainmatter> </tree><p>In particular, we will be most interested in elimination sets that are comprised of the set of quantifier free formulas. It is worth noting that, in some cases it is not possible to have a full quantifier elimination down to the level of a quantifier free set but perhaps we can restrict ourself to some reasonable set of formulas.</p><p>Frequently, we use the following lemma to simplify the task of showing that <tex>\Phi</tex> is an elimination set</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>40</crumb> <crumb>2</crumb></trail> <anchor>2747</anchor>  <taxon>Lemma</taxon> <addr>BMT-d015</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d015.tree</source-path> <route>BMT-d015.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Elimination of Atomic Formulas</title> </frontmatter> <mainmatter><p>Let <tex>K</tex> be a class of <tex>L</tex> structures and <tex>\Phi</tex> be a set of <tex>L</tex>-formulas. Denote <tex>\Phi ^-</tex> as the set of negations of formulas in <tex>\Phi</tex>.</p><p>Suppose that 
  <ol><li>every atomic formula of <tex>L</tex> is in <tex>\Phi</tex> and</li> 
    <li>for every formula <tex>\theta ( \overline {x})</tex> of <tex>L</tex> which is of the form <tex>\exists  y  \bigwedge _{i&lt;n}  \psi _i ( \overline {x},y)</tex> with each <tex>\psi _i  \in   \Phi \cup   \Phi ^-</tex>, there is an <tex>L</tex>-formula <tex>\theta ^*( \overline {x})</tex> which is a boolean combination of formulas in <tex>\Phi</tex> and is equivalent to <tex>\theta</tex> in every structure in <tex>K</tex>.</li></ol>
  Then <tex>\Phi</tex> is an elimination set of <tex>K</tex></p></mainmatter> </tree><p>The art of quantifier elimination lies in choosing an appropriate elimination set that allows the above lemma to be used with minimal obstructions. </p><p>There are many examples of theories which have quantifier elimination for a relatively tame set of formulas: </p>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>40</crumb> <crumb>3</crumb></trail> <anchor>2748</anchor>  <taxon>Example</taxon> <addr>BMT-e031</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e031.tree</source-path> <route>BMT-e031.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Algebraically Closed Fields</title> </frontmatter> <mainmatter><p>
    The theory of <em>algebraically closed fields</em> (ACF) is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">theory</link> in the <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal  L= \{ 0,1,+, \cdot \}</tex>
    consisting of the following <link href="BMT-d013.xml" type="local" title="Definition of Sentences">sentences</link>.
    <ul><li><tex>\forall  x \forall  y \forall  z \, (x+y)+z=x+(y+z)</tex>.
        </li>
        <li><tex>\forall  x \, x+0=x \land0 +x=x</tex>.
        </li>
        <li><tex>\forall  x \exists  y \, x+y=0 \land  y+x=0</tex>.
        </li>
        <li><tex>\forall  x \forall  y \, x+y=y+x</tex>.
        </li>
        <li><tex>\forall  x \forall  y \forall  z \, (x \cdot  y) \cdot  z=x \cdot  (y+ \cdot  z)</tex>.
        </li>
        <li><tex>\forall  x \, x \cdot1 =x \land1 \cdot  x=x</tex>.
        </li>
        <li><tex>\forall  x \exists  y \, x \cdot  y=1 \land  y \cdot  x=1</tex>.
        </li>
        <li><tex>\forall  x \forall  y \, x+ \cdot  y=y \cdot  x</tex>.
        </li>
        <li><tex>\forall  x \forall  y \forall  z \, x \cdot (y+z)=(x \cdot  y)+(x \cdot  z)</tex>.
        </li>
        <li>
            For each <tex>n \in \mathbb  N</tex>, a sentence <tex>\forall  y_1 \cdots \forall  y_n \exists  x \, (y_1 \cdot  x)+ \cdots +(y_n \cdot  x)=0</tex>.
        </li></ul></p><p>
    The theory of algebraically closed fields of characteristic <tex>p</tex> (<tex>\text {ACF}_p</tex>) is ACF together with the sentence
    <tex>1+ \cdots +1=0</tex>, where <tex>1</tex> is being added <tex>p</tex> times. <tex>\text {ACF}_p</tex> is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">complete theory</link> having
    <link href="BMT-s003.xml" type="local" title="Quantifier Elimination">quantifier elimination</link>.
</p><p>
    The theory of algebraically closed fields of characteristic <tex>0</tex> (<tex>\text {ACF}_0</tex>) is ACF together with the collection of sentences
    of the form <tex>\neg (1+ \cdots +1=0)</tex>, for any number of <tex>1</tex>s being added together. <tex>\text {ACF}_0</tex> is also a
    <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">complete theory</link> having <link href="BMT-s003.xml" type="local" title="Quantifier Elimination">quantifier elimination</link>.
</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>40</crumb> <crumb>4</crumb></trail> <anchor>2749</anchor>  <taxon>Example</taxon> <addr>BMT-e030</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e030.tree</source-path> <route>BMT-e030.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>DLO</title> </frontmatter> <mainmatter><p>
    The <em>dense linear order without endpoints</em> (DLO) is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">theory</link> in the <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal  L= \{ &lt; \}</tex>
    consisting of the following <link href="BMT-d013.xml" type="local" title="Definition of Sentences">sentences</link>.
    <ul><li><tex>\forall  x \, \neg  x&lt;x</tex></li>
        <li><tex>\forall  x \forall  y \, (x&lt;y \rightarrow \neg (y&lt;x))</tex></li>
        <li><tex>\forall  x \forall  y \forall  z \, ((x&lt;y \land  y&lt;z) \rightarrow  x&lt;z)</tex></li>
        <li><tex>\forall  x \forall  y \, (( \neg  x=y) \rightarrow (x&lt;y \lor  y&lt;x))</tex></li>
        <li><tex>\forall  x \forall  y \, x&lt;y \rightarrow ( \exists  z \, x&lt;z \land  z&lt;y)</tex></li>
        <li><tex>\forall  x \exists  z \, z&lt;x</tex></li>
        <li><tex>\forall  x \exists  z \, x&lt;z</tex></li></ul></p><p>
    The set of rationals <tex>\mathbb  Q</tex> with the usual ordering is a model of DLO, and DLO is <link href="BMT-d201.xml" type="local" title="-Categoricity"><tex>\aleph _0</tex>-categorical</link>,
    so every countable model is isomorphic to <tex>( \mathbb  Q,&lt;)</tex>. DLO is also a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">complete theory</link> with
    <link href="BMT-s003.xml" type="local" title="Quantifier Elimination">quantifier elimination</link>.
</p></mainmatter> </tree>
<p>Furthermore, if one is willing to accept arbitrary expansions of the language, we can always force a theory to have quantifier elimination. This is done as follows:</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>40</crumb> <crumb>5</crumb></trail> <anchor>2750</anchor>  <taxon>Definition</taxon> <addr>BMT-d026</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d026.tree</source-path> <route>BMT-d026.xml</route> <date><year>2024</year> <month>9</month> <day>26</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Morleyisation</title> </frontmatter> <mainmatter><p> The Morleyisation of an <tex>L</tex>-theory <tex>T</tex> is the theory <tex>T^m</tex> in the language <tex>L^m \supset  L</tex>. The expanded language <tex>L^m</tex> is formed by taking every <tex>L</tex>-formula <tex>\phi (x_1,...,x_n)</tex> and adding an <tex>n</tex>-placed relation symbol <tex>R_ \phi</tex>. To <tex>T</tex> we add the axioms </p><p><tex>\forall  x_1,...,x_n (R_ \phi  (x_1,...,x_n) \leftrightarrow \phi (x_1,...,x_n)) </tex></p><p>Morleyisation preserves many properties such as <link href="BMT-d201.xml" type="local" title="-Categoricity"><tex>\kappa</tex>-categoricity</link>, though the relations <tex>R_ \phi</tex> and the corresponding definable sets may be quite hard to understand. </p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>41</crumb></trail> <anchor>2751</anchor>  <taxon>Section</taxon> <addr>BMT-s004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s004.tree</source-path> <route>BMT-s004.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Back and Forth</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for quantifier Elimination</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>42</crumb></trail> <anchor>2752</anchor>  <taxon>Section</taxon> <addr>BMT-s005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s005.tree</source-path> <route>BMT-s005.xml</route> <date><year>2024</year> <month>3</month> <day>14</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Types</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for types.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>42</crumb> <crumb>1</crumb></trail> <anchor>2753</anchor>  <taxon>Definition</taxon> <addr>BMT-d019</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d019.tree</source-path> <route>BMT-d019.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Definition of a type</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory <tex>T</tex></link>, a <em>partial type</em> of <tex>T</tex> is a <link href="BMT-d022.xml" type="local" title="Satisfiability">finitely satisfiable</link> set of formulas in a fixed tuple of variables <tex>x</tex>.</p><p>A partial type <tex>p(x)</tex> (meaning that the denoted type consists of formulas each in the variables <tex>x</tex>) is <em>complete</em> if for every <tex>\mathcal {L}</tex>-formula in the variables <tex>x</tex>, <tex>\varphi (x) \in  p(x)</tex>, either <tex>\varphi (x) \in  p(x)</tex> or <tex>\neg   \varphi (x) \in  p(x)</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>42</crumb> <crumb>2</crumb></trail> <anchor>2754</anchor>  <taxon>Definition</taxon> <addr>BMT-d020</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d020.tree</source-path> <route>BMT-d020.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Definition of an isolated/principal type</title> </frontmatter> <mainmatter><p>
    Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory <tex>T</tex></link>,
    a partial type of T {p(x)} is <em>principal</em> when there is an <tex>\mathcal {L}</tex>-formula <tex>\varphi (x)</tex> such that
    <tex>\models   \exists  x  \varphi (x)</tex> and for every <tex>\varpsi (x)  \in  p(x)</tex> we have that
    <tex>\models   \forall  x ( \varphi (x)  \rightarrow   \varpsi (x))</tex>.
    In the case that <tex>p(x)</tex> is complete, we must have that <tex>\varphi (x) \in  p(x)</tex>,
    and the first condition is redundant.
</p><p>
    A complete type of T, <tex>p(x)</tex> is <em>isolated</em> if it is principal as a partial type.
    Equivalently, {p(x)} is <em>isolated</em> if <tex>\{ p(x) \}</tex> is open <link href="BMT-d021.xml" type="local" title="The Stone Space S_n(T)">S_n(T)</link>.
    This coincides with the usual topological terminology.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>42</crumb> <crumb>3</crumb></trail> <anchor>2755</anchor>  <taxon>Definition</taxon> <addr>BMT-d021</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d021.tree</source-path> <route>BMT-d021.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>The Stone Space <tex>S_n(T)</tex></title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory <tex>T</tex></link>,
<tex>S_n(T)</tex> denotes a topological space whose underlying set is the set of all complete <em>n-types</em> of <tex>T</tex>.
The topology on <tex>S_n(T)</tex> has a basis of open sets given by all sets of the form <tex>[ \varphi (x)] :=  \{ p(x) \in  S_n(T):
 \varphi (x)  \in  p(x) \}</tex> (for <tex>\varphi (x)</tex> an <tex>\mathcal {L}</tex>-formula).
This space is a Stone Space in the usual sense and the Boolean Algebra associated to it via Stone Duality is
the <tex>n</tex>th Tarski-Lindenbaum Algebra of <tex>T</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>42</crumb> <crumb>4</crumb></trail> <anchor>2756</anchor>  <taxon>Definition</taxon> <addr>BMT-d023</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d023.tree</source-path> <route>BMT-d023.xml</route> <date><year>2024</year> <month>4</month> <day>4</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Finite Satisfiability</title> </frontmatter> <mainmatter><p>
    An <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal  L</tex>-theory</link> <tex>T</tex> is <em>finitely satisfiable</em> when every finite subset of <tex>T</tex> is <link href="BMT-d022.xml" type="local" title="Satisfiability">satisfiable</link>.
</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>43</crumb></trail> <anchor>2757</anchor>  <taxon>Section</taxon> <addr>BMT-s006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s006.tree</source-path> <route>BMT-s006.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> <contributor><link href="francis-westhead.xml" type="local">Francis Westhead</link></contributor></authors> <title>Saturation</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for saturation of models.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>43</crumb> <crumb>1</crumb></trail> <anchor>2758</anchor>  <taxon>Definition</taxon> <addr>BMT-d209</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d209.tree</source-path> <route>BMT-d209.xml</route> <date><year>2024</year> <month>9</month> <day>12</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Saturated Model</title> </frontmatter> <mainmatter><p>
    A <link href="BMT-d002.xml" type="local" title="Structure">structure</link> <tex>M</tex> is <tex>\lambda</tex>-saturated, for a cardinal <tex>\lambda</tex>, when for every <tex>A \subseteq  M</tex> such that <tex>|A|&lt; \lambda</tex>, every <link href="BMT-d019.xml" type="local" title="Definition of a type">type</link> over <tex>A</tex> is realized in <tex>M</tex>. <tex>M</tex> is simply said to be saturated if <tex>M</tex> is <tex>|M|</tex>-saturated.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>43</crumb> <crumb>2</crumb></trail> <anchor>2759</anchor>  <taxon>Definition</taxon> <addr>BMT-d210</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d210.tree</source-path> <route>BMT-d210.xml</route> <date><year>2024</year> <month>9</month> <day>19</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Homogeneous Model</title> </frontmatter> <mainmatter><p>
    A <link href="BMT-d002.xml" type="local" title="Structure">structure</link> <tex>M</tex> is <tex>\lambda</tex>-homogeneous, for a cardinal <tex>\lambda</tex>, 
    when for every cardinal <tex>\eta &lt; \lambda</tex> and sequences <tex>(a_i \in  M|i \in \eta ), \{ b_i \in  M|i \in \eta \}</tex> such that <tex>(M,(a_i)_{i&lt; \eta }) \equiv (M,(b_i)_{i&lt; \eta })</tex>, 
    for each <tex>c \in  M</tex> there is <tex>d \in  M</tex> such that <tex>(M,(a_i)_{i&lt; \eta },c) \equiv (M,(b_i)_{i&lt; \eta },d)</tex>. 

    Here <tex>(M,(a_i)_{i&lt; \eta }),(M,(b_i)_{i&lt; \eta })</tex> refers to <tex>M</tex> with its language expanded by a constant <tex>C_i</tex> for each <tex>i&lt; \eta</tex>, such that <tex>C_i</tex> is interpreted as <tex>a_i</tex>, <tex>b_i</tex> respectively. 
    <tex>(M,(a_i)_{i&lt; \eta },c)</tex> and <tex>(M,(b_i)_{i&lt; \eta },d)</tex> are further expansions, when the language is further expanded by a constant <tex>D</tex> that is interpreted as <tex>c</tex> or <tex>d</tex> respectively.

    Equivalently, <tex>M</tex> is <tex>\lambda</tex>-homogeneous if every partial elementary embedding <tex>\Phi :M \to  M</tex> such that <tex>|dom \Phi |&lt; \lambda</tex> extends to another partial elementary mapping of <tex>M</tex> to itself with a larger domain.

    The first definition follows Chang &amp; Keisler, and the second follows Shelah. The two definitions are equivalent.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>43</crumb> <crumb>3</crumb></trail> <anchor>2760</anchor>  <taxon>Definition</taxon> <addr>BMT-d212</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d212.tree</source-path> <route>BMT-d212.xml</route> <date><year>2024</year> <month>10</month> <day>10</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Strongly Homogeneous Model</title> </frontmatter> <mainmatter><p>
    A model <tex>M</tex> is strongly <tex>\lambda</tex>-homogeneous, if for every partial elementary embedding <tex>\Phi :M \to  M</tex> extends to an automorphism of <tex>M</tex>. 

    Clearly, strongly <tex>\lambda</tex>-homogeneous implies <link href="BMT-d210.xml" type="local" title="Homogeneous Model"><tex>\lambda</tex>-homogeneous</link>. 
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>43</crumb> <crumb>4</crumb></trail> <anchor>2761</anchor>  <taxon>Definition</taxon> <addr>BMT-d211</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d211.tree</source-path> <route>BMT-d211.xml</route> <date><year>2024</year> <month>9</month> <day>26</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Ultrahomogeneous Model</title> </frontmatter> <mainmatter><p>
    A countable <link href="BMT-d002.xml" type="local" title="Structure">structure</link> <tex>M</tex> is ultrahomogeneous, per Hodges, when every <link href="BMT-d005.xml" type="local" title="Isomorphism">isomorphism</link> between two finite <link href="BMT-d006.xml" type="local" title="Substructure">substructures</link> of <tex>M</tex> extends to a global <link href="BMT-d005.xml" type="local" title="Isomorphism">automorphism</link>.

    Also, ultrahomogeneous is strictly stronger than strongly <tex>\omega</tex>-homogeneous. For a strongly <tex>\omega</tex>-homogeneous structure that is not ultrahomogeneous, consider the disjoint union of a countable <link href="Fra-e001.xml" type="local" title="The Random Graph">random graph</link> and a countable triangle-free random graph. This structure is <tex>\omega</tex>-homogenous but not ultrahomogeneous.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>43</crumb> <crumb>5</crumb></trail> <anchor>2762</anchor>  <taxon>Definition</taxon> <addr>BMT-d213</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d213.tree</source-path> <route>BMT-d213.xml</route> <date><year>2024</year> <month>10</month> <day>10</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Strongly Saturated Model</title> </frontmatter> <mainmatter>{



}<p>
    A structure <tex>M</tex> is strongly <tex>\lambda</tex>-saturated if it is <link href="BMT-d209.xml" type="local" title="Saturated Model"><tex>\lambda</tex>-saturated</link> and <link href="BMT-d212.xml" type="local" title="Strongly Homogeneous Model">strongly <tex>\lambda</tex>-homogeneous</link>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>43</crumb> <crumb>6</crumb></trail> <anchor>2763</anchor>  <taxon>Definition</taxon> <addr>BMT-d214</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d214.tree</source-path> <route>BMT-d214.xml</route> <date><year>2024</year> <month>10</month> <day>17</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Universal Model</title> </frontmatter> <mainmatter><p>
    A model <tex>M</tex> is <tex>\lambda</tex>-Universal, per Chang &amp; Keisler, when for every model <tex>N</tex> such that <tex>|N|&lt; \lambda</tex> that is elementarily equivalent to <tex>M</tex> can <link href="BMT-d030.xml" type="local" title="Elementary Embedding of L-structures">elementarily embeds</link> into <tex>M</tex>. 
</p><p>
    A model <tex>M</tex> is <tex>\lambda</tex>-Universal, per Shelah, when for every model <tex>N</tex> that is elementarily equivalent to <tex>M</tex>, and a set <tex>A \subseteq  N</tex> such that <tex>|A| \leq \lambda</tex>, there is a <link href="BMT-d030.xml" type="local" title="Elementary Embedding of L-structures">partial elementary embedding</link> <tex>f:M \to  N</tex> such that <tex>dom(f)=A</tex>.
</p><p><tex>\lambda</tex>-universality per Shelah implies <tex>\lambda ^+</tex>-universality per Chang &amp; Keisler.
    By the Lowenheim-Skolem Theorem, if the language <tex>|L| \leq   \lambda</tex>, then <tex>\lambda</tex>-universality per Shelah and <tex>\lambda ^+</tex>-universality per Chang &amp; Keisler are equivalent.
</p><p>
    Per Shelah, a model <tex>M</tex> is <tex>&lt; \lambda</tex>-universal if it is <tex>\mu</tex>-universal for all <tex>\mu &lt; \lambda</tex>, and a model <tex>M</tex> simply said to be universal if it is <tex>|M|</tex>-universal. 
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>43</crumb> <crumb>7</crumb></trail> <anchor>2764</anchor>  <taxon>Theorem</taxon> <addr>BMT-t081</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t081.tree</source-path> <route>BMT-t081.xml</route> <date><year>2024</year> <month>4</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>A model is homogeneous if and only if it is strongly homogeneous</title> </frontmatter> <mainmatter><p>A back-and-forth argument establishes that if <tex>\mathcal {M}</tex> has infinite cardinality, then <tex>\mathcal {M}</tex> is homogeneous
if and only if <tex>\mathcal {M}</tex> is strongly homogeneous.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>43</crumb> <crumb>8</crumb></trail> <anchor>2765</anchor>  <taxon>Theorem</taxon> <addr>BMT-t082</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t082.tree</source-path> <route>BMT-t082.xml</route> <date><year>2024</year> <month>4</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Saturated elementarily equivalent models of the same cardinality are isomorphic.</title> </frontmatter> <mainmatter><p>
    If <tex>\mathcal {M}</tex> and <tex>\mathcal {N}</tex> are each saturated, <tex>| \mathcal {M}|=| \mathcal {N}|</tex> and <tex>Th( \mathcal {M})=Th( \mathcal {N})</tex>
, then <tex>\mathcal {M}</tex> and <tex>\mathcal {N}</tex> are isomorphic.
</p><p>
    Moreover, every partial elementary embedding <tex>f:M \to  N</tex> extends to an isomorphism. 
    Therefore, for every saturated model <tex>M</tex>, a subset <tex>A \subseteq  M</tex>, and two elements <tex>x,y \in  M</tex> of the same <link href="BMT-d019.xml" type="local" title="Definition of a type">type</link> over <tex>A</tex>, there is an automorphism of <tex>M</tex> fixing <tex>A</tex> pointwise and takes <tex>x</tex> to <tex>y</tex>.
    This is sometimes known as the Model-Theoretic Galois Theory.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>43</crumb> <crumb>9</crumb></trail> <anchor>2766</anchor>  <taxon>Theorem</taxon> <addr>BMT-t083</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t083.tree</source-path> <route>BMT-t083.xml</route> <date><year>2024</year> <month>4</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title><tex>\kappa</tex>-saturated models are <tex>\kappa ^+</tex>-universal</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {M}</tex> is <tex>\kappa</tex>-saturated, then <tex>\mathcal {M}</tex> is <tex>\kappa ^+</tex>-universal.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>43</crumb> <crumb>10</crumb></trail> <anchor>2767</anchor>  <taxon>Theorem</taxon> <addr>BMT-t084</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t084.tree</source-path> <route>BMT-t084.xml</route> <date><year>2024</year> <month>10</month> <day>17</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Saturation is Equivalent to Universality and Homogeneity</title> </frontmatter> <mainmatter><p>
    The following are equivalent, given a model <tex>M</tex> and a cardinal <tex>\lambda</tex>.
</p><p>
    1: <tex>M</tex> is <tex>\lambda</tex>-saturated.
</p><p>
    2: <tex>M</tex> is <tex>\lambda</tex>-universal and <tex>\lambda</tex>-homogeneous.
</p><p>
    3: <tex>M</tex> is <tex>&lt; \aleph _0</tex>-universal and <tex>\lambda</tex>-homogeneous.
</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>44</crumb></trail> <anchor>2768</anchor>  <taxon>Section</taxon> <addr>BMT-s007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s007.tree</source-path> <route>BMT-s007.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> <contributor><link href="gpeters.xml" type="local">Garrett Peters</link></contributor></authors> <title>Ultraproducts</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for the use of ultraproducts in model theory.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>44</crumb> <crumb>1</crumb></trail> <anchor>2769</anchor>  <taxon>Definition</taxon> <addr>BMT-d071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d071.tree</source-path> <route>BMT-d071.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Definition of a Filter</title> </frontmatter> <mainmatter><p>Let <tex>I</tex> be any set. Then a filter <tex>\mathcal {F}</tex> on the power set <tex>\mathcal {P}(I)</tex> is a collection of subsets of <tex>I</tex> with the following properties:</p><p>1: <tex>I \in \mathcal {F}</tex>.</p><p>2: If <tex>A \in   \mathcal {F}</tex> and <tex>A \subseteq  B</tex>, then <tex>B \in   \mathcal {F}</tex>.</p><p>3: If <tex>A,B  \in   \mathcal {F}</tex>, then we have <tex>A \cap  B \in   \mathcal {F}</tex>.</p><p>Furthermore, a filter is proper if <tex>\emptyset \notin \mathcal {F}</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>44</crumb> <crumb>2</crumb></trail> <anchor>2770</anchor>  <taxon>Definition</taxon> <addr>BMT-d072</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d072.tree</source-path> <route>BMT-d072.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Definition of an Ultrafilter</title> </frontmatter> <mainmatter><p>Let <tex>I</tex> be any set. Then an ultrafilter <tex>\mathcal {U}</tex> on <tex>\mathcal {P}(I)</tex> is a proper <link href="BMT-d071.xml" type="local" title="Definition of a Filter">filter</link> on <tex>I</tex> with the additional property:</p><p>For every <tex>A \subseteq  I</tex>, either <tex>A \in \mathcal {U}</tex> or <tex>I \backslash  A \in \mathcal {U}</tex>.</p><p>Every proper filter can be extended into an ultrafilter.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>44</crumb> <crumb>3</crumb></trail> <anchor>2771</anchor>  <taxon>Example</taxon> <addr>BMT-e071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e071.tree</source-path> <route>BMT-e071.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Principal Ultrafilters</title> </frontmatter> <mainmatter><p>Fix any <tex>i \in  I</tex>. Then <tex>\mathcal {U}_i :=  \{ A \subseteq  I: i \in  A \}</tex> is an <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link>. This is referred to as the principal ultrafilter concentrated at <tex>i</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>44</crumb> <crumb>4</crumb></trail> <anchor>2772</anchor>  <taxon>Example</taxon> <addr>BMT-e072</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e072.tree</source-path> <route>BMT-e072.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>The Frchet Filter</title> </frontmatter> <mainmatter><p>For any set <tex>I</tex> of infinite cardinality, the family of cofinite sets forms a proper <link href="BMT-d071.xml" type="local" title="Definition of a Filter">filter</link>. This filter is referred to as the Frchet filter.</p><p>When extending the Frchet filter to an <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link>, the result is not <link href="BMT-e071.xml" type="local" title="Principal Ultrafilters">principal</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>44</crumb> <crumb>5</crumb></trail> <anchor>2773</anchor>  <taxon>Definition</taxon> <addr>BMT-d073</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d073.tree</source-path> <route>BMT-d073.xml</route> <date><year>2024</year> <month>3</month> <day>7</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Ultraproduct</title> </frontmatter> <mainmatter><p>Fix an index set <tex>I</tex> and a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>L</tex>. Let <tex>\{ \mathcal {A}_i: i \in  I \}</tex> be a family of <tex>L</tex>-<link href="BMT-d002.xml" type="local" title="Structure">structures</link>, and let <tex>\mathcal {U}</tex> be any <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link> on <tex>\mathcal {P}(I)</tex>. Then the ultraproduct is the <tex>L</tex>-structure <tex>\mathcal {A}_* :=  \prod \limits _{i \in  I} A_i / \mathcal {U}</tex>. </p><p>In <tex>\mathcal {A}_*</tex>, the elements of the universe of <tex>\mathcal {A}_*</tex> are functions <tex>\underline {a}</tex> with domain <tex>I</tex> and <tex>\underline {a}(i) \in  A_i</tex> under the equivalence class <tex>\sim _{ \mathcal {U}}</tex>, where <tex display="block">\underline {a} \sim _{ \mathcal {U}} \underline {b}  \text { if and only if } \{ i \in  I:  \underline {a}(i)= \underline {b}(i) \}   \in   \mathcal {U}.</tex></p><p>The constant symbols are interpreted by <tex>c^{ \mathcal {A}_*} :=  \prod \limits _{i \in  I} c^{ \mathcal {A}_i} / \mathcal {U}</tex>. </p><p>The function symbols are interpreted by <tex>f^{ \mathcal {A}_i}( \underline {a}_1, \dots ,  \underline {a}_n) :=  \prod \limits _{i \in  I} f^{ \mathcal {A}_i}( \underline {a}_1(i), \dots , \underline {a}_n(i)) /  \mathcal {U} </tex>. </p><p>The relation symbols are interpreted by <tex>\mathcal {A}_* \models  R^{ \mathcal {A}_*}( \underline {a}_1, \dots ,  \underline {a}_n)</tex> if and only if <tex>\{ i \in  I:  \mathcal {A}_i \models  R^{ \mathcal {A}_i}( \underline {a}_1(i), \dots ,  \underline {a}_n(i)) \} \in   \mathcal {U}</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>44</crumb> <crumb>6</crumb></trail> <anchor>2774</anchor>  <taxon>Theorem</taxon> <addr>BMT-t071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t071.tree</source-path> <route>BMT-t071.xml</route> <date><year>2024</year> <month>3</month> <day>7</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title> o's Theorem</title> </frontmatter> <mainmatter><p>Let <tex>\mathcal {A}_* =  \prod \limits _{i \in  I}  \mathcal {A}_i /  \mathcal {U}</tex> be an <link href="BMT-d073.xml" type="local" title="Ultraproduct">ultraproduct</link>. Then for any <tex>L</tex>-formula <tex>\phi (x_1, \dots ,x_n)</tex>, we have <tex display="block">\mathcal {A}_* \models   \phi ( \underline {a}_1, \dots , \underline {a}_n)  \text { if and only if }  \{ i \in  I: A_i \models \phi ( \underline {a}_1(i), \dots ,  \underline {a}_n(i)) \} \in \mathcal {U}.</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>44</crumb> <crumb>7</crumb></trail> <anchor>2775</anchor>  <taxon>Theorem</taxon> <addr>BMT-t072</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t072.tree</source-path> <route>BMT-t072.xml</route> <date><year>2024</year> <month>3</month> <day>14</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Compactness Theorem</title> </frontmatter> <mainmatter><p>Let <tex>L</tex> be any language, and <tex>T</tex> be any <tex>L</tex>-theory. Then <tex>T</tex> is satisfiable if and only if every finite subset <tex>T_0 \subseteq  T</tex> is satisfiable.</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>45</crumb></trail> <anchor>2776</anchor>  <taxon>Section</taxon> <addr>BMT-s008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s008.tree</source-path> <route>BMT-s008.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Model Completeness</title> </frontmatter> <mainmatter><p>In many important examples of theories, typically originating in the field of algebra, all embeddings are elementary embeddings. We define this as follows</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>45</crumb> <crumb>1</crumb></trail> <anchor>2777</anchor>  <taxon>Definition</taxon> <addr>BMT-d016</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d016.tree</source-path> <route>BMT-d016.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Model Complete Theory</title> </frontmatter> <mainmatter><p>A Theory <tex>T</tex> in a first order language <tex>L</tex> is <em>Model-Complete</em> if  every <link href="BMT-d004.xml" type="local" title="Embedding of L-structures"><tex>L</tex>-embedding</link> between models of <tex>T</tex> is an elementary embedding. </p></mainmatter> </tree><p>Here we provide a simple test for for determining if something is model complete:</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>45</crumb> <crumb>2</crumb></trail> <anchor>2778</anchor>  <taxon>Lemma</taxon> <addr>BMT-l001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-l001.tree</source-path> <route>BMT-l001.xml</route> <date><year>2024</year> <month>9</month> <day>19</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Robinson's Test</title> </frontmatter> <mainmatter><p> Let <tex>T</tex> be a theory. Then the following are equivalent:</p><ol><li><tex>T</tex> is model complete.</li>
    <li>For all models <tex>M \subseteq  M'</tex> of <tex>T</tex> and all existential setnences <tex>\phi</tex> from <tex>L(M)</tex>, then <tex>M' \vDash   \phi   \implies  M  \vDash   \phi</tex></li>
    <li>Each formula is, modulo <tex>T</tex>, equivalent to a universal formula. </li></ol><p>Proof: </p><ul><li><tex>1 \implies  2</tex>, Given that the definition of <link href="BMT-d016.xml" type="local" title="Model Complete Theory">model complete</link> implies that every embedding of models is an <link href="BMT-d030.xml" type="local" title="Elementary Embedding of L-structures">elementary emedding</link>,then condition 2 above is actually true for all sentences, in particular existential sentences. </li>
    <li><tex>2 \implies  3</tex>, Given an existential formula <tex>\phi</tex>,  </li>
    <li><tex>3 \implies  1</tex></li></ul></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>46</crumb></trail> <anchor>2779</anchor>  <taxon>Section</taxon> <addr>BMT-s009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s009.tree</source-path> <route>BMT-s009.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>Categoricity</title> </frontmatter> <mainmatter><p>In this section, we give the basic definitions for <tex>\kappa</tex>-categoricity. We then establish some classical characterisations of <tex>\aleph _0</tex>-categoricity.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>46</crumb> <crumb>1</crumb></trail> <anchor>2780</anchor>  <taxon>Definition</taxon> <addr>BMT-d201</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d201.tree</source-path> <route>BMT-d201.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title><tex>\kappa</tex>-categoricity</title> </frontmatter> <mainmatter><p>
    Given a cardinal <tex>\kappa</tex> and a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, an <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory</link> is <em><tex>\kappa</tex>-categorical</em> if whenever <tex>\mathcal {M}</tex> and <tex>\mathcal {N}</tex> are <tex>\mathcal {L}</tex>-structures with <tex>| \mathcal {M}|=| \mathcal {M}|= \kappa</tex>, then <tex>\mathcal {M}  \cong   \mathcal {N}</tex>. 
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>46</crumb> <crumb>2</crumb></trail> <anchor>2781</anchor>  <taxon>Definition</taxon> <addr>BMT-d202</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d202.tree</source-path> <route>BMT-d202.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>Tarski-Lindenbaum Algebra</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and an <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory</link>, <tex>T</tex>, the <em><tex>n</tex>'th Tarski-Lindenbaum algebra of <tex>T</tex></em> is the set of <link href="BMT-d009.xml" type="local" title="{L}-Formula"><tex>\mathcal {L}</tex>-formulas</link> quotiented by the relation of <link href="BMT-d018.xml" type="local" title="Definition of T-equivalence of formulas"><tex>T</tex>-equivalence</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>46</crumb> <crumb>3</crumb></trail> <anchor>2782</anchor>  <taxon>Theorem</taxon> <addr>BMT-t003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t003.tree</source-path> <route>BMT-t003.xml</route> <date><year>2024</year> <month>4</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>(Ryll-Nardjewski) Characterisations of <tex>\omega</tex>-categoricity</title> </frontmatter> <mainmatter><p>For <tex>\aleph _0</tex>-categoricity, there are a number of useful characterisations. The following are due to Ryll-Nardjewski.</p><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and an <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory</link> <tex>T</tex>, the following are equivalent:</p><p>1 <tex>T</tex> is <tex>\aleph _0</tex>-categorical.</p><p>For every <tex>n \in   \omega</tex>, there are finitely many <link href="BMT-d009.xml" type="local" title="{L}-Formula"><tex>\mathcal {L}</tex>-formulas</link> in <tex>n</tex>-variables up to <link href="BMT-d018.xml" type="local" title="Definition of T-equivalence of formulas"><tex>T</tex>-equivalence</link>.</p><p>For every <tex>n \in   \omega</tex>, the <link href="BMT-d202.xml" type="local" title="Tarski-Lindenbaum Algebra"><tex>n</tex>'th Tarski-Lindenbaum algebra of <tex>T</tex></link> is finite. 
Every <link href="BMT-d019.xml" type="local" title="Definition of a type">type</link> over <tex>T</tex> is <link href="BMT-d020.xml" type="local" title="Definition of an isolated/principal type">isolated</link>. </p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>47</crumb></trail> <anchor>2783</anchor>  <taxon>Section</taxon> <addr>BMT-s010</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s010.tree</source-path> <route>BMT-s010.xml</route> <date><year>2024</year> <month>4</month> <day>25</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Examples</title> </frontmatter> <mainmatter><p>
    Here, we give the basic and canonical examples of Model Theory, summarizing their properties.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>47</crumb> <crumb>1</crumb></trail> <anchor>2784</anchor>  <taxon>Example</taxon> <addr>BMT-e030</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e030.tree</source-path> <route>BMT-e030.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>DLO</title> </frontmatter> <mainmatter><p>
    The <em>dense linear order without endpoints</em> (DLO) is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">theory</link> in the <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal  L= \{ &lt; \}</tex>
    consisting of the following <link href="BMT-d013.xml" type="local" title="Definition of Sentences">sentences</link>.
    <ul><li><tex>\forall  x \, \neg  x&lt;x</tex></li>
        <li><tex>\forall  x \forall  y \, (x&lt;y \rightarrow \neg (y&lt;x))</tex></li>
        <li><tex>\forall  x \forall  y \forall  z \, ((x&lt;y \land  y&lt;z) \rightarrow  x&lt;z)</tex></li>
        <li><tex>\forall  x \forall  y \, (( \neg  x=y) \rightarrow (x&lt;y \lor  y&lt;x))</tex></li>
        <li><tex>\forall  x \forall  y \, x&lt;y \rightarrow ( \exists  z \, x&lt;z \land  z&lt;y)</tex></li>
        <li><tex>\forall  x \exists  z \, z&lt;x</tex></li>
        <li><tex>\forall  x \exists  z \, x&lt;z</tex></li></ul></p><p>
    The set of rationals <tex>\mathbb  Q</tex> with the usual ordering is a model of DLO, and DLO is <link href="BMT-d201.xml" type="local" title="-Categoricity"><tex>\aleph _0</tex>-categorical</link>,
    so every countable model is isomorphic to <tex>( \mathbb  Q,&lt;)</tex>. DLO is also a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">complete theory</link> with
    <link href="BMT-s003.xml" type="local" title="Quantifier Elimination">quantifier elimination</link>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>47</crumb> <crumb>2</crumb></trail> <anchor>2785</anchor>  <taxon>Example</taxon> <addr>BMT-e031</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e031.tree</source-path> <route>BMT-e031.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Algebraically Closed Fields</title> </frontmatter> <mainmatter><p>
    The theory of <em>algebraically closed fields</em> (ACF) is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">theory</link> in the <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal  L= \{ 0,1,+, \cdot \}</tex>
    consisting of the following <link href="BMT-d013.xml" type="local" title="Definition of Sentences">sentences</link>.
    <ul><li><tex>\forall  x \forall  y \forall  z \, (x+y)+z=x+(y+z)</tex>.
        </li>
        <li><tex>\forall  x \, x+0=x \land0 +x=x</tex>.
        </li>
        <li><tex>\forall  x \exists  y \, x+y=0 \land  y+x=0</tex>.
        </li>
        <li><tex>\forall  x \forall  y \, x+y=y+x</tex>.
        </li>
        <li><tex>\forall  x \forall  y \forall  z \, (x \cdot  y) \cdot  z=x \cdot  (y+ \cdot  z)</tex>.
        </li>
        <li><tex>\forall  x \, x \cdot1 =x \land1 \cdot  x=x</tex>.
        </li>
        <li><tex>\forall  x \exists  y \, x \cdot  y=1 \land  y \cdot  x=1</tex>.
        </li>
        <li><tex>\forall  x \forall  y \, x+ \cdot  y=y \cdot  x</tex>.
        </li>
        <li><tex>\forall  x \forall  y \forall  z \, x \cdot (y+z)=(x \cdot  y)+(x \cdot  z)</tex>.
        </li>
        <li>
            For each <tex>n \in \mathbb  N</tex>, a sentence <tex>\forall  y_1 \cdots \forall  y_n \exists  x \, (y_1 \cdot  x)+ \cdots +(y_n \cdot  x)=0</tex>.
        </li></ul></p><p>
    The theory of algebraically closed fields of characteristic <tex>p</tex> (<tex>\text {ACF}_p</tex>) is ACF together with the sentence
    <tex>1+ \cdots +1=0</tex>, where <tex>1</tex> is being added <tex>p</tex> times. <tex>\text {ACF}_p</tex> is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">complete theory</link> having
    <link href="BMT-s003.xml" type="local" title="Quantifier Elimination">quantifier elimination</link>.
</p><p>
    The theory of algebraically closed fields of characteristic <tex>0</tex> (<tex>\text {ACF}_0</tex>) is ACF together with the collection of sentences
    of the form <tex>\neg (1+ \cdots +1=0)</tex>, for any number of <tex>1</tex>s being added together. <tex>\text {ACF}_0</tex> is also a
    <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">complete theory</link> having <link href="BMT-s003.xml" type="local" title="Quantifier Elimination">quantifier elimination</link>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>47</crumb> <crumb>3</crumb></trail> <anchor>2786</anchor>  <taxon>Example</taxon> <addr>BMT-e032</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e032.tree</source-path> <route>BMT-e032.xml</route> <date><year>2024</year> <month>9</month> <day>12</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Vector Spaces</title> </frontmatter> <mainmatter><p>
    The theory of vector spaces over a field <tex>F</tex> is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">theory</link> in the <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal  L= \{ 0,+,( \times _f)_{f \in  F} \}</tex>
    consisting of the following <link href="BMT-d013.xml" type="local" title="Definition of Sentences">sentences</link>.
    <ul><li><tex>\forall  x \forall  y \forall  z \, (x+y)+z=x+(y+z)</tex>.
        </li>
        <li><tex>\forall  x \, x+0=x \land0 +x=x</tex>.
        </li>
        <li><tex>\forall  x \exists  y \, x+y=0 \land  y+x=0</tex>.
        </li>
        <li><tex>\forall  x \forall  y \, x+y=y+x</tex>.
        </li>
        <li>
            For each <tex>f,g \in  F</tex>, the sentence <tex>\forall  x \, \times _f( \times _g(x)) =  \times _{fg}(x)</tex>, where <tex>fg</tex> is the product of <tex>f</tex> and <tex>g</tex> in <tex>F</tex>.
        </li>
        <li><tex>\forall  x \, \times _1(x) = x</tex> where <tex>1</tex> is the multiplicative identity in <tex>F</tex>.
        </li>
        <li>
            For each <tex>f \in  F</tex>, the sentence <tex>\forall  x \forall  y \, \times _f(x+y) =  \times _f(x)+ \times _f(y)</tex>.
        </li>
        <li>
            For each <tex>f,g \in  F</tex>, the sentence <tex>\forall  x \, \times _(f+g)(x) =  \times _f(x)+ \times _g(x)</tex>, where <tex>f+g</tex> is the sum of <tex>f</tex> and <tex>g</tex> in <tex>F</tex>.
        </li></ul></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>47</crumb> <crumb>4</crumb></trail> <anchor>2787</anchor>  <taxon>Example</taxon> <addr>BMT-e033</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e033.tree</source-path> <route>BMT-e033.xml</route> <date><year>2024</year> <month>10</month> <day>10</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Equivalence Relation</title> </frontmatter> <mainmatter><p>
    The theory of an equivalence relation is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">theory</link> in the <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal  L= \{ E \}</tex>,
    where <tex>E</tex> is a binary relation, consisting of the following <link href="BMT-d013.xml" type="local" title="Definition of Sentences">sentences</link>.
    <ul><li><tex>\forall  x \, xEx</tex>.
        </li>
        <li><tex>\forall  x \forall  y \, xEy \rightarrow  yEx</tex>.
        </li>
        <li><tex>\forall  x \forall  y \forall  z \, (xEy \land  yEz) \rightarrow  xEz</tex>.
        </li></ul></p><p>
    Being uncomplicated, this theory is usually shown as an initial example (or rather, counterexample) of various properties.
    It is straightforward to add more restrictions, such as stating that there are only <tex>n</tex> equivalence classes:
    <ul><li><tex>\exists  x_1 \cdots \exists  x_n \forall  y \, \bigvee _{i=1}^nx_iEy</tex>.
        </li></ul>
    Or, that each equivalence class has at most <tex>k</tex> elements:
    <ul><li><tex>\forall  x \exists  y_1 \cdots \exists  y_k \forall  z \, (x=z) \rightarrow \bigvee _{i=1}^ny_iEz</tex>.
        </li></ul>
    Or, that each equivalence class has infinitely many elements:
    <ul><li>
            For each <tex>k</tex>, the sentence <tex>\forall  x_1 \cdots \forall  x_k \exists  y \, \bigwedge _{i=1}^n \neg (x_iEy)</tex>.
        </li></ul></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>47</crumb> <crumb>5</crumb></trail> <anchor>2788</anchor>  <taxon>Example</taxon> <addr>BMT-e034</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e034.tree</source-path> <route>BMT-e034.xml</route> <date><year>2024</year> <month>10</month> <day>10</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Graphs (Rado Graph)</title> </frontmatter> <mainmatter><p>
    The theory of a graph is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">theory</link> in the <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal  L= \{ R \}</tex>, where <tex>R</tex> is a binary relation.
    Depending on the author, the theory may only demand symmetry, <tex>\forall  x \forall  y \, xRy \rightarrow  yRx</tex>,
    or additionally include irreflexivity: <tex>\forall  x \, \neg  xRx</tex>.
</p><p>
    The theory of the <em>Rado graph</em> (also called the random graph) is an extension of the theory of the graph by the extension axiom schema:
    <ul><li>
            For each <tex>n</tex> and <tex>m</tex>, the sentence
            <tex>\forall  x_1 \cdots \forall  x_n \forall  y_1 \cdots \forall  y_m \exists  z \, \bigwedge _{i=1}^nzRx_i \land \bigwedge _{j=1}^m \neg  zRy_j</tex>.
        </li></ul>
    This ``single'' schema is enough to make the theory <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">complete</link>,
    and in fact the theory of the Rado graph is <link href="BMT-d201.xml" type="local" title="-Categoricity"><tex>\aleph _0</tex>-categorical</link>.
</p></mainmatter> </tree></mainmatter> </tree>
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2789</anchor>  <taxon>Definition</taxon> <addr>BMT-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d004.tree</source-path> <route>BMT-d004.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Embedding of <tex>L</tex>-structures</title> </frontmatter> <mainmatter><p>Given two structures in a language <tex>\mathcal {L}</tex> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex>, an <em>embedding</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a <link href="BMT-d003.xml" type="local" title="Homomorphism">homomorphism</link> such that:</p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Leftrightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>This is stronger than a homomorphism because we now require a two way implication in the above property.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2790</anchor>  <taxon>Section</taxon> <addr>BMT-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s002.tree</source-path> <route>BMT-s002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> <contributor><link href="francis-westhead.xml" type="local">Francis Westhead</link></contributor><contributor><link href="oscarc.xml" type="local">Oscar Coppola</link></contributor></authors> <title>Formulas and Models</title> </frontmatter> <mainmatter><p>In this section we define formulas, elementary equivalence, elementary substructures, theories, and models</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>48</crumb></trail> <anchor>2791</anchor>  <taxon>Definition</taxon> <addr>BMT-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d007.tree</source-path> <route>BMT-d007.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Term</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, we define a <em>term</em> to be any of the following:</p><p>If <tex>c \in   \mathcal {L}</tex> is a constant symbol, then <tex>c</tex> is a term</p><p>If <tex>x</tex> is a variable symbol, then <tex>x</tex> is a term. We generally assume we have countably infinitely many variable symbols</p><p>If <tex>t_1,..., t_n</tex> are terms, and <tex>f \in   \mathcal {L}</tex> is an <tex>n</tex>-ary function, then <tex>f(t_1,..., t_n)</tex> is a term.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb></trail> <anchor>2792</anchor>  <taxon>Definition</taxon> <addr>BMT-d008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d008.tree</source-path> <route>BMT-d008.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <em>atomic formula</em> is defined as follows:</p><p>If <tex>R \in   \mathcal {L}</tex> is an n-ary relation symbol, and <tex>t_1, \dots , t_n</tex> are <link href="BMT-d007.xml" type="local" title="Term">terms</link>, then <tex>R(t_1, \dots , t_n)</tex> is an atomic formula.</p><p>If <tex>t_1</tex> and <tex>t_2</tex> are <tex>\mathcal {L}</tex>-terms, then <tex>t_1 = t_2</tex> is an atomic formula. </p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb></trail> <anchor>2793</anchor>  <taxon>Definition</taxon> <addr>BMT-d009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d009.tree</source-path> <route>BMT-d009.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>\mathcal {L}</tex>-Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-formula is defined inductively as follows:</p><p><ul><li>
            If <tex>\phi</tex> is an <tex>\mathcal {L}</tex>-<link href="BMT-d008.xml" type="local" title="Atomic Formula">atomic formula</link> then <tex>\phi</tex> is a formula.
        </li>
        <li>
            If <tex>\phi</tex> and <tex>\psi</tex> are both formulas, then <tex>\neg \phi</tex>, <tex>\phi   \land   \psi</tex>, and 
            <tex>\phi \lor \phi</tex> are formulas, where <tex>\lor , \neg , \land</tex> are the usual <link href="BMT-d010.xml" type="local" title="Definition of Logical Connectives">logical connectives</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li></ul></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>51</crumb></trail> <anchor>2794</anchor>  <taxon>Definition</taxon> <addr>BMT-d017</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d017.tree</source-path> <route>BMT-d017.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Definition of an <tex>\mathcal {L}</tex>-theory</title> </frontmatter> <mainmatter><p>
    Given a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, a <em><tex>\mathcal {L}</tex>-theory</em> is a set of <link href="BMT-d013.xml" type="local" title="Definition of Sentences"><tex>\mathcal {L}</tex>-sentences</link>.
    Sometimes it is notationally convenient to assume that theories are deductively closed.
</p><p>
    An <tex>\mathcal  L</tex>-theory is <em>complete</em> when for every <link href="BMT-d009.xml" type="local" title="{L}-Formula"><tex>\mathcal  L</tex>-formula</link> <tex>\phi</tex> we have that
    <tex>\phi</tex> may be deduced from <tex>T</tex> or <tex>\neg \phi</tex> may be deduced from <tex>T</tex>.
</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2795</anchor>  <taxon>Definition</taxon> <addr>BMT-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d003.tree</source-path> <route>BMT-d003.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Homomorphism</title> </frontmatter> <mainmatter><p>Given two <link href="BMT-d002.xml" type="local" title="Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, a <em>homomorphism</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a function between the universes <tex>A</tex> and <tex>B</tex> of <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> respectively such that:</p><p> For every n-ary function <tex>f \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n \in  A</tex>, <tex>\varphi (f^{ \mathcal {A}}(a_1, \dots , a_n)) = f^{ \mathcal {B}}( \varphi (a_1), \dots ,  \varphi (a_n))</tex></p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Rightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>For every constant symbol <tex>c  \in   \mathcal {L}</tex>, <tex>\varphi (c^{ \mathcal {A}}) =c^{ \mathcal {B}}</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2796</anchor>  <taxon>Part</taxon> <addr>inf-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Infinitary Logic/inf-p001.tree</source-path> <route>inf-p001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Infinitary Model Theory</title> </frontmatter> <mainmatter><p>We present the fundamentals of infinitary model theory. The main reference will be David Marker's book Lectures on Infinitary Logic</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2797</anchor>  <taxon>Definition</taxon> <addr>BMT-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d005.tree</source-path> <route>BMT-d005.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Isomorphism</title> </frontmatter> <mainmatter><p>An <link href="BMT-d004.xml" type="local" title="Embedding of L-structures">embedding</link> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex> between <tex>\mathcal {L}</tex>-structures is a <em>isomorphism</em> if it is surjective.

An automorphism of a <link href="BMT-d002.xml" type="local" title="Structure">structure</link> <tex>\mathcal {A}</tex> is an isomorphism to itself.
</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2798</anchor>  <taxon>Definition</taxon> <addr>BMT-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d001.tree</source-path> <route>BMT-d001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Language</title> </frontmatter> <mainmatter><p>A language, also called a vocabulary or signature by different authors, is a set <tex>\mathcal {L}</tex> consisting of symbols for constants, relations, and functions, 
often denoted by <tex>c</tex>, <tex>R</tex>, and <tex>f</tex> respectively. Languages may have any cardinality.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2799</anchor>  <taxon>Definition</taxon> <addr>BMT-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d002.tree</source-path> <route>BMT-d002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Structure</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-structure <tex>\mathcal {M}</tex> in this language has a universe <tex>M</tex> (often, the structure and its universe 
are written the same, by abuse of notation). The structure <tex>\mathcal {M}</tex> &quot;interprets&quot; the symbols of <tex>\mathcal {L}</tex> as follows:</p><p>For a constant symbol <tex>c \in   \mathcal {L}</tex>, the interpretation of <tex>c</tex> in <tex>\mathcal {M}</tex>, denoted <tex>c^{ \mathcal {M}}</tex> represents a fixed 
element of <tex>M</tex></p><p>For an <tex>n</tex>-ary function symbol <tex>f \in   \mathcal {L}</tex>, the interpretation of <tex>f</tex> in <tex>\mathcal {M}</tex>, denoted <tex>f^{ \mathcal {M}}</tex>,
is a function from <tex>M^n</tex> to <tex>M</tex></p><p>For an <tex>n</tex>-ary relation symbol <tex>R \in   \mathcal {L}</tex>, the interpretation of <tex>R</tex> in <tex>\mathcal {M}</tex>, denoted <tex>R^{ \mathcal {M}}</tex>,
is a subset <tex>M^n</tex></p><p>Often, we are interested in the cardinality of a structure, denoted <tex>| \mathcal {M}|</tex>, which is defined to be the cardinality of its universe.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2800</anchor>  <taxon>Section</taxon> <addr>BMT-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s001.tree</source-path> <route>BMT-s001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Structures, Isomorphisms, Substructures</title> </frontmatter> <mainmatter><p>In this section we give the basic notions and theorems for structures, isomorphisms, and substructures</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>52</crumb></trail> <anchor>2801</anchor>  <taxon>Definition</taxon> <addr>BMT-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d001.tree</source-path> <route>BMT-d001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Language</title> </frontmatter> <mainmatter><p>A language, also called a vocabulary or signature by different authors, is a set <tex>\mathcal {L}</tex> consisting of symbols for constants, relations, and functions, 
often denoted by <tex>c</tex>, <tex>R</tex>, and <tex>f</tex> respectively. Languages may have any cardinality.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>53</crumb></trail> <anchor>2802</anchor>  <taxon>Definition</taxon> <addr>BMT-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d002.tree</source-path> <route>BMT-d002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Structure</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-structure <tex>\mathcal {M}</tex> in this language has a universe <tex>M</tex> (often, the structure and its universe 
are written the same, by abuse of notation). The structure <tex>\mathcal {M}</tex> &quot;interprets&quot; the symbols of <tex>\mathcal {L}</tex> as follows:</p><p>For a constant symbol <tex>c \in   \mathcal {L}</tex>, the interpretation of <tex>c</tex> in <tex>\mathcal {M}</tex>, denoted <tex>c^{ \mathcal {M}}</tex> represents a fixed 
element of <tex>M</tex></p><p>For an <tex>n</tex>-ary function symbol <tex>f \in   \mathcal {L}</tex>, the interpretation of <tex>f</tex> in <tex>\mathcal {M}</tex>, denoted <tex>f^{ \mathcal {M}}</tex>,
is a function from <tex>M^n</tex> to <tex>M</tex></p><p>For an <tex>n</tex>-ary relation symbol <tex>R \in   \mathcal {L}</tex>, the interpretation of <tex>R</tex> in <tex>\mathcal {M}</tex>, denoted <tex>R^{ \mathcal {M}}</tex>,
is a subset <tex>M^n</tex></p><p>Often, we are interested in the cardinality of a structure, denoted <tex>| \mathcal {M}|</tex>, which is defined to be the cardinality of its universe.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>54</crumb></trail> <anchor>2803</anchor>  <taxon>Definition</taxon> <addr>BMT-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d003.tree</source-path> <route>BMT-d003.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Homomorphism</title> </frontmatter> <mainmatter><p>Given two <link href="BMT-d002.xml" type="local" title="Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, a <em>homomorphism</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a function between the universes <tex>A</tex> and <tex>B</tex> of <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> respectively such that:</p><p> For every n-ary function <tex>f \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n \in  A</tex>, <tex>\varphi (f^{ \mathcal {A}}(a_1, \dots , a_n)) = f^{ \mathcal {B}}( \varphi (a_1), \dots ,  \varphi (a_n))</tex></p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Rightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>For every constant symbol <tex>c  \in   \mathcal {L}</tex>, <tex>\varphi (c^{ \mathcal {A}}) =c^{ \mathcal {B}}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>55</crumb></trail> <anchor>2804</anchor>  <taxon>Definition</taxon> <addr>BMT-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d004.tree</source-path> <route>BMT-d004.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Embedding of <tex>L</tex>-structures</title> </frontmatter> <mainmatter><p>Given two structures in a language <tex>\mathcal {L}</tex> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex>, an <em>embedding</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a <link href="BMT-d003.xml" type="local" title="Homomorphism">homomorphism</link> such that:</p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Leftrightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>This is stronger than a homomorphism because we now require a two way implication in the above property.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>56</crumb></trail> <anchor>2805</anchor>  <taxon>Definition</taxon> <addr>BMT-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d005.tree</source-path> <route>BMT-d005.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Isomorphism</title> </frontmatter> <mainmatter><p>An <link href="BMT-d004.xml" type="local" title="Embedding of L-structures">embedding</link> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex> between <tex>\mathcal {L}</tex>-structures is a <em>isomorphism</em> if it is surjective.

An automorphism of a <link href="BMT-d002.xml" type="local" title="Structure">structure</link> <tex>\mathcal {A}</tex> is an isomorphism to itself.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>57</crumb></trail> <anchor>2806</anchor>  <taxon>Definition</taxon> <addr>BMT-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d006.tree</source-path> <route>BMT-d006.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Substructure</title> </frontmatter> <mainmatter><p>Given a <tex>\mathcal {L}</tex>-structure <tex>\mathcal {A}</tex>, a subset <tex>B  \subseteq  A</tex> is called a <em>substructure</em> of <tex>\mathcal {A}</tex> if:</p><p>For every constant <tex>c \in   \mathcal {L}</tex>, <tex>c^{ \mathcal {A}}  \in  B</tex></p><p>For every n-ary function <tex>f \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, <tex>f^{ \mathcal {A}}(b_1, \dots ,b_n)  \in  B</tex></p><p>For every n-ary relation, <tex>R \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, we write <tex>R^B = R^{ \mathcal {A}} \cap   \mathcal {P}(B^n)</tex> and require that
<tex>R^{B}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{B}</tex>)  if and only if <tex>R^{ \mathcal {A}}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{ \mathcal {A}}</tex>) 
Note that this condition is vacuously true, so only the first two conditions need to be checked when verifying a substructure.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>58</crumb></trail> <anchor>2807</anchor>  <taxon>Definition</taxon> <addr>BMT-d030</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d030.tree</source-path> <route>BMT-d030.xml</route> <date><year>2024</year> <month>9</month> <day>19</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Elementary Embedding of <tex>L</tex>-structures</title> </frontmatter> <mainmatter><p>
    Given two <link href="BMT-d002.xml" type="local" title="Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>,
    a <link href="BMT-d003.xml" type="local" title="Homomorphism">homomorphism</link> <tex>\Phi \colon \mathcal {A}  \to   \mathcal {B}</tex> is an <em>elementary embedding</em> when
    for every <tex>\mathcal  L</tex>-formula <tex>\varphi (x_1, \dots ,x_n)</tex> and <tex>a_1, \dots ,a_n \in  A</tex>,
    we have <tex>\mathcal  A \vDash \varphi (a_1, \dots ,a_n)</tex> if and only if <tex>\mathcal  B \vDash \varphi ( \Phi (a_1), \dots , \Phi (a_n))</tex>.

    A partial homomorphism <tex>\Phi : \mathcal {A} \to \mathcal {B}</tex> can also be said to be an elementary embedding when
    for every <tex>\mathcal  L</tex>-formula <tex>\varphi (x_1, \dots ,x_n)</tex> and <tex>a_1, \dots ,a_n \in  dom \Phi</tex>,
    we have <tex>\mathcal  A \vDash \varphi (a_1, \dots ,a_n)</tex> if and only if <tex>\mathcal  B \vDash \varphi ( \Phi (a_1), \dots , \Phi (a_n))</tex>.


</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>59</crumb></trail> <anchor>2808</anchor>  <taxon>Definition</taxon> <addr>BMT-d031</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d031.tree</source-path> <route>BMT-d031.xml</route> <date><year>2024</year> <month>9</month> <day>19</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Elementary Substructures</title> </frontmatter> <mainmatter><p>
    Given two <link href="BMT-d002.xml" type="local" title="Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>
    such that <tex>\mathcal  A</tex> is a <link href="BMT-d006.xml" type="local" title="Substructure">substructure</link> of <tex>\mathcal  B</tex>,
    <tex>\mathcal  A</tex> is an <em>elementary substructure</em> of <tex>\mathcal  B</tex> when the inclusion map <tex>\mathcal  A \hookrightarrow \mathcal  B</tex>
    is an <link href="BMT-d030.xml" type="local" title="Elementary Embedding of L-structures">elementary embedding</link>.
    Conversely, <tex>\mathcal  B</tex> is called an elementary extension of <tex>\mathcal  A</tex>.
</p><p>
    One writes <tex>\mathcal  A \preceq \mathcal  B</tex> to mean <tex>\mathcal  A</tex> is an elementary substructure of <tex>\mathcal  B</tex>.
</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2809</anchor>  <taxon>Definition</taxon> <addr>BMT-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d006.tree</source-path> <route>BMT-d006.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Substructure</title> </frontmatter> <mainmatter><p>Given a <tex>\mathcal {L}</tex>-structure <tex>\mathcal {A}</tex>, a subset <tex>B  \subseteq  A</tex> is called a <em>substructure</em> of <tex>\mathcal {A}</tex> if:</p><p>For every constant <tex>c \in   \mathcal {L}</tex>, <tex>c^{ \mathcal {A}}  \in  B</tex></p><p>For every n-ary function <tex>f \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, <tex>f^{ \mathcal {A}}(b_1, \dots ,b_n)  \in  B</tex></p><p>For every n-ary relation, <tex>R \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, we write <tex>R^B = R^{ \mathcal {A}} \cap   \mathcal {P}(B^n)</tex> and require that
<tex>R^{B}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{B}</tex>)  if and only if <tex>R^{ \mathcal {A}}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{ \mathcal {A}}</tex>) 
Note that this condition is vacuously true, so only the first two conditions need to be checked when verifying a substructure.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>2810</anchor>  <taxon>Definition</taxon> <addr>BMT-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d007.tree</source-path> <route>BMT-d007.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Term</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, we define a <em>term</em> to be any of the following:</p><p>If <tex>c \in   \mathcal {L}</tex> is a constant symbol, then <tex>c</tex> is a term</p><p>If <tex>x</tex> is a variable symbol, then <tex>x</tex> is a term. We generally assume we have countably infinitely many variable symbols</p><p>If <tex>t_1,..., t_n</tex> are terms, and <tex>f \in   \mathcal {L}</tex> is an <tex>n</tex>-ary function, then <tex>f(t_1,..., t_n)</tex> is a term.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="true"><frontmatter> <anchor>2811</anchor>   <addr>mon-0001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/mon-0001.tree</source-path> <route>index.xml</route>  <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="gpeters.xml" type="local">Garrett Peters</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>The Model Companion</title> </frontmatter> <mainmatter><p>This is the potential start of a new online resource on model theory, replacing the (now defunct) model theory wiki.</p><p>This website is made with the software Forester (http://www.jonmsterling.com/jms-005P.xml). Forester allows you to explore the site in many interesting ways, we have provided a structured starting off points as in below but you may search for any page using Command K</p><p>The site is nonlinear in its arrangement of information. At the high level, the website is broken into parts which are comprised of sections. Currently parts correspond to large themes or subjects in model theory and the sections subdivide these themes further. These parts and sections may not be disjoint but the nature of forester is well suited to navigating these overlaps since definitions and theorems can be transcluded easily. </p><p>In the future it would be nice to have parts which organize the material as one would encounter it as a course or set of lecture notes intended for self study but for now, we intend to set up the backbone as a wikipedia or stacks project reference document and then reassemble the information after a critical mass has been achieved. </p><strong>Here are the parts which currently exist or are being worked on</strong>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb></trail> <anchor>2812</anchor>  <taxon>Part</taxon> <addr>BMT-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-p001.tree</source-path> <route>BMT-p001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> <contributor><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></contributor><contributor><link href="francis-westhead.xml" type="local">Francis Westhead</link></contributor><contributor><link href="gpeters.xml" type="local">Garrett Peters</link></contributor><contributor><link href="oscarc.xml" type="local">Oscar Coppola</link></contributor><contributor><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></contributor></authors> <title>Basic Model Theory</title> </frontmatter> <mainmatter><p>We give the common definitions and theorems for basic/introductory model theory</p>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>1</crumb></trail> <anchor>2813</anchor>  <taxon>Section</taxon> <addr>BMT-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s001.tree</source-path> <route>BMT-s001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Structures, Isomorphisms, Substructures</title> </frontmatter> <mainmatter><p>In this section we give the basic notions and theorems for structures, isomorphisms, and substructures</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>1</crumb> <crumb>1</crumb></trail> <anchor>2814</anchor>  <taxon>Definition</taxon> <addr>BMT-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d001.tree</source-path> <route>BMT-d001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Language</title> </frontmatter> <mainmatter><p>A language, also called a vocabulary or signature by different authors, is a set <tex>\mathcal {L}</tex> consisting of symbols for constants, relations, and functions, 
often denoted by <tex>c</tex>, <tex>R</tex>, and <tex>f</tex> respectively. Languages may have any cardinality.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>1</crumb> <crumb>2</crumb></trail> <anchor>2815</anchor>  <taxon>Definition</taxon> <addr>BMT-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d002.tree</source-path> <route>BMT-d002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Structure</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-structure <tex>\mathcal {M}</tex> in this language has a universe <tex>M</tex> (often, the structure and its universe 
are written the same, by abuse of notation). The structure <tex>\mathcal {M}</tex> &quot;interprets&quot; the symbols of <tex>\mathcal {L}</tex> as follows:</p><p>For a constant symbol <tex>c \in   \mathcal {L}</tex>, the interpretation of <tex>c</tex> in <tex>\mathcal {M}</tex>, denoted <tex>c^{ \mathcal {M}}</tex> represents a fixed 
element of <tex>M</tex></p><p>For an <tex>n</tex>-ary function symbol <tex>f \in   \mathcal {L}</tex>, the interpretation of <tex>f</tex> in <tex>\mathcal {M}</tex>, denoted <tex>f^{ \mathcal {M}}</tex>,
is a function from <tex>M^n</tex> to <tex>M</tex></p><p>For an <tex>n</tex>-ary relation symbol <tex>R \in   \mathcal {L}</tex>, the interpretation of <tex>R</tex> in <tex>\mathcal {M}</tex>, denoted <tex>R^{ \mathcal {M}}</tex>,
is a subset <tex>M^n</tex></p><p>Often, we are interested in the cardinality of a structure, denoted <tex>| \mathcal {M}|</tex>, which is defined to be the cardinality of its universe.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>1</crumb> <crumb>3</crumb></trail> <anchor>2816</anchor>  <taxon>Definition</taxon> <addr>BMT-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d003.tree</source-path> <route>BMT-d003.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Homomorphism</title> </frontmatter> <mainmatter><p>Given two <link href="BMT-d002.xml" type="local" title="Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, a <em>homomorphism</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a function between the universes <tex>A</tex> and <tex>B</tex> of <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> respectively such that:</p><p> For every n-ary function <tex>f \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n \in  A</tex>, <tex>\varphi (f^{ \mathcal {A}}(a_1, \dots , a_n)) = f^{ \mathcal {B}}( \varphi (a_1), \dots ,  \varphi (a_n))</tex></p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Rightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>For every constant symbol <tex>c  \in   \mathcal {L}</tex>, <tex>\varphi (c^{ \mathcal {A}}) =c^{ \mathcal {B}}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>1</crumb> <crumb>4</crumb></trail> <anchor>2817</anchor>  <taxon>Definition</taxon> <addr>BMT-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d004.tree</source-path> <route>BMT-d004.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Embedding of <tex>L</tex>-structures</title> </frontmatter> <mainmatter><p>Given two structures in a language <tex>\mathcal {L}</tex> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex>, an <em>embedding</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a <link href="BMT-d003.xml" type="local" title="Homomorphism">homomorphism</link> such that:</p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Leftrightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>This is stronger than a homomorphism because we now require a two way implication in the above property.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>1</crumb> <crumb>5</crumb></trail> <anchor>2818</anchor>  <taxon>Definition</taxon> <addr>BMT-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d005.tree</source-path> <route>BMT-d005.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Isomorphism</title> </frontmatter> <mainmatter><p>An <link href="BMT-d004.xml" type="local" title="Embedding of L-structures">embedding</link> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex> between <tex>\mathcal {L}</tex>-structures is a <em>isomorphism</em> if it is surjective.

An automorphism of a <link href="BMT-d002.xml" type="local" title="Structure">structure</link> <tex>\mathcal {A}</tex> is an isomorphism to itself.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>1</crumb> <crumb>6</crumb></trail> <anchor>2819</anchor>  <taxon>Definition</taxon> <addr>BMT-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d006.tree</source-path> <route>BMT-d006.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Substructure</title> </frontmatter> <mainmatter><p>Given a <tex>\mathcal {L}</tex>-structure <tex>\mathcal {A}</tex>, a subset <tex>B  \subseteq  A</tex> is called a <em>substructure</em> of <tex>\mathcal {A}</tex> if:</p><p>For every constant <tex>c \in   \mathcal {L}</tex>, <tex>c^{ \mathcal {A}}  \in  B</tex></p><p>For every n-ary function <tex>f \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, <tex>f^{ \mathcal {A}}(b_1, \dots ,b_n)  \in  B</tex></p><p>For every n-ary relation, <tex>R \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, we write <tex>R^B = R^{ \mathcal {A}} \cap   \mathcal {P}(B^n)</tex> and require that
<tex>R^{B}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{B}</tex>)  if and only if <tex>R^{ \mathcal {A}}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{ \mathcal {A}}</tex>) 
Note that this condition is vacuously true, so only the first two conditions need to be checked when verifying a substructure.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>1</crumb> <crumb>7</crumb></trail> <anchor>2820</anchor>  <taxon>Definition</taxon> <addr>BMT-d030</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d030.tree</source-path> <route>BMT-d030.xml</route> <date><year>2024</year> <month>9</month> <day>19</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Elementary Embedding of <tex>L</tex>-structures</title> </frontmatter> <mainmatter><p>
    Given two <link href="BMT-d002.xml" type="local" title="Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>,
    a <link href="BMT-d003.xml" type="local" title="Homomorphism">homomorphism</link> <tex>\Phi \colon \mathcal {A}  \to   \mathcal {B}</tex> is an <em>elementary embedding</em> when
    for every <tex>\mathcal  L</tex>-formula <tex>\varphi (x_1, \dots ,x_n)</tex> and <tex>a_1, \dots ,a_n \in  A</tex>,
    we have <tex>\mathcal  A \vDash \varphi (a_1, \dots ,a_n)</tex> if and only if <tex>\mathcal  B \vDash \varphi ( \Phi (a_1), \dots , \Phi (a_n))</tex>.

    A partial homomorphism <tex>\Phi : \mathcal {A} \to \mathcal {B}</tex> can also be said to be an elementary embedding when
    for every <tex>\mathcal  L</tex>-formula <tex>\varphi (x_1, \dots ,x_n)</tex> and <tex>a_1, \dots ,a_n \in  dom \Phi</tex>,
    we have <tex>\mathcal  A \vDash \varphi (a_1, \dots ,a_n)</tex> if and only if <tex>\mathcal  B \vDash \varphi ( \Phi (a_1), \dots , \Phi (a_n))</tex>.


</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>1</crumb> <crumb>8</crumb></trail> <anchor>2821</anchor>  <taxon>Definition</taxon> <addr>BMT-d031</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d031.tree</source-path> <route>BMT-d031.xml</route> <date><year>2024</year> <month>9</month> <day>19</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Elementary Substructures</title> </frontmatter> <mainmatter><p>
    Given two <link href="BMT-d002.xml" type="local" title="Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>
    such that <tex>\mathcal  A</tex> is a <link href="BMT-d006.xml" type="local" title="Substructure">substructure</link> of <tex>\mathcal  B</tex>,
    <tex>\mathcal  A</tex> is an <em>elementary substructure</em> of <tex>\mathcal  B</tex> when the inclusion map <tex>\mathcal  A \hookrightarrow \mathcal  B</tex>
    is an <link href="BMT-d030.xml" type="local" title="Elementary Embedding of L-structures">elementary embedding</link>.
    Conversely, <tex>\mathcal  B</tex> is called an elementary extension of <tex>\mathcal  A</tex>.
</p><p>
    One writes <tex>\mathcal  A \preceq \mathcal  B</tex> to mean <tex>\mathcal  A</tex> is an elementary substructure of <tex>\mathcal  B</tex>.
</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>2</crumb></trail> <anchor>2822</anchor>  <taxon>Section</taxon> <addr>BMT-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s002.tree</source-path> <route>BMT-s002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> <contributor><link href="francis-westhead.xml" type="local">Francis Westhead</link></contributor><contributor><link href="oscarc.xml" type="local">Oscar Coppola</link></contributor></authors> <title>Formulas and Models</title> </frontmatter> <mainmatter><p>In this section we define formulas, elementary equivalence, elementary substructures, theories, and models</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>2</crumb> <crumb>1</crumb></trail> <anchor>2823</anchor>  <taxon>Definition</taxon> <addr>BMT-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d007.tree</source-path> <route>BMT-d007.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Term</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, we define a <em>term</em> to be any of the following:</p><p>If <tex>c \in   \mathcal {L}</tex> is a constant symbol, then <tex>c</tex> is a term</p><p>If <tex>x</tex> is a variable symbol, then <tex>x</tex> is a term. We generally assume we have countably infinitely many variable symbols</p><p>If <tex>t_1,..., t_n</tex> are terms, and <tex>f \in   \mathcal {L}</tex> is an <tex>n</tex>-ary function, then <tex>f(t_1,..., t_n)</tex> is a term.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>2</crumb> <crumb>2</crumb></trail> <anchor>2824</anchor>  <taxon>Definition</taxon> <addr>BMT-d008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d008.tree</source-path> <route>BMT-d008.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <em>atomic formula</em> is defined as follows:</p><p>If <tex>R \in   \mathcal {L}</tex> is an n-ary relation symbol, and <tex>t_1, \dots , t_n</tex> are <link href="BMT-d007.xml" type="local" title="Term">terms</link>, then <tex>R(t_1, \dots , t_n)</tex> is an atomic formula.</p><p>If <tex>t_1</tex> and <tex>t_2</tex> are <tex>\mathcal {L}</tex>-terms, then <tex>t_1 = t_2</tex> is an atomic formula. </p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>2</crumb> <crumb>3</crumb></trail> <anchor>2825</anchor>  <taxon>Definition</taxon> <addr>BMT-d009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d009.tree</source-path> <route>BMT-d009.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>\mathcal {L}</tex>-Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-formula is defined inductively as follows:</p><p><ul><li>
            If <tex>\phi</tex> is an <tex>\mathcal {L}</tex>-<link href="BMT-d008.xml" type="local" title="Atomic Formula">atomic formula</link> then <tex>\phi</tex> is a formula.
        </li>
        <li>
            If <tex>\phi</tex> and <tex>\psi</tex> are both formulas, then <tex>\neg \phi</tex>, <tex>\phi   \land   \psi</tex>, and 
            <tex>\phi \lor \phi</tex> are formulas, where <tex>\lor , \neg , \land</tex> are the usual <link href="BMT-d010.xml" type="local" title="Definition of Logical Connectives">logical connectives</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li></ul></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>2</crumb> <crumb>4</crumb></trail> <anchor>2826</anchor>  <taxon>Definition</taxon> <addr>BMT-d017</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d017.tree</source-path> <route>BMT-d017.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Definition of an <tex>\mathcal {L}</tex>-theory</title> </frontmatter> <mainmatter><p>
    Given a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, a <em><tex>\mathcal {L}</tex>-theory</em> is a set of <link href="BMT-d013.xml" type="local" title="Definition of Sentences"><tex>\mathcal {L}</tex>-sentences</link>.
    Sometimes it is notationally convenient to assume that theories are deductively closed.
</p><p>
    An <tex>\mathcal  L</tex>-theory is <em>complete</em> when for every <link href="BMT-d009.xml" type="local" title="{L}-Formula"><tex>\mathcal  L</tex>-formula</link> <tex>\phi</tex> we have that
    <tex>\phi</tex> may be deduced from <tex>T</tex> or <tex>\neg \phi</tex> may be deduced from <tex>T</tex>.
</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>3</crumb></trail> <anchor>2827</anchor>  <taxon>Section</taxon> <addr>BMT-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s003.tree</source-path> <route>BMT-s003.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> <contributor><link href="oscarc.xml" type="local">Oscar Coppola</link></contributor></authors> <title>Quantifier Elimination</title> </frontmatter> <mainmatter><p>Quantifier Elimination is a part of a broader technique in Model Theory where for a structure in a given language, an arbitrary formula can be written as a boolean combination of perhaps simpler formulas</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>3</crumb> <crumb>1</crumb></trail> <anchor>2828</anchor>  <taxon>Definition</taxon> <addr>BMT-d014</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d014.tree</source-path> <route>BMT-d014.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Elimination Set</title> </frontmatter> <mainmatter><p>An <em>Elimination Set</em> for a language <tex>\mathcal {L}</tex> and class <tex>K</tex> of <tex>\mathcal {L}</tex>-structures, then a set <tex>\Gamma</tex> of formulas <tex>\phi</tex> is an elimination set for <tex>K</tex> if for every formula <tex>\phi ( \bar {x})</tex> of <tex>\mathcal {L}</tex> there is a formula <tex>\phi ^*( \bar {x})</tex> which is a boolean combinations of formulas in <tex>\Gamma</tex> and <tex>\phi</tex> is equivalent to <tex>\phi ^*</tex> in every structure in <tex>K</tex></p></mainmatter> </tree><p>In particular, we will be most interested in elimination sets that are comprised of the set of quantifier free formulas. It is worth noting that, in some cases it is not possible to have a full quantifier elimination down to the level of a quantifier free set but perhaps we can restrict ourself to some reasonable set of formulas.</p><p>Frequently, we use the following lemma to simplify the task of showing that <tex>\Phi</tex> is an elimination set</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>3</crumb> <crumb>2</crumb></trail> <anchor>2829</anchor>  <taxon>Lemma</taxon> <addr>BMT-d015</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d015.tree</source-path> <route>BMT-d015.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Elimination of Atomic Formulas</title> </frontmatter> <mainmatter><p>Let <tex>K</tex> be a class of <tex>L</tex> structures and <tex>\Phi</tex> be a set of <tex>L</tex>-formulas. Denote <tex>\Phi ^-</tex> as the set of negations of formulas in <tex>\Phi</tex>.</p><p>Suppose that 
  <ol><li>every atomic formula of <tex>L</tex> is in <tex>\Phi</tex> and</li> 
    <li>for every formula <tex>\theta ( \overline {x})</tex> of <tex>L</tex> which is of the form <tex>\exists  y  \bigwedge _{i&lt;n}  \psi _i ( \overline {x},y)</tex> with each <tex>\psi _i  \in   \Phi \cup   \Phi ^-</tex>, there is an <tex>L</tex>-formula <tex>\theta ^*( \overline {x})</tex> which is a boolean combination of formulas in <tex>\Phi</tex> and is equivalent to <tex>\theta</tex> in every structure in <tex>K</tex>.</li></ol>
  Then <tex>\Phi</tex> is an elimination set of <tex>K</tex></p></mainmatter> </tree><p>The art of quantifier elimination lies in choosing an appropriate elimination set that allows the above lemma to be used with minimal obstructions. </p><p>There are many examples of theories which have quantifier elimination for a relatively tame set of formulas: </p>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>3</crumb> <crumb>3</crumb></trail> <anchor>2830</anchor>  <taxon>Example</taxon> <addr>BMT-e031</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e031.tree</source-path> <route>BMT-e031.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Algebraically Closed Fields</title> </frontmatter> <mainmatter><p>
    The theory of <em>algebraically closed fields</em> (ACF) is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">theory</link> in the <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal  L= \{ 0,1,+, \cdot \}</tex>
    consisting of the following <link href="BMT-d013.xml" type="local" title="Definition of Sentences">sentences</link>.
    <ul><li><tex>\forall  x \forall  y \forall  z \, (x+y)+z=x+(y+z)</tex>.
        </li>
        <li><tex>\forall  x \, x+0=x \land0 +x=x</tex>.
        </li>
        <li><tex>\forall  x \exists  y \, x+y=0 \land  y+x=0</tex>.
        </li>
        <li><tex>\forall  x \forall  y \, x+y=y+x</tex>.
        </li>
        <li><tex>\forall  x \forall  y \forall  z \, (x \cdot  y) \cdot  z=x \cdot  (y+ \cdot  z)</tex>.
        </li>
        <li><tex>\forall  x \, x \cdot1 =x \land1 \cdot  x=x</tex>.
        </li>
        <li><tex>\forall  x \exists  y \, x \cdot  y=1 \land  y \cdot  x=1</tex>.
        </li>
        <li><tex>\forall  x \forall  y \, x+ \cdot  y=y \cdot  x</tex>.
        </li>
        <li><tex>\forall  x \forall  y \forall  z \, x \cdot (y+z)=(x \cdot  y)+(x \cdot  z)</tex>.
        </li>
        <li>
            For each <tex>n \in \mathbb  N</tex>, a sentence <tex>\forall  y_1 \cdots \forall  y_n \exists  x \, (y_1 \cdot  x)+ \cdots +(y_n \cdot  x)=0</tex>.
        </li></ul></p><p>
    The theory of algebraically closed fields of characteristic <tex>p</tex> (<tex>\text {ACF}_p</tex>) is ACF together with the sentence
    <tex>1+ \cdots +1=0</tex>, where <tex>1</tex> is being added <tex>p</tex> times. <tex>\text {ACF}_p</tex> is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">complete theory</link> having
    <link href="BMT-s003.xml" type="local" title="Quantifier Elimination">quantifier elimination</link>.
</p><p>
    The theory of algebraically closed fields of characteristic <tex>0</tex> (<tex>\text {ACF}_0</tex>) is ACF together with the collection of sentences
    of the form <tex>\neg (1+ \cdots +1=0)</tex>, for any number of <tex>1</tex>s being added together. <tex>\text {ACF}_0</tex> is also a
    <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">complete theory</link> having <link href="BMT-s003.xml" type="local" title="Quantifier Elimination">quantifier elimination</link>.
</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>3</crumb> <crumb>4</crumb></trail> <anchor>2831</anchor>  <taxon>Example</taxon> <addr>BMT-e030</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e030.tree</source-path> <route>BMT-e030.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>DLO</title> </frontmatter> <mainmatter><p>
    The <em>dense linear order without endpoints</em> (DLO) is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">theory</link> in the <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal  L= \{ &lt; \}</tex>
    consisting of the following <link href="BMT-d013.xml" type="local" title="Definition of Sentences">sentences</link>.
    <ul><li><tex>\forall  x \, \neg  x&lt;x</tex></li>
        <li><tex>\forall  x \forall  y \, (x&lt;y \rightarrow \neg (y&lt;x))</tex></li>
        <li><tex>\forall  x \forall  y \forall  z \, ((x&lt;y \land  y&lt;z) \rightarrow  x&lt;z)</tex></li>
        <li><tex>\forall  x \forall  y \, (( \neg  x=y) \rightarrow (x&lt;y \lor  y&lt;x))</tex></li>
        <li><tex>\forall  x \forall  y \, x&lt;y \rightarrow ( \exists  z \, x&lt;z \land  z&lt;y)</tex></li>
        <li><tex>\forall  x \exists  z \, z&lt;x</tex></li>
        <li><tex>\forall  x \exists  z \, x&lt;z</tex></li></ul></p><p>
    The set of rationals <tex>\mathbb  Q</tex> with the usual ordering is a model of DLO, and DLO is <link href="BMT-d201.xml" type="local" title="-Categoricity"><tex>\aleph _0</tex>-categorical</link>,
    so every countable model is isomorphic to <tex>( \mathbb  Q,&lt;)</tex>. DLO is also a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">complete theory</link> with
    <link href="BMT-s003.xml" type="local" title="Quantifier Elimination">quantifier elimination</link>.
</p></mainmatter> </tree>
<p>Furthermore, if one is willing to accept arbitrary expansions of the language, we can always force a theory to have quantifier elimination. This is done as follows:</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>3</crumb> <crumb>5</crumb></trail> <anchor>2832</anchor>  <taxon>Definition</taxon> <addr>BMT-d026</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d026.tree</source-path> <route>BMT-d026.xml</route> <date><year>2024</year> <month>9</month> <day>26</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Morleyisation</title> </frontmatter> <mainmatter><p> The Morleyisation of an <tex>L</tex>-theory <tex>T</tex> is the theory <tex>T^m</tex> in the language <tex>L^m \supset  L</tex>. The expanded language <tex>L^m</tex> is formed by taking every <tex>L</tex>-formula <tex>\phi (x_1,...,x_n)</tex> and adding an <tex>n</tex>-placed relation symbol <tex>R_ \phi</tex>. To <tex>T</tex> we add the axioms </p><p><tex>\forall  x_1,...,x_n (R_ \phi  (x_1,...,x_n) \leftrightarrow \phi (x_1,...,x_n)) </tex></p><p>Morleyisation preserves many properties such as <link href="BMT-d201.xml" type="local" title="-Categoricity"><tex>\kappa</tex>-categoricity</link>, though the relations <tex>R_ \phi</tex> and the corresponding definable sets may be quite hard to understand. </p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>4</crumb></trail> <anchor>2833</anchor>  <taxon>Section</taxon> <addr>BMT-s004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s004.tree</source-path> <route>BMT-s004.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Back and Forth</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for quantifier Elimination</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>5</crumb></trail> <anchor>2834</anchor>  <taxon>Section</taxon> <addr>BMT-s005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s005.tree</source-path> <route>BMT-s005.xml</route> <date><year>2024</year> <month>3</month> <day>14</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Types</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for types.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>5</crumb> <crumb>1</crumb></trail> <anchor>2835</anchor>  <taxon>Definition</taxon> <addr>BMT-d019</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d019.tree</source-path> <route>BMT-d019.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Definition of a type</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory <tex>T</tex></link>, a <em>partial type</em> of <tex>T</tex> is a <link href="BMT-d022.xml" type="local" title="Satisfiability">finitely satisfiable</link> set of formulas in a fixed tuple of variables <tex>x</tex>.</p><p>A partial type <tex>p(x)</tex> (meaning that the denoted type consists of formulas each in the variables <tex>x</tex>) is <em>complete</em> if for every <tex>\mathcal {L}</tex>-formula in the variables <tex>x</tex>, <tex>\varphi (x) \in  p(x)</tex>, either <tex>\varphi (x) \in  p(x)</tex> or <tex>\neg   \varphi (x) \in  p(x)</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>5</crumb> <crumb>2</crumb></trail> <anchor>2836</anchor>  <taxon>Definition</taxon> <addr>BMT-d020</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d020.tree</source-path> <route>BMT-d020.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Definition of an isolated/principal type</title> </frontmatter> <mainmatter><p>
    Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory <tex>T</tex></link>,
    a partial type of T {p(x)} is <em>principal</em> when there is an <tex>\mathcal {L}</tex>-formula <tex>\varphi (x)</tex> such that
    <tex>\models   \exists  x  \varphi (x)</tex> and for every <tex>\varpsi (x)  \in  p(x)</tex> we have that
    <tex>\models   \forall  x ( \varphi (x)  \rightarrow   \varpsi (x))</tex>.
    In the case that <tex>p(x)</tex> is complete, we must have that <tex>\varphi (x) \in  p(x)</tex>,
    and the first condition is redundant.
</p><p>
    A complete type of T, <tex>p(x)</tex> is <em>isolated</em> if it is principal as a partial type.
    Equivalently, {p(x)} is <em>isolated</em> if <tex>\{ p(x) \}</tex> is open <link href="BMT-d021.xml" type="local" title="The Stone Space S_n(T)">S_n(T)</link>.
    This coincides with the usual topological terminology.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>5</crumb> <crumb>3</crumb></trail> <anchor>2837</anchor>  <taxon>Definition</taxon> <addr>BMT-d021</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d021.tree</source-path> <route>BMT-d021.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>The Stone Space <tex>S_n(T)</tex></title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory <tex>T</tex></link>,
<tex>S_n(T)</tex> denotes a topological space whose underlying set is the set of all complete <em>n-types</em> of <tex>T</tex>.
The topology on <tex>S_n(T)</tex> has a basis of open sets given by all sets of the form <tex>[ \varphi (x)] :=  \{ p(x) \in  S_n(T):
 \varphi (x)  \in  p(x) \}</tex> (for <tex>\varphi (x)</tex> an <tex>\mathcal {L}</tex>-formula).
This space is a Stone Space in the usual sense and the Boolean Algebra associated to it via Stone Duality is
the <tex>n</tex>th Tarski-Lindenbaum Algebra of <tex>T</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>5</crumb> <crumb>4</crumb></trail> <anchor>2838</anchor>  <taxon>Definition</taxon> <addr>BMT-d023</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d023.tree</source-path> <route>BMT-d023.xml</route> <date><year>2024</year> <month>4</month> <day>4</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Finite Satisfiability</title> </frontmatter> <mainmatter><p>
    An <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal  L</tex>-theory</link> <tex>T</tex> is <em>finitely satisfiable</em> when every finite subset of <tex>T</tex> is <link href="BMT-d022.xml" type="local" title="Satisfiability">satisfiable</link>.
</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>6</crumb></trail> <anchor>2839</anchor>  <taxon>Section</taxon> <addr>BMT-s006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s006.tree</source-path> <route>BMT-s006.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> <contributor><link href="francis-westhead.xml" type="local">Francis Westhead</link></contributor></authors> <title>Saturation</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for saturation of models.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>6</crumb> <crumb>1</crumb></trail> <anchor>2840</anchor>  <taxon>Definition</taxon> <addr>BMT-d209</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d209.tree</source-path> <route>BMT-d209.xml</route> <date><year>2024</year> <month>9</month> <day>12</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Saturated Model</title> </frontmatter> <mainmatter><p>
    A <link href="BMT-d002.xml" type="local" title="Structure">structure</link> <tex>M</tex> is <tex>\lambda</tex>-saturated, for a cardinal <tex>\lambda</tex>, when for every <tex>A \subseteq  M</tex> such that <tex>|A|&lt; \lambda</tex>, every <link href="BMT-d019.xml" type="local" title="Definition of a type">type</link> over <tex>A</tex> is realized in <tex>M</tex>. <tex>M</tex> is simply said to be saturated if <tex>M</tex> is <tex>|M|</tex>-saturated.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>6</crumb> <crumb>2</crumb></trail> <anchor>2841</anchor>  <taxon>Definition</taxon> <addr>BMT-d210</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d210.tree</source-path> <route>BMT-d210.xml</route> <date><year>2024</year> <month>9</month> <day>19</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Homogeneous Model</title> </frontmatter> <mainmatter><p>
    A <link href="BMT-d002.xml" type="local" title="Structure">structure</link> <tex>M</tex> is <tex>\lambda</tex>-homogeneous, for a cardinal <tex>\lambda</tex>, 
    when for every cardinal <tex>\eta &lt; \lambda</tex> and sequences <tex>(a_i \in  M|i \in \eta ), \{ b_i \in  M|i \in \eta \}</tex> such that <tex>(M,(a_i)_{i&lt; \eta }) \equiv (M,(b_i)_{i&lt; \eta })</tex>, 
    for each <tex>c \in  M</tex> there is <tex>d \in  M</tex> such that <tex>(M,(a_i)_{i&lt; \eta },c) \equiv (M,(b_i)_{i&lt; \eta },d)</tex>. 

    Here <tex>(M,(a_i)_{i&lt; \eta }),(M,(b_i)_{i&lt; \eta })</tex> refers to <tex>M</tex> with its language expanded by a constant <tex>C_i</tex> for each <tex>i&lt; \eta</tex>, such that <tex>C_i</tex> is interpreted as <tex>a_i</tex>, <tex>b_i</tex> respectively. 
    <tex>(M,(a_i)_{i&lt; \eta },c)</tex> and <tex>(M,(b_i)_{i&lt; \eta },d)</tex> are further expansions, when the language is further expanded by a constant <tex>D</tex> that is interpreted as <tex>c</tex> or <tex>d</tex> respectively.

    Equivalently, <tex>M</tex> is <tex>\lambda</tex>-homogeneous if every partial elementary embedding <tex>\Phi :M \to  M</tex> such that <tex>|dom \Phi |&lt; \lambda</tex> extends to another partial elementary mapping of <tex>M</tex> to itself with a larger domain.

    The first definition follows Chang &amp; Keisler, and the second follows Shelah. The two definitions are equivalent.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>6</crumb> <crumb>3</crumb></trail> <anchor>2842</anchor>  <taxon>Definition</taxon> <addr>BMT-d212</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d212.tree</source-path> <route>BMT-d212.xml</route> <date><year>2024</year> <month>10</month> <day>10</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Strongly Homogeneous Model</title> </frontmatter> <mainmatter><p>
    A model <tex>M</tex> is strongly <tex>\lambda</tex>-homogeneous, if for every partial elementary embedding <tex>\Phi :M \to  M</tex> extends to an automorphism of <tex>M</tex>. 

    Clearly, strongly <tex>\lambda</tex>-homogeneous implies <link href="BMT-d210.xml" type="local" title="Homogeneous Model"><tex>\lambda</tex>-homogeneous</link>. 
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>6</crumb> <crumb>4</crumb></trail> <anchor>2843</anchor>  <taxon>Definition</taxon> <addr>BMT-d211</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d211.tree</source-path> <route>BMT-d211.xml</route> <date><year>2024</year> <month>9</month> <day>26</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Ultrahomogeneous Model</title> </frontmatter> <mainmatter><p>
    A countable <link href="BMT-d002.xml" type="local" title="Structure">structure</link> <tex>M</tex> is ultrahomogeneous, per Hodges, when every <link href="BMT-d005.xml" type="local" title="Isomorphism">isomorphism</link> between two finite <link href="BMT-d006.xml" type="local" title="Substructure">substructures</link> of <tex>M</tex> extends to a global <link href="BMT-d005.xml" type="local" title="Isomorphism">automorphism</link>.

    Also, ultrahomogeneous is strictly stronger than strongly <tex>\omega</tex>-homogeneous. For a strongly <tex>\omega</tex>-homogeneous structure that is not ultrahomogeneous, consider the disjoint union of a countable <link href="Fra-e001.xml" type="local" title="The Random Graph">random graph</link> and a countable triangle-free random graph. This structure is <tex>\omega</tex>-homogenous but not ultrahomogeneous.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>6</crumb> <crumb>5</crumb></trail> <anchor>2844</anchor>  <taxon>Definition</taxon> <addr>BMT-d213</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d213.tree</source-path> <route>BMT-d213.xml</route> <date><year>2024</year> <month>10</month> <day>10</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Strongly Saturated Model</title> </frontmatter> <mainmatter>{



}<p>
    A structure <tex>M</tex> is strongly <tex>\lambda</tex>-saturated if it is <link href="BMT-d209.xml" type="local" title="Saturated Model"><tex>\lambda</tex>-saturated</link> and <link href="BMT-d212.xml" type="local" title="Strongly Homogeneous Model">strongly <tex>\lambda</tex>-homogeneous</link>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>6</crumb> <crumb>6</crumb></trail> <anchor>2845</anchor>  <taxon>Definition</taxon> <addr>BMT-d214</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d214.tree</source-path> <route>BMT-d214.xml</route> <date><year>2024</year> <month>10</month> <day>17</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Universal Model</title> </frontmatter> <mainmatter><p>
    A model <tex>M</tex> is <tex>\lambda</tex>-Universal, per Chang &amp; Keisler, when for every model <tex>N</tex> such that <tex>|N|&lt; \lambda</tex> that is elementarily equivalent to <tex>M</tex> can <link href="BMT-d030.xml" type="local" title="Elementary Embedding of L-structures">elementarily embeds</link> into <tex>M</tex>. 
</p><p>
    A model <tex>M</tex> is <tex>\lambda</tex>-Universal, per Shelah, when for every model <tex>N</tex> that is elementarily equivalent to <tex>M</tex>, and a set <tex>A \subseteq  N</tex> such that <tex>|A| \leq \lambda</tex>, there is a <link href="BMT-d030.xml" type="local" title="Elementary Embedding of L-structures">partial elementary embedding</link> <tex>f:M \to  N</tex> such that <tex>dom(f)=A</tex>.
</p><p><tex>\lambda</tex>-universality per Shelah implies <tex>\lambda ^+</tex>-universality per Chang &amp; Keisler.
    By the Lowenheim-Skolem Theorem, if the language <tex>|L| \leq   \lambda</tex>, then <tex>\lambda</tex>-universality per Shelah and <tex>\lambda ^+</tex>-universality per Chang &amp; Keisler are equivalent.
</p><p>
    Per Shelah, a model <tex>M</tex> is <tex>&lt; \lambda</tex>-universal if it is <tex>\mu</tex>-universal for all <tex>\mu &lt; \lambda</tex>, and a model <tex>M</tex> simply said to be universal if it is <tex>|M|</tex>-universal. 
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>6</crumb> <crumb>7</crumb></trail> <anchor>2846</anchor>  <taxon>Theorem</taxon> <addr>BMT-t081</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t081.tree</source-path> <route>BMT-t081.xml</route> <date><year>2024</year> <month>4</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>A model is homogeneous if and only if it is strongly homogeneous</title> </frontmatter> <mainmatter><p>A back-and-forth argument establishes that if <tex>\mathcal {M}</tex> has infinite cardinality, then <tex>\mathcal {M}</tex> is homogeneous
if and only if <tex>\mathcal {M}</tex> is strongly homogeneous.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>6</crumb> <crumb>8</crumb></trail> <anchor>2847</anchor>  <taxon>Theorem</taxon> <addr>BMT-t082</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t082.tree</source-path> <route>BMT-t082.xml</route> <date><year>2024</year> <month>4</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Saturated elementarily equivalent models of the same cardinality are isomorphic.</title> </frontmatter> <mainmatter><p>
    If <tex>\mathcal {M}</tex> and <tex>\mathcal {N}</tex> are each saturated, <tex>| \mathcal {M}|=| \mathcal {N}|</tex> and <tex>Th( \mathcal {M})=Th( \mathcal {N})</tex>
, then <tex>\mathcal {M}</tex> and <tex>\mathcal {N}</tex> are isomorphic.
</p><p>
    Moreover, every partial elementary embedding <tex>f:M \to  N</tex> extends to an isomorphism. 
    Therefore, for every saturated model <tex>M</tex>, a subset <tex>A \subseteq  M</tex>, and two elements <tex>x,y \in  M</tex> of the same <link href="BMT-d019.xml" type="local" title="Definition of a type">type</link> over <tex>A</tex>, there is an automorphism of <tex>M</tex> fixing <tex>A</tex> pointwise and takes <tex>x</tex> to <tex>y</tex>.
    This is sometimes known as the Model-Theoretic Galois Theory.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>6</crumb> <crumb>9</crumb></trail> <anchor>2848</anchor>  <taxon>Theorem</taxon> <addr>BMT-t083</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t083.tree</source-path> <route>BMT-t083.xml</route> <date><year>2024</year> <month>4</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title><tex>\kappa</tex>-saturated models are <tex>\kappa ^+</tex>-universal</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {M}</tex> is <tex>\kappa</tex>-saturated, then <tex>\mathcal {M}</tex> is <tex>\kappa ^+</tex>-universal.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>6</crumb> <crumb>10</crumb></trail> <anchor>2849</anchor>  <taxon>Theorem</taxon> <addr>BMT-t084</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t084.tree</source-path> <route>BMT-t084.xml</route> <date><year>2024</year> <month>10</month> <day>17</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Saturation is Equivalent to Universality and Homogeneity</title> </frontmatter> <mainmatter><p>
    The following are equivalent, given a model <tex>M</tex> and a cardinal <tex>\lambda</tex>.
</p><p>
    1: <tex>M</tex> is <tex>\lambda</tex>-saturated.
</p><p>
    2: <tex>M</tex> is <tex>\lambda</tex>-universal and <tex>\lambda</tex>-homogeneous.
</p><p>
    3: <tex>M</tex> is <tex>&lt; \aleph _0</tex>-universal and <tex>\lambda</tex>-homogeneous.
</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>7</crumb></trail> <anchor>2850</anchor>  <taxon>Section</taxon> <addr>BMT-s007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s007.tree</source-path> <route>BMT-s007.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> <contributor><link href="gpeters.xml" type="local">Garrett Peters</link></contributor></authors> <title>Ultraproducts</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for the use of ultraproducts in model theory.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>7</crumb> <crumb>1</crumb></trail> <anchor>2851</anchor>  <taxon>Definition</taxon> <addr>BMT-d071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d071.tree</source-path> <route>BMT-d071.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Definition of a Filter</title> </frontmatter> <mainmatter><p>Let <tex>I</tex> be any set. Then a filter <tex>\mathcal {F}</tex> on the power set <tex>\mathcal {P}(I)</tex> is a collection of subsets of <tex>I</tex> with the following properties:</p><p>1: <tex>I \in \mathcal {F}</tex>.</p><p>2: If <tex>A \in   \mathcal {F}</tex> and <tex>A \subseteq  B</tex>, then <tex>B \in   \mathcal {F}</tex>.</p><p>3: If <tex>A,B  \in   \mathcal {F}</tex>, then we have <tex>A \cap  B \in   \mathcal {F}</tex>.</p><p>Furthermore, a filter is proper if <tex>\emptyset \notin \mathcal {F}</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>7</crumb> <crumb>2</crumb></trail> <anchor>2852</anchor>  <taxon>Definition</taxon> <addr>BMT-d072</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d072.tree</source-path> <route>BMT-d072.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Definition of an Ultrafilter</title> </frontmatter> <mainmatter><p>Let <tex>I</tex> be any set. Then an ultrafilter <tex>\mathcal {U}</tex> on <tex>\mathcal {P}(I)</tex> is a proper <link href="BMT-d071.xml" type="local" title="Definition of a Filter">filter</link> on <tex>I</tex> with the additional property:</p><p>For every <tex>A \subseteq  I</tex>, either <tex>A \in \mathcal {U}</tex> or <tex>I \backslash  A \in \mathcal {U}</tex>.</p><p>Every proper filter can be extended into an ultrafilter.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>7</crumb> <crumb>3</crumb></trail> <anchor>2853</anchor>  <taxon>Example</taxon> <addr>BMT-e071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e071.tree</source-path> <route>BMT-e071.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Principal Ultrafilters</title> </frontmatter> <mainmatter><p>Fix any <tex>i \in  I</tex>. Then <tex>\mathcal {U}_i :=  \{ A \subseteq  I: i \in  A \}</tex> is an <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link>. This is referred to as the principal ultrafilter concentrated at <tex>i</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>7</crumb> <crumb>4</crumb></trail> <anchor>2854</anchor>  <taxon>Example</taxon> <addr>BMT-e072</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e072.tree</source-path> <route>BMT-e072.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>The Frchet Filter</title> </frontmatter> <mainmatter><p>For any set <tex>I</tex> of infinite cardinality, the family of cofinite sets forms a proper <link href="BMT-d071.xml" type="local" title="Definition of a Filter">filter</link>. This filter is referred to as the Frchet filter.</p><p>When extending the Frchet filter to an <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link>, the result is not <link href="BMT-e071.xml" type="local" title="Principal Ultrafilters">principal</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>7</crumb> <crumb>5</crumb></trail> <anchor>2855</anchor>  <taxon>Definition</taxon> <addr>BMT-d073</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d073.tree</source-path> <route>BMT-d073.xml</route> <date><year>2024</year> <month>3</month> <day>7</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Ultraproduct</title> </frontmatter> <mainmatter><p>Fix an index set <tex>I</tex> and a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>L</tex>. Let <tex>\{ \mathcal {A}_i: i \in  I \}</tex> be a family of <tex>L</tex>-<link href="BMT-d002.xml" type="local" title="Structure">structures</link>, and let <tex>\mathcal {U}</tex> be any <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link> on <tex>\mathcal {P}(I)</tex>. Then the ultraproduct is the <tex>L</tex>-structure <tex>\mathcal {A}_* :=  \prod \limits _{i \in  I} A_i / \mathcal {U}</tex>. </p><p>In <tex>\mathcal {A}_*</tex>, the elements of the universe of <tex>\mathcal {A}_*</tex> are functions <tex>\underline {a}</tex> with domain <tex>I</tex> and <tex>\underline {a}(i) \in  A_i</tex> under the equivalence class <tex>\sim _{ \mathcal {U}}</tex>, where <tex display="block">\underline {a} \sim _{ \mathcal {U}} \underline {b}  \text { if and only if } \{ i \in  I:  \underline {a}(i)= \underline {b}(i) \}   \in   \mathcal {U}.</tex></p><p>The constant symbols are interpreted by <tex>c^{ \mathcal {A}_*} :=  \prod \limits _{i \in  I} c^{ \mathcal {A}_i} / \mathcal {U}</tex>. </p><p>The function symbols are interpreted by <tex>f^{ \mathcal {A}_i}( \underline {a}_1, \dots ,  \underline {a}_n) :=  \prod \limits _{i \in  I} f^{ \mathcal {A}_i}( \underline {a}_1(i), \dots , \underline {a}_n(i)) /  \mathcal {U} </tex>. </p><p>The relation symbols are interpreted by <tex>\mathcal {A}_* \models  R^{ \mathcal {A}_*}( \underline {a}_1, \dots ,  \underline {a}_n)</tex> if and only if <tex>\{ i \in  I:  \mathcal {A}_i \models  R^{ \mathcal {A}_i}( \underline {a}_1(i), \dots ,  \underline {a}_n(i)) \} \in   \mathcal {U}</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>7</crumb> <crumb>6</crumb></trail> <anchor>2856</anchor>  <taxon>Theorem</taxon> <addr>BMT-t071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t071.tree</source-path> <route>BMT-t071.xml</route> <date><year>2024</year> <month>3</month> <day>7</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title> o's Theorem</title> </frontmatter> <mainmatter><p>Let <tex>\mathcal {A}_* =  \prod \limits _{i \in  I}  \mathcal {A}_i /  \mathcal {U}</tex> be an <link href="BMT-d073.xml" type="local" title="Ultraproduct">ultraproduct</link>. Then for any <tex>L</tex>-formula <tex>\phi (x_1, \dots ,x_n)</tex>, we have <tex display="block">\mathcal {A}_* \models   \phi ( \underline {a}_1, \dots , \underline {a}_n)  \text { if and only if }  \{ i \in  I: A_i \models \phi ( \underline {a}_1(i), \dots ,  \underline {a}_n(i)) \} \in \mathcal {U}.</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>7</crumb> <crumb>7</crumb></trail> <anchor>2857</anchor>  <taxon>Theorem</taxon> <addr>BMT-t072</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t072.tree</source-path> <route>BMT-t072.xml</route> <date><year>2024</year> <month>3</month> <day>14</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Compactness Theorem</title> </frontmatter> <mainmatter><p>Let <tex>L</tex> be any language, and <tex>T</tex> be any <tex>L</tex>-theory. Then <tex>T</tex> is satisfiable if and only if every finite subset <tex>T_0 \subseteq  T</tex> is satisfiable.</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>8</crumb></trail> <anchor>2858</anchor>  <taxon>Section</taxon> <addr>BMT-s008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s008.tree</source-path> <route>BMT-s008.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Model Completeness</title> </frontmatter> <mainmatter><p>In many important examples of theories, typically originating in the field of algebra, all embeddings are elementary embeddings. We define this as follows</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>8</crumb> <crumb>1</crumb></trail> <anchor>2859</anchor>  <taxon>Definition</taxon> <addr>BMT-d016</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d016.tree</source-path> <route>BMT-d016.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Model Complete Theory</title> </frontmatter> <mainmatter><p>A Theory <tex>T</tex> in a first order language <tex>L</tex> is <em>Model-Complete</em> if  every <link href="BMT-d004.xml" type="local" title="Embedding of L-structures"><tex>L</tex>-embedding</link> between models of <tex>T</tex> is an elementary embedding. </p></mainmatter> </tree><p>Here we provide a simple test for for determining if something is model complete:</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>8</crumb> <crumb>2</crumb></trail> <anchor>2860</anchor>  <taxon>Lemma</taxon> <addr>BMT-l001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-l001.tree</source-path> <route>BMT-l001.xml</route> <date><year>2024</year> <month>9</month> <day>19</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Robinson's Test</title> </frontmatter> <mainmatter><p> Let <tex>T</tex> be a theory. Then the following are equivalent:</p><ol><li><tex>T</tex> is model complete.</li>
    <li>For all models <tex>M \subseteq  M'</tex> of <tex>T</tex> and all existential setnences <tex>\phi</tex> from <tex>L(M)</tex>, then <tex>M' \vDash   \phi   \implies  M  \vDash   \phi</tex></li>
    <li>Each formula is, modulo <tex>T</tex>, equivalent to a universal formula. </li></ol><p>Proof: </p><ul><li><tex>1 \implies  2</tex>, Given that the definition of <link href="BMT-d016.xml" type="local" title="Model Complete Theory">model complete</link> implies that every embedding of models is an <link href="BMT-d030.xml" type="local" title="Elementary Embedding of L-structures">elementary emedding</link>,then condition 2 above is actually true for all sentences, in particular existential sentences. </li>
    <li><tex>2 \implies  3</tex>, Given an existential formula <tex>\phi</tex>,  </li>
    <li><tex>3 \implies  1</tex></li></ul></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>9</crumb></trail> <anchor>2861</anchor>  <taxon>Section</taxon> <addr>BMT-s009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s009.tree</source-path> <route>BMT-s009.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>Categoricity</title> </frontmatter> <mainmatter><p>In this section, we give the basic definitions for <tex>\kappa</tex>-categoricity. We then establish some classical characterisations of <tex>\aleph _0</tex>-categoricity.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>9</crumb> <crumb>1</crumb></trail> <anchor>2862</anchor>  <taxon>Definition</taxon> <addr>BMT-d201</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d201.tree</source-path> <route>BMT-d201.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title><tex>\kappa</tex>-categoricity</title> </frontmatter> <mainmatter><p>
    Given a cardinal <tex>\kappa</tex> and a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, an <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory</link> is <em><tex>\kappa</tex>-categorical</em> if whenever <tex>\mathcal {M}</tex> and <tex>\mathcal {N}</tex> are <tex>\mathcal {L}</tex>-structures with <tex>| \mathcal {M}|=| \mathcal {M}|= \kappa</tex>, then <tex>\mathcal {M}  \cong   \mathcal {N}</tex>. 
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>9</crumb> <crumb>2</crumb></trail> <anchor>2863</anchor>  <taxon>Definition</taxon> <addr>BMT-d202</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d202.tree</source-path> <route>BMT-d202.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>Tarski-Lindenbaum Algebra</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and an <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory</link>, <tex>T</tex>, the <em><tex>n</tex>'th Tarski-Lindenbaum algebra of <tex>T</tex></em> is the set of <link href="BMT-d009.xml" type="local" title="{L}-Formula"><tex>\mathcal {L}</tex>-formulas</link> quotiented by the relation of <link href="BMT-d018.xml" type="local" title="Definition of T-equivalence of formulas"><tex>T</tex>-equivalence</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>9</crumb> <crumb>3</crumb></trail> <anchor>2864</anchor>  <taxon>Theorem</taxon> <addr>BMT-t003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t003.tree</source-path> <route>BMT-t003.xml</route> <date><year>2024</year> <month>4</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>(Ryll-Nardjewski) Characterisations of <tex>\omega</tex>-categoricity</title> </frontmatter> <mainmatter><p>For <tex>\aleph _0</tex>-categoricity, there are a number of useful characterisations. The following are due to Ryll-Nardjewski.</p><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and an <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory</link> <tex>T</tex>, the following are equivalent:</p><p>1 <tex>T</tex> is <tex>\aleph _0</tex>-categorical.</p><p>For every <tex>n \in   \omega</tex>, there are finitely many <link href="BMT-d009.xml" type="local" title="{L}-Formula"><tex>\mathcal {L}</tex>-formulas</link> in <tex>n</tex>-variables up to <link href="BMT-d018.xml" type="local" title="Definition of T-equivalence of formulas"><tex>T</tex>-equivalence</link>.</p><p>For every <tex>n \in   \omega</tex>, the <link href="BMT-d202.xml" type="local" title="Tarski-Lindenbaum Algebra"><tex>n</tex>'th Tarski-Lindenbaum algebra of <tex>T</tex></link> is finite. 
Every <link href="BMT-d019.xml" type="local" title="Definition of a type">type</link> over <tex>T</tex> is <link href="BMT-d020.xml" type="local" title="Definition of an isolated/principal type">isolated</link>. </p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>10</crumb></trail> <anchor>2865</anchor>  <taxon>Section</taxon> <addr>BMT-s010</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s010.tree</source-path> <route>BMT-s010.xml</route> <date><year>2024</year> <month>4</month> <day>25</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Examples</title> </frontmatter> <mainmatter><p>
    Here, we give the basic and canonical examples of Model Theory, summarizing their properties.
</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>10</crumb> <crumb>1</crumb></trail> <anchor>2866</anchor>  <taxon>Example</taxon> <addr>BMT-e030</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e030.tree</source-path> <route>BMT-e030.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>DLO</title> </frontmatter> <mainmatter><p>
    The <em>dense linear order without endpoints</em> (DLO) is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">theory</link> in the <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal  L= \{ &lt; \}</tex>
    consisting of the following <link href="BMT-d013.xml" type="local" title="Definition of Sentences">sentences</link>.
    <ul><li><tex>\forall  x \, \neg  x&lt;x</tex></li>
        <li><tex>\forall  x \forall  y \, (x&lt;y \rightarrow \neg (y&lt;x))</tex></li>
        <li><tex>\forall  x \forall  y \forall  z \, ((x&lt;y \land  y&lt;z) \rightarrow  x&lt;z)</tex></li>
        <li><tex>\forall  x \forall  y \, (( \neg  x=y) \rightarrow (x&lt;y \lor  y&lt;x))</tex></li>
        <li><tex>\forall  x \forall  y \, x&lt;y \rightarrow ( \exists  z \, x&lt;z \land  z&lt;y)</tex></li>
        <li><tex>\forall  x \exists  z \, z&lt;x</tex></li>
        <li><tex>\forall  x \exists  z \, x&lt;z</tex></li></ul></p><p>
    The set of rationals <tex>\mathbb  Q</tex> with the usual ordering is a model of DLO, and DLO is <link href="BMT-d201.xml" type="local" title="-Categoricity"><tex>\aleph _0</tex>-categorical</link>,
    so every countable model is isomorphic to <tex>( \mathbb  Q,&lt;)</tex>. DLO is also a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">complete theory</link> with
    <link href="BMT-s003.xml" type="local" title="Quantifier Elimination">quantifier elimination</link>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>10</crumb> <crumb>2</crumb></trail> <anchor>2867</anchor>  <taxon>Example</taxon> <addr>BMT-e031</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e031.tree</source-path> <route>BMT-e031.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Algebraically Closed Fields</title> </frontmatter> <mainmatter><p>
    The theory of <em>algebraically closed fields</em> (ACF) is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">theory</link> in the <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal  L= \{ 0,1,+, \cdot \}</tex>
    consisting of the following <link href="BMT-d013.xml" type="local" title="Definition of Sentences">sentences</link>.
    <ul><li><tex>\forall  x \forall  y \forall  z \, (x+y)+z=x+(y+z)</tex>.
        </li>
        <li><tex>\forall  x \, x+0=x \land0 +x=x</tex>.
        </li>
        <li><tex>\forall  x \exists  y \, x+y=0 \land  y+x=0</tex>.
        </li>
        <li><tex>\forall  x \forall  y \, x+y=y+x</tex>.
        </li>
        <li><tex>\forall  x \forall  y \forall  z \, (x \cdot  y) \cdot  z=x \cdot  (y+ \cdot  z)</tex>.
        </li>
        <li><tex>\forall  x \, x \cdot1 =x \land1 \cdot  x=x</tex>.
        </li>
        <li><tex>\forall  x \exists  y \, x \cdot  y=1 \land  y \cdot  x=1</tex>.
        </li>
        <li><tex>\forall  x \forall  y \, x+ \cdot  y=y \cdot  x</tex>.
        </li>
        <li><tex>\forall  x \forall  y \forall  z \, x \cdot (y+z)=(x \cdot  y)+(x \cdot  z)</tex>.
        </li>
        <li>
            For each <tex>n \in \mathbb  N</tex>, a sentence <tex>\forall  y_1 \cdots \forall  y_n \exists  x \, (y_1 \cdot  x)+ \cdots +(y_n \cdot  x)=0</tex>.
        </li></ul></p><p>
    The theory of algebraically closed fields of characteristic <tex>p</tex> (<tex>\text {ACF}_p</tex>) is ACF together with the sentence
    <tex>1+ \cdots +1=0</tex>, where <tex>1</tex> is being added <tex>p</tex> times. <tex>\text {ACF}_p</tex> is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">complete theory</link> having
    <link href="BMT-s003.xml" type="local" title="Quantifier Elimination">quantifier elimination</link>.
</p><p>
    The theory of algebraically closed fields of characteristic <tex>0</tex> (<tex>\text {ACF}_0</tex>) is ACF together with the collection of sentences
    of the form <tex>\neg (1+ \cdots +1=0)</tex>, for any number of <tex>1</tex>s being added together. <tex>\text {ACF}_0</tex> is also a
    <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">complete theory</link> having <link href="BMT-s003.xml" type="local" title="Quantifier Elimination">quantifier elimination</link>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>10</crumb> <crumb>3</crumb></trail> <anchor>2868</anchor>  <taxon>Example</taxon> <addr>BMT-e032</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e032.tree</source-path> <route>BMT-e032.xml</route> <date><year>2024</year> <month>9</month> <day>12</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Vector Spaces</title> </frontmatter> <mainmatter><p>
    The theory of vector spaces over a field <tex>F</tex> is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">theory</link> in the <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal  L= \{ 0,+,( \times _f)_{f \in  F} \}</tex>
    consisting of the following <link href="BMT-d013.xml" type="local" title="Definition of Sentences">sentences</link>.
    <ul><li><tex>\forall  x \forall  y \forall  z \, (x+y)+z=x+(y+z)</tex>.
        </li>
        <li><tex>\forall  x \, x+0=x \land0 +x=x</tex>.
        </li>
        <li><tex>\forall  x \exists  y \, x+y=0 \land  y+x=0</tex>.
        </li>
        <li><tex>\forall  x \forall  y \, x+y=y+x</tex>.
        </li>
        <li>
            For each <tex>f,g \in  F</tex>, the sentence <tex>\forall  x \, \times _f( \times _g(x)) =  \times _{fg}(x)</tex>, where <tex>fg</tex> is the product of <tex>f</tex> and <tex>g</tex> in <tex>F</tex>.
        </li>
        <li><tex>\forall  x \, \times _1(x) = x</tex> where <tex>1</tex> is the multiplicative identity in <tex>F</tex>.
        </li>
        <li>
            For each <tex>f \in  F</tex>, the sentence <tex>\forall  x \forall  y \, \times _f(x+y) =  \times _f(x)+ \times _f(y)</tex>.
        </li>
        <li>
            For each <tex>f,g \in  F</tex>, the sentence <tex>\forall  x \, \times _(f+g)(x) =  \times _f(x)+ \times _g(x)</tex>, where <tex>f+g</tex> is the sum of <tex>f</tex> and <tex>g</tex> in <tex>F</tex>.
        </li></ul></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>10</crumb> <crumb>4</crumb></trail> <anchor>2869</anchor>  <taxon>Example</taxon> <addr>BMT-e033</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e033.tree</source-path> <route>BMT-e033.xml</route> <date><year>2024</year> <month>10</month> <day>10</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Equivalence Relation</title> </frontmatter> <mainmatter><p>
    The theory of an equivalence relation is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">theory</link> in the <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal  L= \{ E \}</tex>,
    where <tex>E</tex> is a binary relation, consisting of the following <link href="BMT-d013.xml" type="local" title="Definition of Sentences">sentences</link>.
    <ul><li><tex>\forall  x \, xEx</tex>.
        </li>
        <li><tex>\forall  x \forall  y \, xEy \rightarrow  yEx</tex>.
        </li>
        <li><tex>\forall  x \forall  y \forall  z \, (xEy \land  yEz) \rightarrow  xEz</tex>.
        </li></ul></p><p>
    Being uncomplicated, this theory is usually shown as an initial example (or rather, counterexample) of various properties.
    It is straightforward to add more restrictions, such as stating that there are only <tex>n</tex> equivalence classes:
    <ul><li><tex>\exists  x_1 \cdots \exists  x_n \forall  y \, \bigvee _{i=1}^nx_iEy</tex>.
        </li></ul>
    Or, that each equivalence class has at most <tex>k</tex> elements:
    <ul><li><tex>\forall  x \exists  y_1 \cdots \exists  y_k \forall  z \, (x=z) \rightarrow \bigvee _{i=1}^ny_iEz</tex>.
        </li></ul>
    Or, that each equivalence class has infinitely many elements:
    <ul><li>
            For each <tex>k</tex>, the sentence <tex>\forall  x_1 \cdots \forall  x_k \exists  y \, \bigwedge _{i=1}^n \neg (x_iEy)</tex>.
        </li></ul></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>60</crumb> <crumb>10</crumb> <crumb>5</crumb></trail> <anchor>2870</anchor>  <taxon>Example</taxon> <addr>BMT-e034</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e034.tree</source-path> <route>BMT-e034.xml</route> <date><year>2024</year> <month>10</month> <day>10</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Graphs (Rado Graph)</title> </frontmatter> <mainmatter><p>
    The theory of a graph is a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">theory</link> in the <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal  L= \{ R \}</tex>, where <tex>R</tex> is a binary relation.
    Depending on the author, the theory may only demand symmetry, <tex>\forall  x \forall  y \, xRy \rightarrow  yRx</tex>,
    or additionally include irreflexivity: <tex>\forall  x \, \neg  xRx</tex>.
</p><p>
    The theory of the <em>Rado graph</em> (also called the random graph) is an extension of the theory of the graph by the extension axiom schema:
    <ul><li>
            For each <tex>n</tex> and <tex>m</tex>, the sentence
            <tex>\forall  x_1 \cdots \forall  x_n \forall  y_1 \cdots \forall  y_m \exists  z \, \bigwedge _{i=1}^nzRx_i \land \bigwedge _{j=1}^m \neg  zRy_j</tex>.
        </li></ul>
    This ``single'' schema is enough to make the theory <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory">complete</link>,
    and in fact the theory of the Rado graph is <link href="BMT-d201.xml" type="local" title="-Categoricity"><tex>\aleph _0</tex>-categorical</link>.
</p></mainmatter> </tree></mainmatter> </tree>
</mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb></trail> <anchor>2871</anchor>  <taxon>Part</taxon> <addr>Fra-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-p001.tree</source-path> <route>Fra-p001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse Classes and Variants</title> </frontmatter> <mainmatter><p>We present Fraisse Classes, Smooth classes, and related results and variants.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>1</crumb></trail> <anchor>2872</anchor>  <taxon>Section</taxon> <addr>Fra-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s001.tree</source-path> <route>Fra-s001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse Classes</title> </frontmatter> <mainmatter><p>We define Fraisse constructions and their properties. Most of the concepts can be referred to in <link href="Ref-0001.xml" type="local" title="Model Theory by Wilfred Hodges">Wilfred Hodges' Model Theory</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>1</crumb> <crumb>1</crumb></trail> <anchor>2873</anchor>  <taxon>Definition</taxon> <addr>Fra-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d001.tree</source-path> <route>Fra-d001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Class of Structures</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, a class <tex>K</tex> is defined to be a set of <tex>\mathcal {L}</tex>-structures</p><p>Often, we want there to be a relation <tex>\leq</tex> acting on the structures in <tex>K</tex>, and when we do, we write the class and relation as a pair <tex>(K,  \leq )</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>1</crumb> <crumb>2</crumb></trail> <anchor>2874</anchor>  <taxon>Definition</taxon> <addr>Fra-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d002.tree</source-path> <route>Fra-d002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Age</title> </frontmatter> <mainmatter><p>Given a structure <tex>A</tex> in a language <tex>\mathcal {L}</tex>, the <em>Age</em> (pronounced ah-zh) of <tex>A</tex> is <tex display="block">\{ B \subseteq  A: B  \text { is finitely generated } \}</tex></p><p>The age of a structure is itself a class, often under the relation of substructure</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>1</crumb> <crumb>3</crumb></trail> <anchor>2875</anchor>  <taxon>Definition</taxon> <addr>Fra-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d003.tree</source-path> <route>Fra-d003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Amalgamation Property (AP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex> and <tex>h_2(f(A)) = h_1(g(A))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>1</crumb> <crumb>4</crumb></trail> <anchor>2876</anchor>  <taxon>Definition</taxon> <addr>Fra-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d004.tree</source-path> <route>Fra-d004.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Joint Embedding Property (JEP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B  \in  K</tex>, there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex></p><p><link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">Amalgamation Property</link> does NOT necessarily imply JEP, unless the empty set <tex>\emptyset</tex> is in <tex>K</tex> and for all <tex>A \in  K</tex>, we have that <tex>\emptyset   \leq  A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>1</crumb> <crumb>5</crumb></trail> <anchor>2877</anchor>  <taxon>Definition</taxon> <addr>Fra-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d005.tree</source-path> <route>Fra-d005.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Hereditary Property (HP)</title> </frontmatter> <mainmatter><p>A class <tex>(K, \leq )</tex> has the hereditary property if for every <tex>A \in  K</tex>, and any <tex>B \subseteq  A</tex> finitely generated, then there is some <tex>C \in  K</tex> such that <tex>C \cong  B</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>1</crumb> <crumb>6</crumb></trail> <anchor>2878</anchor>  <taxon>Theorem</taxon> <addr>Fra-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t001.tree</source-path> <route>Fra-t001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \subset )</tex> a class of finitely generated structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link>, the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, and the <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">hereditary property</link>, 
Then there is a unique, countable structure <tex>\mathcal {M}</tex> whose <link href="Fra-d002.xml" type="local" title="Age">age</link> is <tex>K</tex> with the property that any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \subseteq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>The structure <tex>\mathcal {M}</tex> is the <em>Fraisse limit</em> of <tex>K</tex>.</p><p>We call a class <tex>(K, \subseteq )</tex> satisfying AP, HP, and JEP a Fraisse class</p><p>When a structure has the above isomorphism extension property, we say it is <em>ultrahomogeneous</em> (or <em>homogeneous</em>). 
The converse of Fraisse's Theorem is also true in the sense that if we have a structure which is ultrahomogeneous with respect to its age, then its age is a Fraisse class.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>1</crumb> <crumb>7</crumb></trail> <anchor>2879</anchor>  <taxon>Theorem</taxon> <addr>Fra-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t002.tree</source-path> <route>Fra-t002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Properties of a Fraisse Limit</title> </frontmatter> <mainmatter><p>If <tex>M</tex> is the <link href="Fra-t001.xml" type="local" title="Fraisse's Theorem">Fraisse Limit</link> of a class <tex>(K,  \leq )</tex>, then <tex>Th(M)</tex> has quantifier elimination and is <tex>\omega</tex>-categorical</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>1</crumb> <crumb>8</crumb></trail> <anchor>2880</anchor>  <taxon>Example</taxon> <addr>Fra-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e001.tree</source-path> <route>Fra-e001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>The Random Graph</title> </frontmatter> <mainmatter><p>Rado's famous random graph is indeed the Fraisse Limit of the class of finite graphs in the language <tex>\mathcal {L} =  \{ E \}</tex> where <tex>E</tex> is a binary relation representing &quot;there is an edge&quot; between two points.</p><p>More precisely, a graph is an <tex>\mathcal {L}-</tex>structure for which <tex>E</tex> is anti-reflexive and symmetric.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>1</crumb> <crumb>9</crumb></trail> <anchor>2881</anchor>  <taxon>Example</taxon> <addr>Fra-e002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e002.tree</source-path> <route>Fra-e002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>( \mathbb {Q},  \leq )</tex></title> </frontmatter> <mainmatter><p>The Dense Linear Order <tex>( \mathbb {Q},  \leq )</tex> is the Fraisse Limit of the class of all finite linear orders</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>2</crumb></trail> <anchor>2882</anchor>  <taxon>Section</taxon> <addr>Fra-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s002.tree</source-path> <route>Fra-s002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Other Properties of Classes</title> </frontmatter> <mainmatter><p>We define other common properties and variants of the set up shown in the <link href="Fra-s001.xml" type="local" title="Fraisse Classes">Fraisse section</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>2</crumb> <crumb>1</crumb></trail> <anchor>2883</anchor>  <taxon>Definition</taxon> <addr>Fra-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d006.tree</source-path> <route>Fra-d006.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Disjoint Amalgamation Property (dAP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Disjoint Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex> such that <tex>B \cap  C =A</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex>, <tex>h_2(f(A)) = h_1(g(A))</tex>, and <tex>h_2(C)  \cap  h_1(B) = h_1(A)</tex></p><p>An example of a class which has the dAP is the <link href="Fra-e001.xml" type="local" title="The Random Graph">Fraisse class of finite graphs</link></p><p>An example of a smooth class which does not have the dAP is <link href="Smc-e001.xml" type="local" title="Initial Segments">The class of initial segments</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>2</crumb> <crumb>2</crumb></trail> <anchor>2884</anchor>  <taxon>Definition</taxon> <addr>Fra-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Ramsey stuff/Fra-d007.tree</source-path> <route>Fra-d007.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ramsey Property on Substructures (RPS)</title> </frontmatter> <mainmatter><p>For structures <tex>A,B</tex>, let <tex>\binom {B}{A} =  \{ A_0: A_0 \leq  B &amp; ; A_0 \cong  B \}</tex></p><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the Ramsey property on substructures if for every <tex>A \leq  B  \in  K</tex>, there is some <tex>C \in  K</tex> with <tex>B \leq  C</tex>
such that for every <tex>k</tex>-coloring <tex>c:  \binom {C}{A} \rightarrow  k</tex>, there is some <tex>B'  \in   \binom {C}{B}</tex> with <tex display="block">c|_{ \binom {B'}{A}}</tex> constant.</p><p>Ramsey classes are highly related to descriptive set theory, in particular, extremely amenable sets.</p><p>Take care not to mix up RPS and <link href="Fra-d008.xml" type="local" title="Ramsey Property on Embeddings (RPE)">RPE</link></p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>3</crumb></trail> <anchor>2885</anchor>  <taxon>Section</taxon> <addr>Smc-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-s001.tree</source-path> <route>Smc-s001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes</title> </frontmatter> <mainmatter><p>We define Smooth class constructions and their properties. Sources for this section are the papers <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic Structures</link> and <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Stable generic structures</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>3</crumb> <crumb>1</crumb></trail> <anchor>2886</anchor>  <taxon>Definition</taxon> <addr>Smc-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-d001.tree</source-path> <route>Smc-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Class</title> </frontmatter> <mainmatter><p>We assume the language <tex>\mathcal {L}</tex> is countable and only relational.</p><p>A class <tex>(K, \leq )</tex> of finite <tex>\mathcal {L}</tex>-structures (closed under isomorphism) is called <em>a smooth class</em> if <tex>\leq</tex> is transitive, <tex>A \leq  B  \Rightarrow  A \subsetq  B</tex>, and for each <tex>A \in  K</tex>, there is a set of universal formulas <tex>\Phi _A</tex> such that:
<tex display="block">A \leq  B  \Leftrightarrow  B \models   \Phi _A(A)</tex>
and we require that <tex>A \cong  A'  \Leftrightarrow   \Phi _A =  \Phi _{A'}</tex></p><p>This definition comes from <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic structures</link></p><p>An alternative definition, or characterization, from <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Baldwin and Shi</link>, is a class that satisfies the following:</p><p>If <tex>A \in  K</tex>, <tex>A \leq  A</tex></p><p>If <tex>A \leq  B</tex>, then <tex>A \subseteq  B</tex></p><p><tex>\leq</tex> is transitive</p><p>If <tex>A \leq  C</tex>, and <tex>A \subseteq  B \subseteq  C</tex>, then <tex>A \leq  B</tex> for <tex>A,B,C  \in  K</tex></p><p><tex>\emptyset \in  K</tex> and <tex>\emptyset   \leq  A</tex> for all <tex>A \in  K</tex></p><p>The only difference between these two characterizations is that in the first definition, we essentially stipulate that <tex>\leq</tex> is definable/determined by a 
set of universal formulas. This turns out to be an advantage in working with these classes. Certainly, classes satisfying the first definition will satisfy Baldwin-Shi's. In this way,
it is perhaps wiser to regard the second definition as a characterization as opposed to an actual definition.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>3</crumb> <crumb>2</crumb></trail> <anchor>2887</anchor>  <taxon>Example</taxon> <addr>Smc-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-e001.tree</source-path> <route>Smc-e001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Initial Segments</title> </frontmatter> <mainmatter><p> Let <tex>(K, \leq _*)</tex> be the class of be finite, initial segements of the linear order <tex>( \omega , \leq )</tex>, where <tex>A \leq _* B</tex> is &quot;<tex>A</tex> is an initial segment of <tex>B</tex>&quot;.</p><p>It is clear that <tex>\leq</tex> fits into the definition of a smooth class, simply by the universal formula <tex>\Phi _A(y_1, \dots , y_n) =  \forall  x(( x=y_1 \lor \dots \lor  x=y_n)  \lor   \bigwedge _i^n x \geq  y_i)</tex></p><p>This class has <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">AP</link> and <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">JEP</link>, but not <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">HP</link> or <link href="Fra-d006.xml" type="local" title="Disjoint Amalgamation Property (dAP)">dAP</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>3</crumb> <crumb>3</crumb></trail> <anchor>2888</anchor>  <taxon>Theorem</taxon> <addr>Smc-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t001.tree</source-path> <route>Smc-t001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Extension of Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \leq )</tex> is a smooth class of finite structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link> and the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, 
then there is a unique, countable structure <tex>\mathcal {M}</tex>  with the following properties:</p><p>1. Any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \leq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>2. <tex>\mathcal {M} =  \bigcup ^ \omega _n A_n</tex> where <tex>A_n  \leq  A_{n+1}</tex> and for all <tex>n</tex>, <tex>A_n \in  K</tex></p><p>3. For every <tex>A \in  K</tex>, there is an embedding <tex>f:A \rightarrow  M</tex> of <tex>A</tex> into <tex>M</tex> such that <tex>f(A)  \leq  M</tex></p><p>The structure <tex>\mathcal {M}</tex> is the <em>generic</em>, or sometimes, the <em>limit</em> of <tex>K</tex>.</p><p>An equivalent characterization of a generic is properties 2 and 3 and the following property:</p><p>4. If <tex>A \leq  M</tex> and <tex>A \leq  B</tex> for <tex>B \in  K</tex>, then there is an isomorphism <tex>f: B \rightarrow  M</tex> extending the identity map <tex>id: A \rightarrow  M</tex> 
such that <tex>f(B)  \leq  M</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>3</crumb> <crumb>4</crumb></trail> <anchor>2889</anchor>  <taxon>Theorem</taxon> <addr>Smc-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t002.tree</source-path> <route>Smc-t002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes and Saturation</title> </frontmatter> <mainmatter><p>The following theorem first appears in <link href="" type="external">this paper</link> by Laskowski and Kueker</p><p>Let <tex>(K,  \leq )</tex> be a smooth class with a <link href="" type="external">generic</link> <tex>\mathcal {A}</tex>. If <tex>\mathcal {A}</tex> is weakly saturated, then <tex>\mathcal {A}</tex> is indeed saturated</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>3</crumb> <crumb>5</crumb></trail> <anchor>2890</anchor>  <taxon>Theorem</taxon> <addr>Smc-t003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t003.tree</source-path> <route>Smc-t003.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Generic of Smooth Class (Kueker &amp; Laskowski)</title> </frontmatter> <mainmatter><p>Let <tex>(K, \leq )</tex> be a smooth class with a generic <tex>\mathcal {A}</tex>. If for every <tex>A  \in  K</tex>, <tex>\Phi _A</tex> (see <link href="Smc-d001.xml" type="local" title="Smooth Class">here</link>) consists of a single universal formula,
then <tex>\mathcal {A}</tex> is an atomic model.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>61</crumb> <crumb>4</crumb></trail> <anchor>2891</anchor>  <taxon>Section</taxon> <addr>Fra-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s003.tree</source-path> <route>Fra-s003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Abstract Elementary Classes (AEC)s</title> </frontmatter> <mainmatter><p>We define AEC constructions and their properties</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb></trail> <anchor>2892</anchor>  <taxon>Part</taxon> <addr>mon-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-p001.tree</source-path> <route>mon-p001.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> <contributor><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></contributor><contributor><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></contributor></authors> <title>Dividing lines</title> </frontmatter> <mainmatter><p>Dividing lines play a fundamental role in model theory. They form the basis of Shelah's approach to classification theory and have been a central influence on model theory since their conception. Here is an interactive (though not complete) map of the <link href="https://forkinganddividing.com" type="external">model theoretic universe</link>, maintained by Gabriel Conant. Important examples of dividing lines include stability, NIP, and o-minimality.</p>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb> <crumb>1</crumb></trail> <anchor>2893</anchor>  <taxon>Section</taxon> <addr>mon-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/Stability/mon-s002.tree</source-path> <route>mon-s002.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> <contributor><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></contributor></authors> <title>Stability Theory</title> </frontmatter> <mainmatter><p><strong>Stable theories</strong></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb> <crumb>1</crumb> <crumb>1</crumb></trail> <anchor>2894</anchor>  <taxon>Subsection</taxon> <addr>mon-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/Stability/mon-s003.tree</source-path> <route>mon-s003.xml</route> <date><year>2024</year> <month>2</month> <day>10</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> <contributor><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></contributor></authors> <title>Forking and Dividing</title> </frontmatter> <mainmatter><p><strong>Forking and Dividing</strong></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb> <crumb>1</crumb> <crumb>1</crumb> <crumb>1</crumb></trail> <anchor>2895</anchor>  <taxon>Definition</taxon> <addr>mon-d012</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d012.tree</source-path> <route>mon-d012.xml</route> <date><year>2024</year> <month>11</month> <day>7</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Dividing</title> </frontmatter> <mainmatter><p>
The formula <tex>\varphi ( \overline {x}, \overline {a})</tex> (with parameter <tex>\overline {a}</tex>) <em>divides</em> over <tex>A</tex>, if there are <tex>n&lt; \omega</tex> and sequence <tex>\{ \overline {a_i}:i&lt; \omega \}</tex> such that:
<ul><li><tex>tp( \overline {a},A)=tp( \overline {a_i},A)</tex>;</li>
    <li><tex>\{ \varphi (x, \overline {a_i}):i&lt; \omega \}</tex> is <tex>n</tex>-inconsistent.</li></ul>
Usually we have <tex>\bar {a} \not \subset  A</tex>, because obviously <tex>\varphi ( \bar {x}, \bar {a})</tex> does not divide over <tex>A</tex> if <tex>\bar {a} \subseteq  A</tex>.

We say a type <tex>\mathfrak {p}</tex> divides over <tex>A</tex>, if it implies a formula dividing over <tex>A</tex>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb> <crumb>1</crumb> <crumb>1</crumb> <crumb>2</crumb></trail> <anchor>2896</anchor>  <taxon>Definition</taxon> <addr>mon-d013</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d013.tree</source-path> <route>mon-d013.xml</route> <date><year>2024</year> <month>11</month> <day>7</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Forking</title> </frontmatter> <mainmatter><p><link href="BMT-d019.xml" type="local" title="Definition of a type">Type</link> <tex>p \in  S(B)</tex> forks over <tex>A</tex> if for some finite <tex>n</tex>, and formulas <tex>\varphi _k( \overline {x}, \overline {a_{k}})</tex> where <tex>\overline {a_k} \subset  B</tex>, we have <tex>p \vdash \bigvee _{k&lt;n} \varphi _k( \overline {x}, \overline {a_{k}})</tex> where each <tex>\varphi _k( \overline {x}, \overline {a_{k}})</tex> divides over <tex>A</tex>, and <tex>\bar {x}</tex> consist of some of the variables in <tex>p</tex>/

Usually, we have <tex>p \in  S(B)</tex> when <tex>B \not \subseteq  A</tex>, because if <tex>B \subseteq  A</tex> then we will see that that <tex>p</tex> does not fork over <tex>A</tex>. Moreover, we often takes <tex>A \subseteq  B</tex>.

Notice that forking can also be defined for types over infinitely many variables.
</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree>

    
    <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb> <crumb>2</crumb></trail> <anchor>2897</anchor>  <taxon>Section</taxon> <addr>mon-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-s001.tree</source-path> <route>mon-s001.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>NIP Theories</title> </frontmatter> <mainmatter><p><strong>NIP theories</strong> are a class of theories generalizing stable
theories, but allowing for an ordering. Aside from stable theories,
important examples are real closed fields, ACVF, <tex>p</tex>-adically closed
fields, and o-minimal theories</p><p>Fix a complete theory <tex>T</tex> with monster model <tex>\mathbb {M}</tex>.
Also fix a formula <tex>\varphi (x;y)</tex> with a fixed partitioning into
the two tuples <tex>x</tex> and <tex>y</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb> <crumb>2</crumb> <crumb>1</crumb></trail> <anchor>2898</anchor>  <taxon>Definition</taxon> <addr>mon-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d004.tree</source-path> <route>mon-d004.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Definition of the independence property</title> </frontmatter> <mainmatter><p>The formula <tex>\varphi (x;y)</tex> has the <em>independence property</em> if there
are sequences of tuples <tex>(a_i : i  \in   \omega )</tex> and
<tex>(b_S : S  \subseteq   \omega )</tex> such that for every subset <tex>S  \subseteq   \omega</tex>
<tex display="block">i  \in  S  \Longleftrightarrow   \mathbb {M}  \models   \varphi (a_i; b_S).</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb> <crumb>2</crumb> <crumb>2</crumb></trail> <anchor>2899</anchor>  <taxon>Definition</taxon> <addr>mon-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d005.tree</source-path> <route>mon-d005.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Definition of NIP</title> </frontmatter> <mainmatter><p>The formula <tex>\varphi (x;y)</tex> is said to be <em>NIP</em> if it does not have
the <link href="mon-0004" type="external">independence property</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb> <crumb>2</crumb> <crumb>3</crumb></trail> <anchor>2900</anchor>  <taxon>Theorem</taxon> <addr>mon-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-t001.tree</source-path> <route>mon-t001.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Characterizations of NIP for a formula</title> </frontmatter> <mainmatter><p>The following conditions are equivalent:
<ol><li> The formula <tex>\varphi (x;y)</tex> has the independence property.</li>
  <li> The formula <tex>\varphi ^{ \vee }(y;x)</tex> has the independence property,
	where <tex>\varphi ^{ \vee }(y;x)</tex> is the formula <tex>\varphi (x;y)</tex> with the
	opposite partition.</li>
	<li> For any two finite sets <tex>U</tex> and <tex>V</tex>, and any subset <tex>R  \subseteq  U  \times  V</tex>, there are <tex>(a_i : i  \in  U)</tex> and <tex>(b_j : j  \in  U)</tex> such that <tex>\mathbb   \models   \varphi (a_i;b_j)  \Longleftrightarrow  (i,j)  \in  R</tex>.</li>
	<li> There is an indiscernible sequence <tex>(a_i : i  \in   \omega )</tex>
	and some <tex>b</tex> such that <tex>\mathbb  M  \models   \varphi (a_i;b)  \Longleftrightarrow  i</tex>
	is even.</li></ol></p><p>We are also interested in the following characterization, which is more amenable to computations.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb> <crumb>2</crumb> <crumb>3</crumb> <crumb>1</crumb></trail> <anchor>2901</anchor>  <taxon>Definition</taxon> <addr>mon-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d007.tree</source-path> <route>mon-d007.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Alternation Number</title> </frontmatter> <mainmatter><p>The <em>alternation number</em> of a formula <tex>\varphi (x;y)</tex>, denoted <tex>\operatorname {alt}( \varphi (x;y))</tex> is the maximal number <tex>n  \in   \omega</tex> (if it exists) such that there is an indiscernible sequence <tex>(a_i : i  \in   \omega )</tex>, some <tex>b</tex>, and indices <tex>i_0 &lt;  \dots  &lt; i_n</tex> with <tex>\mathbb  M  \models   \varphi (a_i,b)  \Longleftrightarrow  i  \text { is even}</tex>. If no such maximum exists, we let <tex>\operatorname {alt}( \varphi (x;y)) =  \infty</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb> <crumb>2</crumb> <crumb>3</crumb> <crumb>2</crumb></trail> <anchor>2902</anchor>  <taxon>Lemma</taxon> <addr>mon-d008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d008.tree</source-path> <route>mon-d008.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Alternation Lemma</title> </frontmatter> <mainmatter><p>A formula <tex>\varphi (x;y)</tex> is NIP if and only if <tex>\operatorname {alt}( \varphi (x;y)) &lt;  \infty</tex>.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree>

    
    <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb> <crumb>3</crumb></trail> <anchor>2903</anchor>  <taxon>Section</taxon> <addr>mon-s004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-s004.tree</source-path> <route>mon-s004.xml</route> <date><year>2024</year> <month>11</month> <day>7</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Elimination of Imaginaries</title> </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb> <crumb>3</crumb> <crumb>1</crumb></trail> <anchor>2904</anchor>  <taxon>Definition</taxon> <addr>mon-d009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d009.tree</source-path> <route>mon-d009.xml</route> <date><year>2024</year> <month>11</month> <day>7</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Elimination of Imaginaries</title> </frontmatter> <mainmatter><p>
    A model <tex>M</tex> has elimination of imaginaries, when given a formula <tex>\theta ( \bar {x}, \bar {y})</tex> where <tex>l( \bar {x})=l( \bar {y})=n</tex> that defines an equivalence relation on <tex>M^n</tex>, for every equivalence class <tex>\bar {a}/ \theta</tex> represented by <tex>\bar {a}</tex>, there is a formula <tex>\phi</tex>, such that the equivalence class <tex>\bar {a}/ \theta</tex> is defined by <tex>\phi ( \bar {x}, \bar {b})</tex>, where <tex>\bar {b}</tex> is unique given <tex>\phi</tex> and <tex>\bar {a}/ \theta</tex>.

    A theory <tex>T</tex> is said to have elimination of imaginaries, if every model <tex>M</tex> of <tex>T</tex> has elimination of imaginaries.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb> <crumb>3</crumb> <crumb>2</crumb></trail> <anchor>2905</anchor>  <taxon>Definition</taxon> <addr>mon-d010</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d010.tree</source-path> <route>mon-d010.xml</route> <date><year>2024</year> <month>11</month> <day>7</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Uniform Elimination of Imaginaries</title> </frontmatter> <mainmatter><p>
    A model <tex>M</tex> has uniform elimination of imaginaries, if, in addition to having elimination of imaginaries, the formula <tex>\phi</tex> is independent of <tex>\bar {a}</tex> and is dependent only on <tex>\theta</tex>. 
    
    Equivalently, we can say $M$ has uniform elimination of imaginaries if there is a $0$-definable function <tex>f</tex>, such that <tex>f( \bar {a})= \bar {b}</tex> where <tex>\bar {b}</tex> is the unique tuple that defines <tex>\bar {a}/ \theta</tex>.
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>62</crumb> <crumb>3</crumb> <crumb>3</crumb></trail> <anchor>2906</anchor>  <taxon>Definition</taxon> <addr>mon-d011</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d011.tree</source-path> <route>mon-d011.xml</route> <date><year>2024</year> <month>11</month> <day>7</day></date> <authors><author><link href="ruohan-hu.xml" type="local">Ruohan Hu</link></author> </authors> <title>Weak Elimination of Imaginaries</title> </frontmatter> <mainmatter><p>  
    A model <tex>M</tex> has weak elimination of imaginaries, when given a formula <tex>\theta ( \bar {x}, \bar {y})</tex> where <tex>l( \bar {x})=l( \bar {y})=n</tex> that defines an equivalence relation on <tex>M^n</tex>, for every equivalence class <tex>\bar {a}/ \theta</tex>, there is a formula <tex>\phi</tex>, and a finite set of tuples <tex>X</tex> in <tex>M</tex> such that the equivalence class <tex>\bar {a}/ \theta</tex> is defined by <tex>\phi ( \bar {x}, \bar {b})</tex> if and only if <tex>\bar {b} \in  X</tex>.
    
    A theory <tex>T</tex> is said to have weak elimination of imaginaries, if every model <tex>M</tex> of <tex>T</tex> has weak elimination of imaginaries.
</p></mainmatter> </tree></mainmatter> </tree>
</mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>63</crumb></trail> <anchor>2907</anchor>  <taxon>Part</taxon> <addr>inf-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Infinitary Logic/inf-p001.tree</source-path> <route>inf-p001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Infinitary Model Theory</title> </frontmatter> <mainmatter><p>We present the fundamentals of infinitary model theory. The main reference will be David Marker's book Lectures on Infinitary Logic</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>64</crumb></trail> <anchor>2908</anchor>  <taxon>Part</taxon> <addr>moe-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Monadic Expansions/moe-p001.tree</source-path> <route>moe-p001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> <contributor><link href="gpeters.xml" type="local">Garrett Peters</link></contributor></authors> <title>Monadic Expansions</title> </frontmatter> <mainmatter><p>Model Theory of Monadic Expansions</p>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>64</crumb> <crumb>1</crumb></trail> <anchor>2909</anchor>  <taxon>Section</taxon> <addr>moe-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Monadic Expansions/Mutually Algebraic Theories/moe-s001.tree</source-path> <route>moe-s001.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Monadic NFCP</title> </frontmatter> <mainmatter><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>64</crumb> <crumb>1</crumb> <crumb>1</crumb></trail> <anchor>2910</anchor>  <taxon>Definition</taxon> <addr>moe-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Monadic Expansions/Mutually Algebraic Theories/moe-d001.tree</source-path> <route>moe-d001.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Monadic Expansion of a Language</title> </frontmatter> <mainmatter><p>Let <tex>L</tex> be any <link href="BMT-d001.xml" type="local" title="Language">language</link>. Then a monadic expansion of <tex>L</tex> is a language <tex>L':= L \cup \{ R_i \} _{i \in  I}</tex>, where <tex>\{ R_i \} _{i \in  I}</tex> is a collection of unary relation symbols.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>64</crumb> <crumb>1</crumb> <crumb>2</crumb></trail> <anchor>2911</anchor>  <taxon>Definition</taxon> <addr>moe-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Monadic Expansions/Mutually Algebraic Theories/moe-d002.tree</source-path> <route>moe-d002.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Monadically NFCP</title> </frontmatter> <mainmatter><p>Let <tex>M</tex> be an <tex>L</tex>-<link href="BMT-d002.xml" type="local" title="Structure">structure</link>. Then <tex>M</tex> is monadically NFCP if it is NFCP under every <link href="moe-d001.xml" type="local" title="Monadic Expansion of a Language">monadic expansion of <tex>L</tex></link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>64</crumb> <crumb>1</crumb> <crumb>3</crumb></trail> <anchor>2912</anchor>  <taxon>Definition</taxon> <addr>moe-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Monadic Expansions/Mutually Algebraic Theories/moe-d003.tree</source-path> <route>moe-d003.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Mutually Algebraic Sets</title> </frontmatter> <mainmatter><p>Let <tex>X</tex> be a non-empty set and <tex>l \geq1</tex>. Then a subset <tex>C \subseteq  X^l</tex> is mutually algebraic if there exists some <tex>K</tex> such that for all <tex>a \in  X</tex>, we have <tex>| \{ \overline {c} \in  C: a \in \overline {c} \} | \leq  K</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>64</crumb> <crumb>1</crumb> <crumb>4</crumb></trail> <anchor>2913</anchor>  <taxon>Example</taxon> <addr>moe-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Monadic Expansions/Mutually Algebraic Theories/moe-e001.tree</source-path> <route>moe-e001.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Mated Pairs</title> </frontmatter> <mainmatter><p>For <tex>l</tex>=2, if <tex>C \subseteq  X^2</tex> is a set of mated pairs, i.e. every element in <tex>X</tex> has a unique &quot;mate,&quot; which is symmetric, then <tex>C</tex> is <link href="moe-d003.xml" type="local" title="Mutually Algebraic Sets">mutually algebraic</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>64</crumb> <crumb>1</crumb> <crumb>5</crumb></trail> <anchor>2914</anchor>  <taxon>Definition</taxon> <addr>moe-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Monadic Expansions/Mutually Algebraic Theories/moe-d004.tree</source-path> <route>moe-d004.xml</route> <date><year>2024</year> <month>5</month> <day>2</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Mutually Algebraic Formulas</title> </frontmatter> <mainmatter><p>Suppose <tex>M</tex> is an <tex>L</tex>-<link href="BMT-d002.xml" type="local" title="Structure">structure</link> and <tex>\phi ( \overline {z})</tex> is an <tex>L(M)</tex> definable set. Then <tex>\phi</tex> is a mutually algebraic formula if <tex>D= \phi ( \overline {z})</tex> is a <link href="moe-d003.xml" type="local" title="Mutually Algebraic Sets">mutually algebraic subset</link> of <tex>M^{lg( \overline {z})}</tex>.</p></mainmatter> </tree></mainmatter> </tree>
</mainmatter> </tree>
</mainmatter> </tree></contributions> <context/> <related/> <backlinks/> <references/></backmatter></tree>