<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="forest.xsl"?>
<tree expanded="true" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1633</anchor>  <taxon>Person</taxon> <addr>mbryant</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Authors/mbryant.tree</source-path> <route>mbryant.xml</route>   <title>Morgan Bryant</title> </frontmatter> <mainmatter><p>Doctorate student with interests in classical model theory, set theory, computability, and infinitary logic</p></mainmatter> <backmatter><contributions><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1634</anchor>  <taxon>Definition</taxon> <addr>Set-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d001.tree</source-path> <route>Set-d001.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Existentionality (AE)</title> </frontmatter> <mainmatter><p>The axiom of existentionality is as follows:</p><p><tex>\forall  x  \forall  y( x = y  \Leftrightarrow  ( \forall  z (z \in  x  \leftrightarrow  z \in  y)))</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1635</anchor>  <taxon>Definition</taxon> <addr>Set-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d005.tree</source-path> <route>Set-d005.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Infinity</title> </frontmatter> <mainmatter><p>The axiom of infinity is as follows:</p><p>*****</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1636</anchor>  <taxon>Definition</taxon> <addr>Set-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d002.tree</source-path> <route>Set-d002.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Pairing (PA)</title> </frontmatter> <mainmatter><p>The Pairing Axiom is as follows:</p><p><tex>\forall  x  \forall  y  \exists  z ( \forall  w(w \in  z  \leftrightarrow  (w= x \lor  w=y)))</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1637</anchor>  <taxon>Definition</taxon> <addr>Set-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d004.tree</source-path> <route>Set-d004.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Seperation (SA)</title> </frontmatter> <mainmatter><p>The axiom of seperation, or the seperation schema, is as follows:</p><p>If <tex>\varphi (x_1, \dots , x_n,z)</tex> is any formula in the appropriate language, then there exists a set <tex> y =  \{ z:  \varphi (x_1, \dots , x_n, z)</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1638</anchor>  <taxon>Definition</taxon> <addr>Set-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d003.tree</source-path> <route>Set-d003.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Union (UA)</title> </frontmatter> <mainmatter><p>The Union Axiom is as follows:</p><p><tex>\forall  x  \exists  z( \forall  y( y \in  z  \leftrightarrow  ( \exists  w  \in  x (y \in  w))))</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1639</anchor>  <taxon>Definition</taxon> <addr>DST-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-s001.tree</source-path> <route>DST-s001.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Basic DST</title> </frontmatter> <mainmatter><p>We give basic definitions of Borel sets, topology, polish spaces, Baire spaces, etc.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>1</crumb></trail> <anchor>1640</anchor>  <taxon>Definition</taxon> <addr>DST-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d001.tree</source-path> <route>DST-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Borel Sets</title> </frontmatter> <mainmatter><p>Given a topology, the Borel sets are the sets generated by closing the open sets under complementation and countable union.</p><p>A <tex>G_ \delta</tex> set is a Borel set formed by a countable intersection of open sets.</p><p>A <tex>F_ \sigma</tex> set is a Borel set formed by a countable union of closed sets.</p><p>(Recall a countable union of open sets is open, and a countable intersection is closed.)</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>2</crumb></trail> <anchor>1641</anchor>  <taxon>Definition</taxon> <addr>DST-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d002.tree</source-path> <route>DST-d002.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Borel Hierarchy</title> </frontmatter> <mainmatter><p>Building off of the <link href="DST-d001.xml" type="local" title="Definition of Borel Sets">Borel sets</link>, welet <tex>\Sigma _0</tex> denote open sets, <tex>\Pi _0</tex> the closed sets, and then 
<tex display="block">\Sigma _n =  \{ \bigcup _i^ \omega  A_i : A_i  \in   \Pi _{n-1} \}</tex>
<tex display="block">\Pi _n =  \{ \bigcap _i^ \omega  A_i : A_i  \in   \Sigma _{n-1} \}</tex></p><p>This is the Borel Hierarchy, and it mirrors similar hierarchies in recursion theory. 
Notice in particular <tex>\Sigma _1</tex> is the set of <tex>F_ \sigma</tex> sets, <tex>\Pi _1</tex> is the set of <tex>G_ \delta</tex> sets. </p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>3</crumb></trail> <anchor>1642</anchor>  <taxon>Definition</taxon> <addr>DST-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d003.tree</source-path> <route>DST-d003.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Polish Space</title> </frontmatter> <mainmatter><p>Given a topological space <tex>X</tex>, <tex>X</tex> is a Polish space if <tex>X</tex> is completely metrisable and seperable</p><p>(Seperable = Second Countable = There is a dense, countable set in <tex>X</tex>)</p><p>(Completely metrisable = there is a metric on <tex>X</tex> which is complete = there is a metric on <tex>X</tex> so that every cauchy sequence 
has a limit)</p><p>Closed subsets of Polish spaces are themselves Polish (closed = the restricted metric is complete), Product and sums of topologies of Polish spaces are Polish</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>4</crumb></trail> <anchor>1643</anchor>  <taxon>Definition</taxon> <addr>DST-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d004.tree</source-path> <route>DST-d004.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Meagre and Comeagre Sets</title> </frontmatter> <mainmatter><p>Given a topological space <tex>X</tex>, <tex>A \subseteq  X</tex> is meagre if <tex display="block">A =  \bigcup _i^ \omega  A_i</tex> where the closure of <tex>A_i</tex> has empty interior (i.e., nowhere dense)</p><p>Comeagre sets are the complements of meagre sets</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1644</anchor>  <taxon>Part</taxon> <addr>DST-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/DST-p001.tree</source-path> <route>DST-p001.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Basics of Descriptive Set Theory and Relations to Model Theory</title> </frontmatter> <mainmatter><p>We present the basics of descriptive set theory (DST) and its relationship to model theory.</p><p>The main resource will be <link href="DST-r001.xml" type="local" title="Classical Descriptive Set Theory">Kechris's Classical Descriptive Set Theory</link>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>5</crumb></trail> <anchor>1645</anchor>  <taxon>Definition</taxon> <addr>DST-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-s001.tree</source-path> <route>DST-s001.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Basic DST</title> </frontmatter> <mainmatter><p>We give basic definitions of Borel sets, topology, polish spaces, Baire spaces, etc.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>5</crumb> <crumb>1</crumb></trail> <anchor>1646</anchor>  <taxon>Definition</taxon> <addr>DST-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d001.tree</source-path> <route>DST-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Borel Sets</title> </frontmatter> <mainmatter><p>Given a topology, the Borel sets are the sets generated by closing the open sets under complementation and countable union.</p><p>A <tex>G_ \delta</tex> set is a Borel set formed by a countable intersection of open sets.</p><p>A <tex>F_ \sigma</tex> set is a Borel set formed by a countable union of closed sets.</p><p>(Recall a countable union of open sets is open, and a countable intersection is closed.)</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>5</crumb> <crumb>2</crumb></trail> <anchor>1647</anchor>  <taxon>Definition</taxon> <addr>DST-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d002.tree</source-path> <route>DST-d002.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Borel Hierarchy</title> </frontmatter> <mainmatter><p>Building off of the <link href="DST-d001.xml" type="local" title="Definition of Borel Sets">Borel sets</link>, welet <tex>\Sigma _0</tex> denote open sets, <tex>\Pi _0</tex> the closed sets, and then 
<tex display="block">\Sigma _n =  \{ \bigcup _i^ \omega  A_i : A_i  \in   \Pi _{n-1} \}</tex>
<tex display="block">\Pi _n =  \{ \bigcap _i^ \omega  A_i : A_i  \in   \Sigma _{n-1} \}</tex></p><p>This is the Borel Hierarchy, and it mirrors similar hierarchies in recursion theory. 
Notice in particular <tex>\Sigma _1</tex> is the set of <tex>F_ \sigma</tex> sets, <tex>\Pi _1</tex> is the set of <tex>G_ \delta</tex> sets. </p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>5</crumb> <crumb>3</crumb></trail> <anchor>1648</anchor>  <taxon>Definition</taxon> <addr>DST-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d003.tree</source-path> <route>DST-d003.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Polish Space</title> </frontmatter> <mainmatter><p>Given a topological space <tex>X</tex>, <tex>X</tex> is a Polish space if <tex>X</tex> is completely metrisable and seperable</p><p>(Seperable = Second Countable = There is a dense, countable set in <tex>X</tex>)</p><p>(Completely metrisable = there is a metric on <tex>X</tex> which is complete = there is a metric on <tex>X</tex> so that every cauchy sequence 
has a limit)</p><p>Closed subsets of Polish spaces are themselves Polish (closed = the restricted metric is complete), Product and sums of topologies of Polish spaces are Polish</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>5</crumb> <crumb>4</crumb></trail> <anchor>1649</anchor>  <taxon>Definition</taxon> <addr>DST-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d004.tree</source-path> <route>DST-d004.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Meagre and Comeagre Sets</title> </frontmatter> <mainmatter><p>Given a topological space <tex>X</tex>, <tex>A \subseteq  X</tex> is meagre if <tex display="block">A =  \bigcup _i^ \omega  A_i</tex> where the closure of <tex>A_i</tex> has empty interior (i.e., nowhere dense)</p><p>Comeagre sets are the complements of meagre sets</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1650</anchor>  <taxon>Definition</taxon> <addr>DST-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d002.tree</source-path> <route>DST-d002.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Borel Hierarchy</title> </frontmatter> <mainmatter><p>Building off of the <link href="DST-d001.xml" type="local" title="Definition of Borel Sets">Borel sets</link>, welet <tex>\Sigma _0</tex> denote open sets, <tex>\Pi _0</tex> the closed sets, and then 
<tex display="block">\Sigma _n =  \{ \bigcup _i^ \omega  A_i : A_i  \in   \Pi _{n-1} \}</tex>
<tex display="block">\Pi _n =  \{ \bigcap _i^ \omega  A_i : A_i  \in   \Sigma _{n-1} \}</tex></p><p>This is the Borel Hierarchy, and it mirrors similar hierarchies in recursion theory. 
Notice in particular <tex>\Sigma _1</tex> is the set of <tex>F_ \sigma</tex> sets, <tex>\Pi _1</tex> is the set of <tex>G_ \delta</tex> sets. </p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1651</anchor>  <taxon>Definition</taxon> <addr>DST-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d004.tree</source-path> <route>DST-d004.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Meagre and Comeagre Sets</title> </frontmatter> <mainmatter><p>Given a topological space <tex>X</tex>, <tex>A \subseteq  X</tex> is meagre if <tex display="block">A =  \bigcup _i^ \omega  A_i</tex> where the closure of <tex>A_i</tex> has empty interior (i.e., nowhere dense)</p><p>Comeagre sets are the complements of meagre sets</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1652</anchor>  <taxon>Definition</taxon> <addr>DST-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d003.tree</source-path> <route>DST-d003.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Polish Space</title> </frontmatter> <mainmatter><p>Given a topological space <tex>X</tex>, <tex>X</tex> is a Polish space if <tex>X</tex> is completely metrisable and seperable</p><p>(Seperable = Second Countable = There is a dense, countable set in <tex>X</tex>)</p><p>(Completely metrisable = there is a metric on <tex>X</tex> which is complete = there is a metric on <tex>X</tex> so that every cauchy sequence 
has a limit)</p><p>Closed subsets of Polish spaces are themselves Polish (closed = the restricted metric is complete), Product and sums of topologies of Polish spaces are Polish</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1653</anchor>  <taxon>Definition</taxon> <addr>Fra-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d007.tree</source-path> <route>Fra-d007.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ramsey Class</title> </frontmatter> <mainmatter><p>For structures <tex>A,B</tex>, let <tex display="block">\binom {B}{A} =  \{ A_0: A_0 \leq  B &amp; ; A_0 \cong  B \}</tex></p><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the Ramsey property if for every <tex>A \leq  B  \in  K</tex>, there is some <tex>C \in  K</tex> with <tex>B \leq  C</tex>
such that for every <tex>k</tex>-coloring <tex>c:  \binom {C}{A} \rightarrow  k</tex>, there is some <tex>B'  \in   \binom {C}{B}</tex> with <tex display="block">c|_{ \binom {B'}{A}}</tex> constant.</p><p>Ramsey classes are highly related to descriptive set theory, in particular, extremely amenable sets.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1654</anchor>  <taxon>Theorem</taxon> <addr>Smc-t003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t003.tree</source-path> <route>Smc-t003.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Generic of Smooth Class (Kueker &amp; Laskowski)</title> </frontmatter> <mainmatter><p>Let <tex>(K, \leq )</tex> be a smooth class with a generic <tex>\mathcal {A}</tex>. If for every <tex>A  \in  K</tex>, <tex>\Phi _A</tex> (see <link href="Smc-d001.xml" type="local" title="Smooth Class">here</link>) consists of a single universal formula,
then <tex>\mathcal {A}</tex> is an atomic model.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1655</anchor>  <taxon>Section</taxon> <addr>Set-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-s001.tree</source-path> <route>Set-s001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axioms of Set Theory</title> </frontmatter> <mainmatter><p>We describe the different set theory axioms and different accepted sets of these axioms, such as ZFC, ZFC+, etc.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>6</crumb></trail> <anchor>1656</anchor>  <taxon>Definition</taxon> <addr>Set-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d001.tree</source-path> <route>Set-d001.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Existentionality (AE)</title> </frontmatter> <mainmatter><p>The axiom of existentionality is as follows:</p><p><tex>\forall  x  \forall  y( x = y  \Leftrightarrow  ( \forall  z (z \in  x  \leftrightarrow  z \in  y)))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>7</crumb></trail> <anchor>1657</anchor>  <taxon>Definition</taxon> <addr>Set-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d002.tree</source-path> <route>Set-d002.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Pairing (PA)</title> </frontmatter> <mainmatter><p>The Pairing Axiom is as follows:</p><p><tex>\forall  x  \forall  y  \exists  z ( \forall  w(w \in  z  \leftrightarrow  (w= x \lor  w=y)))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>8</crumb></trail> <anchor>1658</anchor>  <taxon>Definition</taxon> <addr>Set-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d003.tree</source-path> <route>Set-d003.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Union (UA)</title> </frontmatter> <mainmatter><p>The Union Axiom is as follows:</p><p><tex>\forall  x  \exists  z( \forall  y( y \in  z  \leftrightarrow  ( \exists  w  \in  x (y \in  w))))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>9</crumb></trail> <anchor>1659</anchor>  <taxon>Definition</taxon> <addr>Set-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d004.tree</source-path> <route>Set-d004.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Seperation (SA)</title> </frontmatter> <mainmatter><p>The axiom of seperation, or the seperation schema, is as follows:</p><p>If <tex>\varphi (x_1, \dots , x_n,z)</tex> is any formula in the appropriate language, then there exists a set <tex> y =  \{ z:  \varphi (x_1, \dots , x_n, z)</tex></p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1660</anchor>  <taxon>Part</taxon> <addr>Set-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Set-p001.tree</source-path> <route>Set-p001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Basic Set Theory</title> </frontmatter> <mainmatter><p>In this part, we give some of the basic notions of set theory that are necessary to studying model theory. Topics include definitions of ZFC, set theory axioms, cardinals and ordinals, partial/linear orders,....</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>10</crumb></trail> <anchor>1661</anchor>  <taxon>Section</taxon> <addr>Set-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-s001.tree</source-path> <route>Set-s001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axioms of Set Theory</title> </frontmatter> <mainmatter><p>We describe the different set theory axioms and different accepted sets of these axioms, such as ZFC, ZFC+, etc.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>10</crumb> <crumb>1</crumb></trail> <anchor>1662</anchor>  <taxon>Definition</taxon> <addr>Set-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d001.tree</source-path> <route>Set-d001.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Existentionality (AE)</title> </frontmatter> <mainmatter><p>The axiom of existentionality is as follows:</p><p><tex>\forall  x  \forall  y( x = y  \Leftrightarrow  ( \forall  z (z \in  x  \leftrightarrow  z \in  y)))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>10</crumb> <crumb>2</crumb></trail> <anchor>1663</anchor>  <taxon>Definition</taxon> <addr>Set-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d002.tree</source-path> <route>Set-d002.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Pairing (PA)</title> </frontmatter> <mainmatter><p>The Pairing Axiom is as follows:</p><p><tex>\forall  x  \forall  y  \exists  z ( \forall  w(w \in  z  \leftrightarrow  (w= x \lor  w=y)))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>10</crumb> <crumb>3</crumb></trail> <anchor>1664</anchor>  <taxon>Definition</taxon> <addr>Set-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d003.tree</source-path> <route>Set-d003.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Union (UA)</title> </frontmatter> <mainmatter><p>The Union Axiom is as follows:</p><p><tex>\forall  x  \exists  z( \forall  y( y \in  z  \leftrightarrow  ( \exists  w  \in  x (y \in  w))))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>10</crumb> <crumb>4</crumb></trail> <anchor>1665</anchor>  <taxon>Definition</taxon> <addr>Set-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Set Theory/Axioms/Set-d004.tree</source-path> <route>Set-d004.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Axiom of Seperation (SA)</title> </frontmatter> <mainmatter><p>The axiom of seperation, or the seperation schema, is as follows:</p><p>If <tex>\varphi (x_1, \dots , x_n,z)</tex> is any formula in the appropriate language, then there exists a set <tex> y =  \{ z:  \varphi (x_1, \dots , x_n, z)</tex></p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1666</anchor>  <taxon>Definition</taxon> <addr>DST-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/DescriptiveST/Basic notions/DST-d001.tree</source-path> <route>DST-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Borel Sets</title> </frontmatter> <mainmatter><p>Given a topology, the Borel sets are the sets generated by closing the open sets under complementation and countable union.</p><p>A <tex>G_ \delta</tex> set is a Borel set formed by a countable intersection of open sets.</p><p>A <tex>F_ \sigma</tex> set is a Borel set formed by a countable union of closed sets.</p><p>(Recall a countable union of open sets is open, and a countable intersection is closed.)</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1667</anchor>  <taxon>Definition</taxon> <addr>Fra-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d006.tree</source-path> <route>Fra-d006.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Disjoint Amalgamation Property (dAP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Disjoint Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex> such that <tex>B \cap  C =A</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex>, <tex>h_2(f(A)) = h_1(g(A))</tex>, and <tex>h_2(C)  \cap  h_1(B) = h_1(A)</tex></p><p>An example of a class which has the dAP is the <link href="Fra-e001.xml" type="local" title="The Random Graph">Fraisse class of finite graphs</link></p><p>An example of a smooth class which does not have the dAP is <link href="Smc-e001.xml" type="local" title="Initial Segments">The class of initial segments</link></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1668</anchor>  <taxon>Example</taxon> <addr>Smc-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-e001.tree</source-path> <route>Smc-e001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Initial Segments</title> </frontmatter> <mainmatter><p> Let <tex>(K, \leq _*)</tex> be the class of be finite, initial segements of the linear order <tex>( \omega , \leq )</tex>, where <tex>A \leq _* B</tex> is &quot;<tex>A</tex> is an initial segment of <tex>B</tex>&quot;.</p><p>It is clear that <tex>\leq</tex> fits into the definition of a smooth class, simply by the universal formula <tex>\Phi _A(y_1, \dots , y_n) =  \forall  x(( x=y_1 \lor \dots \lor  x=y_n)  \lor   \bigwedge _i^n x \geq  y_i)</tex></p><p>This class has <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">AP</link> and <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">JEP</link>, but not <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">HP</link> or <link href="Fra-d006.xml" type="local" title="Disjoint Amalgamation Property (dAP)">dAP</link></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1669</anchor>  <taxon>Section</taxon> <addr>Fra-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s002.tree</source-path> <route>Fra-s002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Other Properties of Classes</title> </frontmatter> <mainmatter><p>We define other common properties and variants of the set up shown in the <link href="Fra-s001.xml" type="local" title="Fraisse Classes">Fraisse section</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>11</crumb></trail> <anchor>1670</anchor>  <taxon>Definition</taxon> <addr>Fra-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d006.tree</source-path> <route>Fra-d006.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Disjoint Amalgamation Property (dAP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Disjoint Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex> such that <tex>B \cap  C =A</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex>, <tex>h_2(f(A)) = h_1(g(A))</tex>, and <tex>h_2(C)  \cap  h_1(B) = h_1(A)</tex></p><p>An example of a class which has the dAP is the <link href="Fra-e001.xml" type="local" title="The Random Graph">Fraisse class of finite graphs</link></p><p>An example of a smooth class which does not have the dAP is <link href="Smc-e001.xml" type="local" title="Initial Segments">The class of initial segments</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>12</crumb></trail> <anchor>1671</anchor>  <taxon>Definition</taxon> <addr>Fra-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d007.tree</source-path> <route>Fra-d007.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ramsey Class</title> </frontmatter> <mainmatter><p>For structures <tex>A,B</tex>, let <tex display="block">\binom {B}{A} =  \{ A_0: A_0 \leq  B &amp; ; A_0 \cong  B \}</tex></p><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the Ramsey property if for every <tex>A \leq  B  \in  K</tex>, there is some <tex>C \in  K</tex> with <tex>B \leq  C</tex>
such that for every <tex>k</tex>-coloring <tex>c:  \binom {C}{A} \rightarrow  k</tex>, there is some <tex>B'  \in   \binom {C}{B}</tex> with <tex display="block">c|_{ \binom {B'}{A}}</tex> constant.</p><p>Ramsey classes are highly related to descriptive set theory, in particular, extremely amenable sets.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1672</anchor>  <taxon>Definition</taxon> <addr>Smc-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-d001.tree</source-path> <route>Smc-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Class</title> </frontmatter> <mainmatter><p>We assume the language <tex>\mathcal {L}</tex> is countable and only relational.</p><p>A class <tex>(K, \leq )</tex> of finite <tex>\mathcal {L}</tex>-structures (closed under isomorphism) is called <em>a smooth class</em> if <tex>\leq</tex> is transitive, <tex>A \leq  B  \Rightarrow  A \subsetq  B</tex>, and for each <tex>A \in  K</tex>, there is a set of universal formulas <tex>\Phi _A</tex> such that:
<tex display="block">A \leq  B  \Leftrightarrow  B \models   \Phi _A(A)</tex>
and we require that <tex>A \cong  A'  \Leftrightarrow   \Phi _A =  \Phi _{A'}</tex></p><p>This definition comes from <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic structures</link></p><p>An alternative definition, or characterization, from <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Baldwin and Shi</link>, is a class that satisfies the following:</p><p>If <tex>A \in  K</tex>, <tex>A \leq  A</tex></p><p>If <tex>A \leq  B</tex>, then <tex>A \subseteq  B</tex></p><p><tex>\leq</tex> is transitive</p><p>If <tex>A \leq  C</tex>, and <tex>A \subseteq  B \subseteq  C</tex>, then <tex>A \leq  B</tex> for <tex>A,B,C  \in  K</tex></p><p><tex>\emptyset \in  K</tex> and <tex>\emptyset   \leq  A</tex> for all <tex>A \in  K</tex></p><p>The only difference between these two characterizations is that in the first definition, we essentially stipulate that <tex>\leq</tex> is definable/determined by a 
set of universal formulas. This turns out to be an advantage in working with these classes. Certainly, classes satisfying the first definition will satisfy Baldwin-Shi's. In this way,
it is perhaps wiser to regard the second definition as a characterization as opposed to an actual definition.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1673</anchor>  <taxon>Theorem</taxon> <addr>Smc-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t002.tree</source-path> <route>Smc-t002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes and Saturation</title> </frontmatter> <mainmatter><p>The following theorem first appears in <link href="" type="external">this paper</link> by Laskowski and Kueker</p><p>Let <tex>(K,  \leq )</tex> be a smooth class with a <link href="" type="external">generic</link> <tex>\mathcal {A}</tex>. If <tex>\mathcal {A}</tex> is weakly saturated, then <tex>\mathcal {A}</tex> is indeed saturated</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1674</anchor>  <taxon>Theorem</taxon> <addr>Smc-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t001.tree</source-path> <route>Smc-t001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Extension of Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \leq )</tex> is a smooth class of finite structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link> and the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, 
then there is a unique, countable structure <tex>\mathcal {M}</tex>  with the following properties:</p><p>1. Any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \leq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>2. <tex>\mathcal {M} =  \bigcup ^ \omega _n A_n</tex> where <tex>A_n  \leq  A_{n+1}</tex> and for all <tex>n</tex>, <tex>A_n \in  K</tex></p><p>3. For every <tex>A \in  K</tex>, there is an embedding <tex>f:A \rightarrow  M</tex> of <tex>A</tex> into <tex>M</tex> such that <tex>f(A)  \leq  M</tex></p><p>The structure <tex>\mathcal {M}</tex> is the <em>generic</em>, or sometimes, the <em>limit</em> of <tex>K</tex>.</p><p>An equivalent characterization of a generic is properties 2 and 3 and the following property:</p><p>4. If <tex>A \leq  M</tex> and <tex>A \leq  B</tex> for <tex>B \in  K</tex>, then there is an isomorphism <tex>f: B \rightarrow  M</tex> extending the identity map <tex>id: A \rightarrow  M</tex> 
such that <tex>f(B)  \leq  M</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1675</anchor>  <taxon>Example</taxon> <addr>Fra-e002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e002.tree</source-path> <route>Fra-e002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>( \mathbb {Q},  \leq )</tex></title> </frontmatter> <mainmatter><p>The Dense Linear Order <tex>( \mathbb {Q},  \leq )</tex> is the Fraisse Limit of the class of all finite linear orders</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1676</anchor>  <taxon>Section</taxon> <addr>Fra-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s003.tree</source-path> <route>Fra-s003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Abstract Elementary Classes (AEC)s</title> </frontmatter> <mainmatter><p>We define AEC constructions and their properties</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1677</anchor>  <taxon>Definition</taxon> <addr>Fra-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d002.tree</source-path> <route>Fra-d002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Age</title> </frontmatter> <mainmatter><p>Given a structure <tex>A</tex> in a language <tex>\mathcal {L}</tex>, the <em>Age</em> (pronounced ah-zh) of <tex>A</tex> is <tex display="block">\{ B \subseteq  A: B  \text { is finitely generated } \}</tex></p><p>The age of a structure is itself a class, often under the relation of substructure</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1678</anchor>  <taxon>Definition</taxon> <addr>Fra-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d003.tree</source-path> <route>Fra-d003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Amalgamation Property (AP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex> and <tex>h_2(f(A)) = h_1(g(A))</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1679</anchor>  <taxon>Definition</taxon> <addr>Fra-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d001.tree</source-path> <route>Fra-d001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Class of Structures</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, a class <tex>K</tex> is defined to be a set of <tex>\mathcal {L}</tex>-structures</p><p>Often, we want there to be a relation <tex>\leq</tex> acting on the structures in <tex>K</tex>, and when we do, we write the class and relation as a pair <tex>(K,  \leq )</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1680</anchor>  <taxon>Section</taxon> <addr>Fra-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s001.tree</source-path> <route>Fra-s001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse Classes</title> </frontmatter> <mainmatter><p>We define Fraisse constructions and their properties. Most of the concepts can be referred to in <link href="Ref-0001.xml" type="local" title="Model Theory by Wilfred Hodges">Wilfred Hodges' Model Theory</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>13</crumb></trail> <anchor>1681</anchor>  <taxon>Definition</taxon> <addr>Fra-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d001.tree</source-path> <route>Fra-d001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Class of Structures</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, a class <tex>K</tex> is defined to be a set of <tex>\mathcal {L}</tex>-structures</p><p>Often, we want there to be a relation <tex>\leq</tex> acting on the structures in <tex>K</tex>, and when we do, we write the class and relation as a pair <tex>(K,  \leq )</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>14</crumb></trail> <anchor>1682</anchor>  <taxon>Definition</taxon> <addr>Fra-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d002.tree</source-path> <route>Fra-d002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Age</title> </frontmatter> <mainmatter><p>Given a structure <tex>A</tex> in a language <tex>\mathcal {L}</tex>, the <em>Age</em> (pronounced ah-zh) of <tex>A</tex> is <tex display="block">\{ B \subseteq  A: B  \text { is finitely generated } \}</tex></p><p>The age of a structure is itself a class, often under the relation of substructure</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>15</crumb></trail> <anchor>1683</anchor>  <taxon>Definition</taxon> <addr>Fra-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d003.tree</source-path> <route>Fra-d003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Amalgamation Property (AP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex> and <tex>h_2(f(A)) = h_1(g(A))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>16</crumb></trail> <anchor>1684</anchor>  <taxon>Definition</taxon> <addr>Fra-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d004.tree</source-path> <route>Fra-d004.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Joint Embedding Property (JEP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B  \in  K</tex>, there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex></p><p><link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">Amalgamation Property</link> does NOT necessarily imply JEP, unless the empty set <tex>\emptyset</tex> is in <tex>K</tex> and for all <tex>A \in  K</tex>, we have that <tex>\emptyset   \leq  A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>17</crumb></trail> <anchor>1685</anchor>  <taxon>Definition</taxon> <addr>Fra-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d005.tree</source-path> <route>Fra-d005.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Hereditary Property (HP)</title> </frontmatter> <mainmatter><p>A class <tex>(K, \leq )</tex> has the hereditary property if for every <tex>A \in  K</tex>, and any <tex>B \subseteq  A</tex> finitely generated, then there is some <tex>C \in  K</tex> such that <tex>C \cong  B</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>18</crumb></trail> <anchor>1686</anchor>  <taxon>Theorem</taxon> <addr>Fra-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t001.tree</source-path> <route>Fra-t001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \subset )</tex> a class of finitely generated structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link>, the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, and the <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">hereditary property</link>, 
Then there is a unique, countable structure <tex>\mathcal {M}</tex> whose <link href="Fra-d002.xml" type="local" title="Age">age</link> is <tex>K</tex> with the property that any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \subseteq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>The structure <tex>\mathcal {M}</tex> is the <em>Fraisse limit</em> of <tex>K</tex>.</p><p>We call a class <tex>(K, \subseteq )</tex> satisfying AP, HP, and JEP a Fraisse class</p><p>When a structure has the above isomorphism extension property, we say it is <em>ultrahomogeneous</em> (or <em>homogeneous</em>). 
The converse of Fraisse's Theorem is also true in the sense that if we have a structure which is ultrahomogeneous with respect to its age, then its age is a Fraisse class.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>19</crumb></trail> <anchor>1687</anchor>  <taxon>Theorem</taxon> <addr>Fra-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t002.tree</source-path> <route>Fra-t002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Properties of a Fraisse Limit</title> </frontmatter> <mainmatter><p>If <tex>M</tex> is the <link href="Fra-t001.xml" type="local" title="Fraisse's Theorem">Fraisse Limit</link> of a class <tex>(K,  \leq )</tex>, then <tex>Th(M)</tex> has quantifier elimination and is <tex>\omega</tex>-categorical</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>20</crumb></trail> <anchor>1688</anchor>  <taxon>Example</taxon> <addr>Fra-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e001.tree</source-path> <route>Fra-e001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>The Random Graph</title> </frontmatter> <mainmatter><p>Rado's famous random graph is indeed the Fraisse Limit of the class of finite graphs in the language <tex>\mathcal {L} =  \{ E \}</tex> where <tex>E</tex> is a binary relation representing &quot;there is an edge&quot; between two points.</p><p>More precisely, a graph is an <tex>\mathcal {L}-</tex>structure for which <tex>E</tex> is anti-reflexive and symmetric.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>21</crumb></trail> <anchor>1689</anchor>  <taxon>Example</taxon> <addr>Fra-e002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e002.tree</source-path> <route>Fra-e002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>( \mathbb {Q},  \leq )</tex></title> </frontmatter> <mainmatter><p>The Dense Linear Order <tex>( \mathbb {Q},  \leq )</tex> is the Fraisse Limit of the class of all finite linear orders</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1690</anchor>  <taxon>Part</taxon> <addr>Fra-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-p001.tree</source-path> <route>Fra-p001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse Classes and Variants</title> </frontmatter> <mainmatter><p>We present Fraisse Classes, Smooth classes, and related results and variants.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>22</crumb></trail> <anchor>1691</anchor>  <taxon>Section</taxon> <addr>Fra-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s001.tree</source-path> <route>Fra-s001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse Classes</title> </frontmatter> <mainmatter><p>We define Fraisse constructions and their properties. Most of the concepts can be referred to in <link href="Ref-0001.xml" type="local" title="Model Theory by Wilfred Hodges">Wilfred Hodges' Model Theory</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>22</crumb> <crumb>1</crumb></trail> <anchor>1692</anchor>  <taxon>Definition</taxon> <addr>Fra-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d001.tree</source-path> <route>Fra-d001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Class of Structures</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, a class <tex>K</tex> is defined to be a set of <tex>\mathcal {L}</tex>-structures</p><p>Often, we want there to be a relation <tex>\leq</tex> acting on the structures in <tex>K</tex>, and when we do, we write the class and relation as a pair <tex>(K,  \leq )</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>22</crumb> <crumb>2</crumb></trail> <anchor>1693</anchor>  <taxon>Definition</taxon> <addr>Fra-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d002.tree</source-path> <route>Fra-d002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Age</title> </frontmatter> <mainmatter><p>Given a structure <tex>A</tex> in a language <tex>\mathcal {L}</tex>, the <em>Age</em> (pronounced ah-zh) of <tex>A</tex> is <tex display="block">\{ B \subseteq  A: B  \text { is finitely generated } \}</tex></p><p>The age of a structure is itself a class, often under the relation of substructure</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>22</crumb> <crumb>3</crumb></trail> <anchor>1694</anchor>  <taxon>Definition</taxon> <addr>Fra-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d003.tree</source-path> <route>Fra-d003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Amalgamation Property (AP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex> and <tex>h_2(f(A)) = h_1(g(A))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>22</crumb> <crumb>4</crumb></trail> <anchor>1695</anchor>  <taxon>Definition</taxon> <addr>Fra-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d004.tree</source-path> <route>Fra-d004.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Joint Embedding Property (JEP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B  \in  K</tex>, there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex></p><p><link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">Amalgamation Property</link> does NOT necessarily imply JEP, unless the empty set <tex>\emptyset</tex> is in <tex>K</tex> and for all <tex>A \in  K</tex>, we have that <tex>\emptyset   \leq  A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>22</crumb> <crumb>5</crumb></trail> <anchor>1696</anchor>  <taxon>Definition</taxon> <addr>Fra-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d005.tree</source-path> <route>Fra-d005.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Hereditary Property (HP)</title> </frontmatter> <mainmatter><p>A class <tex>(K, \leq )</tex> has the hereditary property if for every <tex>A \in  K</tex>, and any <tex>B \subseteq  A</tex> finitely generated, then there is some <tex>C \in  K</tex> such that <tex>C \cong  B</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>22</crumb> <crumb>6</crumb></trail> <anchor>1697</anchor>  <taxon>Theorem</taxon> <addr>Fra-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t001.tree</source-path> <route>Fra-t001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \subset )</tex> a class of finitely generated structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link>, the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, and the <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">hereditary property</link>, 
Then there is a unique, countable structure <tex>\mathcal {M}</tex> whose <link href="Fra-d002.xml" type="local" title="Age">age</link> is <tex>K</tex> with the property that any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \subseteq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>The structure <tex>\mathcal {M}</tex> is the <em>Fraisse limit</em> of <tex>K</tex>.</p><p>We call a class <tex>(K, \subseteq )</tex> satisfying AP, HP, and JEP a Fraisse class</p><p>When a structure has the above isomorphism extension property, we say it is <em>ultrahomogeneous</em> (or <em>homogeneous</em>). 
The converse of Fraisse's Theorem is also true in the sense that if we have a structure which is ultrahomogeneous with respect to its age, then its age is a Fraisse class.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>22</crumb> <crumb>7</crumb></trail> <anchor>1698</anchor>  <taxon>Theorem</taxon> <addr>Fra-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t002.tree</source-path> <route>Fra-t002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Properties of a Fraisse Limit</title> </frontmatter> <mainmatter><p>If <tex>M</tex> is the <link href="Fra-t001.xml" type="local" title="Fraisse's Theorem">Fraisse Limit</link> of a class <tex>(K,  \leq )</tex>, then <tex>Th(M)</tex> has quantifier elimination and is <tex>\omega</tex>-categorical</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>22</crumb> <crumb>8</crumb></trail> <anchor>1699</anchor>  <taxon>Example</taxon> <addr>Fra-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e001.tree</source-path> <route>Fra-e001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>The Random Graph</title> </frontmatter> <mainmatter><p>Rado's famous random graph is indeed the Fraisse Limit of the class of finite graphs in the language <tex>\mathcal {L} =  \{ E \}</tex> where <tex>E</tex> is a binary relation representing &quot;there is an edge&quot; between two points.</p><p>More precisely, a graph is an <tex>\mathcal {L}-</tex>structure for which <tex>E</tex> is anti-reflexive and symmetric.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>22</crumb> <crumb>9</crumb></trail> <anchor>1700</anchor>  <taxon>Example</taxon> <addr>Fra-e002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e002.tree</source-path> <route>Fra-e002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>( \mathbb {Q},  \leq )</tex></title> </frontmatter> <mainmatter><p>The Dense Linear Order <tex>( \mathbb {Q},  \leq )</tex> is the Fraisse Limit of the class of all finite linear orders</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>23</crumb></trail> <anchor>1701</anchor>  <taxon>Section</taxon> <addr>Fra-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s002.tree</source-path> <route>Fra-s002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Other Properties of Classes</title> </frontmatter> <mainmatter><p>We define other common properties and variants of the set up shown in the <link href="Fra-s001.xml" type="local" title="Fraisse Classes">Fraisse section</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>23</crumb> <crumb>1</crumb></trail> <anchor>1702</anchor>  <taxon>Definition</taxon> <addr>Fra-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d006.tree</source-path> <route>Fra-d006.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Disjoint Amalgamation Property (dAP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Disjoint Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex> such that <tex>B \cap  C =A</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex>, <tex>h_2(f(A)) = h_1(g(A))</tex>, and <tex>h_2(C)  \cap  h_1(B) = h_1(A)</tex></p><p>An example of a class which has the dAP is the <link href="Fra-e001.xml" type="local" title="The Random Graph">Fraisse class of finite graphs</link></p><p>An example of a smooth class which does not have the dAP is <link href="Smc-e001.xml" type="local" title="Initial Segments">The class of initial segments</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>23</crumb> <crumb>2</crumb></trail> <anchor>1703</anchor>  <taxon>Definition</taxon> <addr>Fra-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d007.tree</source-path> <route>Fra-d007.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ramsey Class</title> </frontmatter> <mainmatter><p>For structures <tex>A,B</tex>, let <tex display="block">\binom {B}{A} =  \{ A_0: A_0 \leq  B &amp; ; A_0 \cong  B \}</tex></p><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the Ramsey property if for every <tex>A \leq  B  \in  K</tex>, there is some <tex>C \in  K</tex> with <tex>B \leq  C</tex>
such that for every <tex>k</tex>-coloring <tex>c:  \binom {C}{A} \rightarrow  k</tex>, there is some <tex>B'  \in   \binom {C}{B}</tex> with <tex display="block">c|_{ \binom {B'}{A}}</tex> constant.</p><p>Ramsey classes are highly related to descriptive set theory, in particular, extremely amenable sets.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>24</crumb></trail> <anchor>1704</anchor>  <taxon>Section</taxon> <addr>Smc-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-s001.tree</source-path> <route>Smc-s001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes</title> </frontmatter> <mainmatter><p>We define Smooth class constructions and their properties. Sources for this section are the papers <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic Structures</link> and <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Stable generic structures</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>24</crumb> <crumb>1</crumb></trail> <anchor>1705</anchor>  <taxon>Definition</taxon> <addr>Smc-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-d001.tree</source-path> <route>Smc-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Class</title> </frontmatter> <mainmatter><p>We assume the language <tex>\mathcal {L}</tex> is countable and only relational.</p><p>A class <tex>(K, \leq )</tex> of finite <tex>\mathcal {L}</tex>-structures (closed under isomorphism) is called <em>a smooth class</em> if <tex>\leq</tex> is transitive, <tex>A \leq  B  \Rightarrow  A \subsetq  B</tex>, and for each <tex>A \in  K</tex>, there is a set of universal formulas <tex>\Phi _A</tex> such that:
<tex display="block">A \leq  B  \Leftrightarrow  B \models   \Phi _A(A)</tex>
and we require that <tex>A \cong  A'  \Leftrightarrow   \Phi _A =  \Phi _{A'}</tex></p><p>This definition comes from <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic structures</link></p><p>An alternative definition, or characterization, from <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Baldwin and Shi</link>, is a class that satisfies the following:</p><p>If <tex>A \in  K</tex>, <tex>A \leq  A</tex></p><p>If <tex>A \leq  B</tex>, then <tex>A \subseteq  B</tex></p><p><tex>\leq</tex> is transitive</p><p>If <tex>A \leq  C</tex>, and <tex>A \subseteq  B \subseteq  C</tex>, then <tex>A \leq  B</tex> for <tex>A,B,C  \in  K</tex></p><p><tex>\emptyset \in  K</tex> and <tex>\emptyset   \leq  A</tex> for all <tex>A \in  K</tex></p><p>The only difference between these two characterizations is that in the first definition, we essentially stipulate that <tex>\leq</tex> is definable/determined by a 
set of universal formulas. This turns out to be an advantage in working with these classes. Certainly, classes satisfying the first definition will satisfy Baldwin-Shi's. In this way,
it is perhaps wiser to regard the second definition as a characterization as opposed to an actual definition.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>24</crumb> <crumb>2</crumb></trail> <anchor>1706</anchor>  <taxon>Example</taxon> <addr>Smc-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-e001.tree</source-path> <route>Smc-e001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Initial Segments</title> </frontmatter> <mainmatter><p> Let <tex>(K, \leq _*)</tex> be the class of be finite, initial segements of the linear order <tex>( \omega , \leq )</tex>, where <tex>A \leq _* B</tex> is &quot;<tex>A</tex> is an initial segment of <tex>B</tex>&quot;.</p><p>It is clear that <tex>\leq</tex> fits into the definition of a smooth class, simply by the universal formula <tex>\Phi _A(y_1, \dots , y_n) =  \forall  x(( x=y_1 \lor \dots \lor  x=y_n)  \lor   \bigwedge _i^n x \geq  y_i)</tex></p><p>This class has <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">AP</link> and <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">JEP</link>, but not <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">HP</link> or <link href="Fra-d006.xml" type="local" title="Disjoint Amalgamation Property (dAP)">dAP</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>24</crumb> <crumb>3</crumb></trail> <anchor>1707</anchor>  <taxon>Theorem</taxon> <addr>Smc-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t001.tree</source-path> <route>Smc-t001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Extension of Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \leq )</tex> is a smooth class of finite structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link> and the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, 
then there is a unique, countable structure <tex>\mathcal {M}</tex>  with the following properties:</p><p>1. Any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \leq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>2. <tex>\mathcal {M} =  \bigcup ^ \omega _n A_n</tex> where <tex>A_n  \leq  A_{n+1}</tex> and for all <tex>n</tex>, <tex>A_n \in  K</tex></p><p>3. For every <tex>A \in  K</tex>, there is an embedding <tex>f:A \rightarrow  M</tex> of <tex>A</tex> into <tex>M</tex> such that <tex>f(A)  \leq  M</tex></p><p>The structure <tex>\mathcal {M}</tex> is the <em>generic</em>, or sometimes, the <em>limit</em> of <tex>K</tex>.</p><p>An equivalent characterization of a generic is properties 2 and 3 and the following property:</p><p>4. If <tex>A \leq  M</tex> and <tex>A \leq  B</tex> for <tex>B \in  K</tex>, then there is an isomorphism <tex>f: B \rightarrow  M</tex> extending the identity map <tex>id: A \rightarrow  M</tex> 
such that <tex>f(B)  \leq  M</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>24</crumb> <crumb>4</crumb></trail> <anchor>1708</anchor>  <taxon>Theorem</taxon> <addr>Smc-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t002.tree</source-path> <route>Smc-t002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes and Saturation</title> </frontmatter> <mainmatter><p>The following theorem first appears in <link href="" type="external">this paper</link> by Laskowski and Kueker</p><p>Let <tex>(K,  \leq )</tex> be a smooth class with a <link href="" type="external">generic</link> <tex>\mathcal {A}</tex>. If <tex>\mathcal {A}</tex> is weakly saturated, then <tex>\mathcal {A}</tex> is indeed saturated</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>24</crumb> <crumb>5</crumb></trail> <anchor>1709</anchor>  <taxon>Theorem</taxon> <addr>Smc-t003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t003.tree</source-path> <route>Smc-t003.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Generic of Smooth Class (Kueker &amp; Laskowski)</title> </frontmatter> <mainmatter><p>Let <tex>(K, \leq )</tex> be a smooth class with a generic <tex>\mathcal {A}</tex>. If for every <tex>A  \in  K</tex>, <tex>\Phi _A</tex> (see <link href="Smc-d001.xml" type="local" title="Smooth Class">here</link>) consists of a single universal formula,
then <tex>\mathcal {A}</tex> is an atomic model.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>25</crumb></trail> <anchor>1710</anchor>  <taxon>Section</taxon> <addr>Fra-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s003.tree</source-path> <route>Fra-s003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Abstract Elementary Classes (AEC)s</title> </frontmatter> <mainmatter><p>We define AEC constructions and their properties</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1711</anchor>  <taxon>Theorem</taxon> <addr>Fra-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t001.tree</source-path> <route>Fra-t001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \subset )</tex> a class of finitely generated structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link>, the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, and the <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">hereditary property</link>, 
Then there is a unique, countable structure <tex>\mathcal {M}</tex> whose <link href="Fra-d002.xml" type="local" title="Age">age</link> is <tex>K</tex> with the property that any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \subseteq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>The structure <tex>\mathcal {M}</tex> is the <em>Fraisse limit</em> of <tex>K</tex>.</p><p>We call a class <tex>(K, \subseteq )</tex> satisfying AP, HP, and JEP a Fraisse class</p><p>When a structure has the above isomorphism extension property, we say it is <em>ultrahomogeneous</em> (or <em>homogeneous</em>). 
The converse of Fraisse's Theorem is also true in the sense that if we have a structure which is ultrahomogeneous with respect to its age, then its age is a Fraisse class.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1712</anchor>  <taxon>Definition</taxon> <addr>Fra-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d005.tree</source-path> <route>Fra-d005.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Hereditary Property (HP)</title> </frontmatter> <mainmatter><p>A class <tex>(K, \leq )</tex> has the hereditary property if for every <tex>A \in  K</tex>, and any <tex>B \subseteq  A</tex> finitely generated, then there is some <tex>C \in  K</tex> such that <tex>C \cong  B</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1713</anchor>  <taxon>Definition</taxon> <addr>Fra-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d004.tree</source-path> <route>Fra-d004.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Joint Embedding Property (JEP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B  \in  K</tex>, there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex></p><p><link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">Amalgamation Property</link> does NOT necessarily imply JEP, unless the empty set <tex>\emptyset</tex> is in <tex>K</tex> and for all <tex>A \in  K</tex>, we have that <tex>\emptyset   \leq  A</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1714</anchor>  <taxon>Theorem</taxon> <addr>Fra-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t002.tree</source-path> <route>Fra-t002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Properties of a Fraisse Limit</title> </frontmatter> <mainmatter><p>If <tex>M</tex> is the <link href="Fra-t001.xml" type="local" title="Fraisse's Theorem">Fraisse Limit</link> of a class <tex>(K,  \leq )</tex>, then <tex>Th(M)</tex> has quantifier elimination and is <tex>\omega</tex>-categorical</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1715</anchor>  <taxon>Section</taxon> <addr>Smc-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-s001.tree</source-path> <route>Smc-s001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes</title> </frontmatter> <mainmatter><p>We define Smooth class constructions and their properties. Sources for this section are the papers <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic Structures</link> and <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Stable generic structures</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>26</crumb></trail> <anchor>1716</anchor>  <taxon>Definition</taxon> <addr>Smc-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-d001.tree</source-path> <route>Smc-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Class</title> </frontmatter> <mainmatter><p>We assume the language <tex>\mathcal {L}</tex> is countable and only relational.</p><p>A class <tex>(K, \leq )</tex> of finite <tex>\mathcal {L}</tex>-structures (closed under isomorphism) is called <em>a smooth class</em> if <tex>\leq</tex> is transitive, <tex>A \leq  B  \Rightarrow  A \subsetq  B</tex>, and for each <tex>A \in  K</tex>, there is a set of universal formulas <tex>\Phi _A</tex> such that:
<tex display="block">A \leq  B  \Leftrightarrow  B \models   \Phi _A(A)</tex>
and we require that <tex>A \cong  A'  \Leftrightarrow   \Phi _A =  \Phi _{A'}</tex></p><p>This definition comes from <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic structures</link></p><p>An alternative definition, or characterization, from <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Baldwin and Shi</link>, is a class that satisfies the following:</p><p>If <tex>A \in  K</tex>, <tex>A \leq  A</tex></p><p>If <tex>A \leq  B</tex>, then <tex>A \subseteq  B</tex></p><p><tex>\leq</tex> is transitive</p><p>If <tex>A \leq  C</tex>, and <tex>A \subseteq  B \subseteq  C</tex>, then <tex>A \leq  B</tex> for <tex>A,B,C  \in  K</tex></p><p><tex>\emptyset \in  K</tex> and <tex>\emptyset   \leq  A</tex> for all <tex>A \in  K</tex></p><p>The only difference between these two characterizations is that in the first definition, we essentially stipulate that <tex>\leq</tex> is definable/determined by a 
set of universal formulas. This turns out to be an advantage in working with these classes. Certainly, classes satisfying the first definition will satisfy Baldwin-Shi's. In this way,
it is perhaps wiser to regard the second definition as a characterization as opposed to an actual definition.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>27</crumb></trail> <anchor>1717</anchor>  <taxon>Example</taxon> <addr>Smc-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-e001.tree</source-path> <route>Smc-e001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Initial Segments</title> </frontmatter> <mainmatter><p> Let <tex>(K, \leq _*)</tex> be the class of be finite, initial segements of the linear order <tex>( \omega , \leq )</tex>, where <tex>A \leq _* B</tex> is &quot;<tex>A</tex> is an initial segment of <tex>B</tex>&quot;.</p><p>It is clear that <tex>\leq</tex> fits into the definition of a smooth class, simply by the universal formula <tex>\Phi _A(y_1, \dots , y_n) =  \forall  x(( x=y_1 \lor \dots \lor  x=y_n)  \lor   \bigwedge _i^n x \geq  y_i)</tex></p><p>This class has <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">AP</link> and <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">JEP</link>, but not <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">HP</link> or <link href="Fra-d006.xml" type="local" title="Disjoint Amalgamation Property (dAP)">dAP</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>28</crumb></trail> <anchor>1718</anchor>  <taxon>Theorem</taxon> <addr>Smc-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t001.tree</source-path> <route>Smc-t001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Extension of Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \leq )</tex> is a smooth class of finite structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link> and the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, 
then there is a unique, countable structure <tex>\mathcal {M}</tex>  with the following properties:</p><p>1. Any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \leq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>2. <tex>\mathcal {M} =  \bigcup ^ \omega _n A_n</tex> where <tex>A_n  \leq  A_{n+1}</tex> and for all <tex>n</tex>, <tex>A_n \in  K</tex></p><p>3. For every <tex>A \in  K</tex>, there is an embedding <tex>f:A \rightarrow  M</tex> of <tex>A</tex> into <tex>M</tex> such that <tex>f(A)  \leq  M</tex></p><p>The structure <tex>\mathcal {M}</tex> is the <em>generic</em>, or sometimes, the <em>limit</em> of <tex>K</tex>.</p><p>An equivalent characterization of a generic is properties 2 and 3 and the following property:</p><p>4. If <tex>A \leq  M</tex> and <tex>A \leq  B</tex> for <tex>B \in  K</tex>, then there is an isomorphism <tex>f: B \rightarrow  M</tex> extending the identity map <tex>id: A \rightarrow  M</tex> 
such that <tex>f(B)  \leq  M</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>29</crumb></trail> <anchor>1719</anchor>  <taxon>Theorem</taxon> <addr>Smc-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t002.tree</source-path> <route>Smc-t002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes and Saturation</title> </frontmatter> <mainmatter><p>The following theorem first appears in <link href="" type="external">this paper</link> by Laskowski and Kueker</p><p>Let <tex>(K,  \leq )</tex> be a smooth class with a <link href="" type="external">generic</link> <tex>\mathcal {A}</tex>. If <tex>\mathcal {A}</tex> is weakly saturated, then <tex>\mathcal {A}</tex> is indeed saturated</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>30</crumb></trail> <anchor>1720</anchor>  <taxon>Theorem</taxon> <addr>Smc-t003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t003.tree</source-path> <route>Smc-t003.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Generic of Smooth Class (Kueker &amp; Laskowski)</title> </frontmatter> <mainmatter><p>Let <tex>(K, \leq )</tex> be a smooth class with a generic <tex>\mathcal {A}</tex>. If for every <tex>A  \in  K</tex>, <tex>\Phi _A</tex> (see <link href="Smc-d001.xml" type="local" title="Smooth Class">here</link>) consists of a single universal formula,
then <tex>\mathcal {A}</tex> is an atomic model.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1721</anchor>  <taxon>Example</taxon> <addr>Fra-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e001.tree</source-path> <route>Fra-e001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>The Random Graph</title> </frontmatter> <mainmatter><p>Rado's famous random graph is indeed the Fraisse Limit of the class of finite graphs in the language <tex>\mathcal {L} =  \{ E \}</tex> where <tex>E</tex> is a binary relation representing &quot;there is an edge&quot; between two points.</p><p>More precisely, a graph is an <tex>\mathcal {L}-</tex>structure for which <tex>E</tex> is anti-reflexive and symmetric.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1722</anchor>  <taxon>Definition</taxon> <addr>Inf-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Infinitary Logic/Inf-d001.tree</source-path> <route>Inf-d001.xml</route> <date><year>2024</year> <month>2</month> <day>9</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of <tex>\mathcal {L}_{ \kappa ,  \omega }</tex></title> </frontmatter> <mainmatter/> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1723</anchor>  <taxon>Definition</taxon> <addr>BMT-d010</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d010.tree</source-path> <route>BMT-d010.xml</route> <date><year>2024</year> <month>2</month> <day>9</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Logical Connectives</title> </frontmatter> <mainmatter><p>We use logical connectives to assess truth value of a formula in propositional and first order logic.</p><p>The symbol <tex>\lor</tex> corresponds to the English word &quot;or&quot;. We say <tex>A  \lor  B</tex> is true if <tex>A</tex> or <tex>B</tex> is true under their respective truth assignments****.</p><p>The symbol <tex>\land</tex> corresponds to the English word &quot;and&quot;. We say <tex>A \land  B</tex> is true if <tex>A</tex> and <tex>B</tex> are both true under their respective truth assignments.</p><p>The symbol <tex>\neg</tex> corresponds to the English word &quot;not&quot;. We say <tex>\neg  A</tex> is true if <tex>A</tex> is false.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1724</anchor>  <taxon>Definition</taxon> <addr>BMT-d011</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d011.tree</source-path> <route>BMT-d011.xml</route> <date><year>2024</year> <month>2</month> <day>9</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Definition of Quantifiers</title> </frontmatter> <mainmatter><p>We use <em>quantifiers</em> to bound variables in a formula in first order logic.</p><p>If <tex>\phi (x)</tex> is a <link href="BMT-d009.xml" type="local" title="{L}-Formula">formula</link>, then <tex>\exists  x ( \phi (x))</tex> should be translated as &quot;there is an interpretation of <tex>x</tex> such that <tex>\phi (x)</tex> holds.</p><p>If <tex>\phi (x)</tex> is a <link href="BMT-d009.xml" type="local" title="{L}-Formula">formula</link>, then <tex>\forall  x ( \phi (x))</tex> should be translated as &quot;for all interpretations of <tex>x</tex>, <tex>\phi (x)</tex> holds.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1725</anchor>  <taxon>Definition</taxon> <addr>BMT-d009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d009.tree</source-path> <route>BMT-d009.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>\mathcal {L}</tex>-Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-formula is defined inductively as follows:</p><p><ul><li>
            If <tex>\phi</tex> is an <tex>\mathcal {L}</tex>-<link href="BMT-d008.xml" type="local" title="Atomic Formula">atomic formula</link> then <tex>\phi</tex> is a formula.
        </li>
        <li>
            If <tex>\phi</tex> and <tex>\psi</tex> are both formulas, then <tex>\neg \phi</tex>, <tex>\phi   \land   \psi</tex>, and 
            <tex>\phi \lor \phi</tex> are formulas, where <tex>\lor , \neg , \land</tex> are the usual <link href="BMT-d010.xml" type="local" title="Definition of Logical Connectives">logical connectives</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li></ul></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1726</anchor>  <taxon>Definition</taxon> <addr>BMT-d008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d008.tree</source-path> <route>BMT-d008.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <em>atomic formula</em> is defined as follows:</p><p>If <tex>R \in   \mathcal {L}</tex> is an n-ary relation symbol, and <tex>t_1, \dots , t_n</tex> are <link href="BMT-d007.xml" type="local" title="Term">terms</link>, then <tex>R(t_1, \dots , t_n)</tex> is an atomic formula.</p><p>If <tex>t_1</tex> and <tex>t_2</tex> are <tex>\mathcal {L}</tex>-terms, then <tex>t_1 = t_2</tex> is an atomic formula. </p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1727</anchor>  <taxon>Part</taxon> <addr>BMT-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-p001.tree</source-path> <route>BMT-p001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> <contributor><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></contributor><contributor><link href="francis-westhead.xml" type="local">Francis Westhead</link></contributor><contributor><link href="gpeters.xml" type="local">Garrett Peters</link></contributor><contributor><link href="oscarc.xml" type="local">Oscar Coppola</link></contributor></authors> <title>Basic Model Theory</title> </frontmatter> <mainmatter><p>We give the common definitions and theorems for basic/introductory model theory</p>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>31</crumb></trail> <anchor>1728</anchor>  <taxon>Section</taxon> <addr>BMT-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s001.tree</source-path> <route>BMT-s001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Structures, Isomorphisms, Substructures</title> </frontmatter> <mainmatter><p>In this section we give the basic notions and theorems for structures, isomorphisms, and substructures</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>31</crumb> <crumb>1</crumb></trail> <anchor>1729</anchor>  <taxon>Definition</taxon> <addr>BMT-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d001.tree</source-path> <route>BMT-d001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Language</title> </frontmatter> <mainmatter><p>A language, also called a vocabulary or signature by different authors, is a set <tex>\mathcal {L}</tex> consisting of symbols for constants, relations, and functions, 
often denoted by <tex>c</tex>, <tex>R</tex>, and <tex>f</tex> respectively. Languages may have any cardinality.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>31</crumb> <crumb>2</crumb></trail> <anchor>1730</anchor>  <taxon>Definition</taxon> <addr>BMT-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d002.tree</source-path> <route>BMT-d002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Structure</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-structure <tex>\mathcal {M}</tex> in this language has a universe <tex>M</tex> (often, the structure and its universe 
are written the same, by abuse of notation). The structure <tex>\mathcal {M}</tex> &quot;interprets&quot; the symbols of <tex>\mathcal {L}</tex> as follows:</p><p>For a constant symbol <tex>c \in   \mathcal {L}</tex>, the interpretation of <tex>c</tex> in <tex>\mathcal {M}</tex>, denoted <tex>c^{ \mathcal {M}}</tex> represents a fixed 
element of <tex>M</tex></p><p>For an <tex>n</tex>-ary function symbol <tex>f \in   \mathcal {L}</tex>, the interpretation of <tex>f</tex> in <tex>\mathcal {M}</tex>, denoted <tex>f^{ \mathcal {M}}</tex>,
is a function from <tex>M^n</tex> to <tex>M</tex></p><p>For an <tex>n</tex>-ary relation symbol <tex>R \in   \mathcal {L}</tex>, the interpretation of <tex>R</tex> in <tex>\mathcal {M}</tex>, denoted <tex>R^{ \mathcal {M}}</tex>,
is a subset <tex>M^n</tex></p><p>Often, we are interested in the cardinality of a structure, denoted <tex>| \mathcal {M}|</tex>, which is defined to be the cardinality of its universe.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>31</crumb> <crumb>3</crumb></trail> <anchor>1731</anchor>  <taxon>Definition</taxon> <addr>BMT-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d003.tree</source-path> <route>BMT-d003.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Homomorphism</title> </frontmatter> <mainmatter><p>Given two <link href="BMT-d002.xml" type="local" title="Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, a <em>homomorphism</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a function between the universes <tex>A</tex> and <tex>B</tex> of <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> respectively such that:</p><p> For every n-ary function <tex>f \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n \in  A</tex>, <tex>\varphi (f^{ \mathcal {A}}(a_1, \dots , a_n)) = f^{ \mathcal {B}}( \varphi (a_1), \dots ,  \varphi (a_n))</tex></p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Rightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>For every constant symbol <tex>c  \in   \mathcal {L}</tex>, <tex>\varphi (c^{ \mathcal {A}}) =c^{ \mathcal {B}}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>31</crumb> <crumb>4</crumb></trail> <anchor>1732</anchor>  <taxon>Definition</taxon> <addr>BMT-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d004.tree</source-path> <route>BMT-d004.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Embedding of <tex>L</tex>-structures</title> </frontmatter> <mainmatter><p>Given two structures in a language <tex>\mathcal {L}</tex> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex>, an <em>embedding</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a <link href="BMT-d003.xml" type="local" title="Homomorphism">homomorphism</link> such that:</p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Leftrightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>This is stronger than a homomorphism because we now require a two way implication in the above property.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>31</crumb> <crumb>5</crumb></trail> <anchor>1733</anchor>  <taxon>Definition</taxon> <addr>BMT-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d005.tree</source-path> <route>BMT-d005.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Isomorphism</title> </frontmatter> <mainmatter><p>An <link href="BMT-d004.xml" type="local" title="Embedding of L-structures">embedding</link> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex> between <tex>\mathcal {L}</tex>-structures is a <em>isomorphism</em> if it is surjective.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>31</crumb> <crumb>6</crumb></trail> <anchor>1734</anchor>  <taxon>Definition</taxon> <addr>BMT-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d006.tree</source-path> <route>BMT-d006.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Substructure</title> </frontmatter> <mainmatter><p>Given a <tex>\mathcal {L}</tex>-structure <tex>\mathcal {A}</tex>, a subset <tex>B  \subseteq  A</tex> is called a <em>substructure</em> of <tex>\mathcal {A}</tex> if:</p><p>For every constant <tex>c \in   \mathcal {L}</tex>, <tex>c^{ \mathcal {A}}  \in  B</tex></p><p>For every n-ary function <tex>f \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, <tex>f^{ \mathcal {A}}(b_1, \dots ,b_n)  \in  B</tex></p><p>For every n-ary relation, <tex>R \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, we write <tex>R^B = R^{ \mathcal {A}} \cap   \mathcal {P}(B^n)</tex> and require that
<tex>R^{B}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{B}</tex>)  if and only if <tex>R^{ \mathcal {A}}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{ \mathcal {A}}</tex>) 
Note that this condition is vacuously true, so only the first two conditions need to be checked when verifying a substructure.</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>32</crumb></trail> <anchor>1735</anchor>  <taxon>Section</taxon> <addr>BMT-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s002.tree</source-path> <route>BMT-s002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Formulas and Models</title> </frontmatter> <mainmatter><p>In this section we define formulas, elementary equivalence, elementary substructures, theories, and models</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>32</crumb> <crumb>1</crumb></trail> <anchor>1736</anchor>  <taxon>Definition</taxon> <addr>BMT-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d007.tree</source-path> <route>BMT-d007.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Term</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, we define a <em>term</em> to be any of the following:</p><p>If <tex>c \in   \mathcal {L}</tex> is a constant symbol, then <tex>c</tex> is a term</p><p>If <tex>x</tex> is a variable symbol, then <tex>x</tex> is a term. We generally assume we have countably infinitely many variable symbols</p><p>If <tex>t_1,..., t_n</tex> are terms, and <tex>f \in   \mathcal {L}</tex> is an <tex>n</tex>-ary function, then <tex>f(t_1,..., t_n)</tex> is a term.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>32</crumb> <crumb>2</crumb></trail> <anchor>1737</anchor>  <taxon>Definition</taxon> <addr>BMT-d008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d008.tree</source-path> <route>BMT-d008.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <em>atomic formula</em> is defined as follows:</p><p>If <tex>R \in   \mathcal {L}</tex> is an n-ary relation symbol, and <tex>t_1, \dots , t_n</tex> are <link href="BMT-d007.xml" type="local" title="Term">terms</link>, then <tex>R(t_1, \dots , t_n)</tex> is an atomic formula.</p><p>If <tex>t_1</tex> and <tex>t_2</tex> are <tex>\mathcal {L}</tex>-terms, then <tex>t_1 = t_2</tex> is an atomic formula. </p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>32</crumb> <crumb>3</crumb></trail> <anchor>1738</anchor>  <taxon>Definition</taxon> <addr>BMT-d009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d009.tree</source-path> <route>BMT-d009.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>\mathcal {L}</tex>-Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-formula is defined inductively as follows:</p><p><ul><li>
            If <tex>\phi</tex> is an <tex>\mathcal {L}</tex>-<link href="BMT-d008.xml" type="local" title="Atomic Formula">atomic formula</link> then <tex>\phi</tex> is a formula.
        </li>
        <li>
            If <tex>\phi</tex> and <tex>\psi</tex> are both formulas, then <tex>\neg \phi</tex>, <tex>\phi   \land   \psi</tex>, and 
            <tex>\phi \lor \phi</tex> are formulas, where <tex>\lor , \neg , \land</tex> are the usual <link href="BMT-d010.xml" type="local" title="Definition of Logical Connectives">logical connectives</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li></ul></p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>33</crumb></trail> <anchor>1739</anchor>  <taxon>Section</taxon> <addr>BMT-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s003.tree</source-path> <route>BMT-s003.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Quantifier Elimination</title> </frontmatter> <mainmatter><p>Quantifier Elimination is a part of a broader technique in Model Theory where for a structure in a given language, an arbitrary formula can be written as a boolean combination of perhaps simpler formulas</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>33</crumb> <crumb>1</crumb></trail> <anchor>1740</anchor>  <taxon>Definition</taxon> <addr>BMT-d014</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d014.tree</source-path> <route>BMT-d014.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Elimination Set</title> </frontmatter> <mainmatter><p>An <em>Elimination Set</em> for a language <tex>\mathcal {L}</tex> and class <tex>K</tex> of <tex>\mathcal {L}</tex>-structures, then a set <tex>\Gamma</tex> of formulas <tex>\phi</tex> is an elimination set for <tex>K</tex> if for every formula <tex>\phi ( \bar {x})</tex> of <tex>\mathcal {L}</tex> there is a formula <tex>\phi ^*( \bar {x})</tex> which is a boolean combinations of formulas in <tex>\Gamma</tex> and <tex>\phi</tex> is equivalent to <tex>\phi ^*</tex> in every structure in <tex>K</tex></p></mainmatter> </tree><p>In particular, we will be most interested in elimination sets that are comprised of the set of quantifier free formulas. It is worth noting that, in some cases it is not possible to have a full quantifier elimination down to the level of a quantifier free set but perhaps we can restrict ourself to some reasonable set of formulas.</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>34</crumb></trail> <anchor>1741</anchor>  <taxon>Section</taxon> <addr>BMT-s004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s004.tree</source-path> <route>BMT-s004.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Back and Forth</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for quantifier Elimination</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>35</crumb></trail> <anchor>1742</anchor>  <taxon>Section</taxon> <addr>BMT-s005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s005.tree</source-path> <route>BMT-s005.xml</route> <date><year>2024</year> <month>3</month> <day>14</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> <contributor><link href="francis-westhead.xml" type="local">Francis Westhead</link></contributor></authors> <title>Types</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for types.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>35</crumb> <crumb>1</crumb></trail> <anchor>1743</anchor>  <taxon>Definition</taxon> <addr>BMT-d019</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d019.tree</source-path> <route>BMT-d019.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>Definition of a type</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory <tex>T</tex></link>, a <em>partial type</em> of <tex>T</tex> is a <link href="BMT-d022.xml" type="local" title="Satisfiability">finitely satisfiable</link> set of formulas in a fixed tuple of variables <tex>x</tex>.</p><p>A partial type <tex>p(x)</tex> (meaning that the denoted type consists of formulas each in the variables <tex>x</tex>) is <em>complete</em> if for every <tex>\mathcal {L}</tex>-formula in the variables <tex>x</tex>, <tex>\varphi (x) \in  p(x)</tex>, either <tex>\varphi (x) \in  p(x)</tex> or <tex>\neg   \varphi (x) \in  p(x)</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>35</crumb> <crumb>2</crumb></trail> <anchor>1744</anchor>  <taxon>Definition</taxon> <addr>BMT-d020</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d020.tree</source-path> <route>BMT-d020.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>Definition of an isolated/principal type</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory <tex>T</tex></link>, a partial type of T, {p(x)}, <em>principal</em> if there is an <tex>\mathcal {L}</tex>-formula, <tex>\varphi (x)</tex>, such that <tex>\models   \exists  x  \varphi (x)</tex> and for every <tex>\varpsi (x)  \in  p(x)</tex> we have that <tex>\models   \forall  x ( \varphi (x)  \rightarrow   \varpsi (x))</tex>. In the case that <tex>p(x)</tex> is complete, we must have that <tex>\varphi (x) \in  p(x)</tex> and the first condition is redundant.</p><p>A complete type of T, {p(x)} is <em>isolated</em> if it is principal as a partial type. Equivalently, {p(x)} is <em>isolated</em> if <tex>\{ p(x) \}</tex> is open <link href="BMT-d021.xml" type="local" title="The Stone Space #[S_n(T)]">S_n(T)</link>. This coincides with the usual topological terminology.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>35</crumb> <crumb>3</crumb></trail> <anchor>1745</anchor>  <taxon>Definition</taxon> <addr>BMT-d021</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d021.tree</source-path> <route>BMT-d021.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>The Stone Space #[S_n(T)]</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory <tex>T</tex></link>,
<tex>S_n(T)</tex> denotes a topological space whose underlying set is the set of all complete <tex>n-types</tex> of <tex>T</tex>.
The topology on <tex>S_n(T)</tex> has a basis of open sets given by all sets of the form <tex>[ \varphi (x)] :=  \{ p(x) \in  S_n(T):
 \varphi (x)  \in  p(x) \}</tex> (for <tex>\varphi (x)</tex> an <tex>\mathcal {L}</tex>-formula).
This space is a Stone Space in the usual sense and the Boolean Algebra associated to it via Stone Duality is
the <tex>n</tex>th Tarski-Lindenbaum Algebra of <tex>T</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>35</crumb> <crumb>4</crumb></trail> <anchor>1746</anchor>  <taxon>Definition</taxon> <addr>BMT-d023</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d023.tree</source-path> <route>BMT-d023.xml</route> <date><year>2024</year> <month>4</month> <day>4</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Finite Satisfiability</title> </frontmatter> <mainmatter><p>
    An <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal  L</tex>-theory</link> <tex>T</tex> is <em>finitely satisfiable</em> when every finite subset of <tex>T</tex> is satisfiable.
</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>36</crumb></trail> <anchor>1747</anchor>  <taxon>Section</taxon> <addr>BMT-s006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s006.tree</source-path> <route>BMT-s006.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Saturation</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for saturation of models.</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>37</crumb></trail> <anchor>1748</anchor>  <taxon>Section</taxon> <addr>BMT-s007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s007.tree</source-path> <route>BMT-s007.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> <contributor><link href="gpeters.xml" type="local">Garrett Peters</link></contributor></authors> <title>Ultraproducts</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for the use of ultraproducts in model theory.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>37</crumb> <crumb>1</crumb></trail> <anchor>1749</anchor>  <taxon>Definition</taxon> <addr>BMT-d071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d071.tree</source-path> <route>BMT-d071.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Definition of a Filter</title> </frontmatter> <mainmatter><p>Let <tex>I</tex> be any set. Then a filter <tex>\mathcal {F}</tex> on the power set <tex>\mathcal {P}(I)</tex> is a collection of subsets of <tex>I</tex> with the following properties:</p><p>1: <tex>I \in \mathcal {F}</tex>.</p><p>2: If <tex>A \in   \mathcal {F}</tex> and <tex>A \subseteq  B</tex>, then <tex>B \in   \mathcal {F}</tex>.</p><p>3: If <tex>A,B  \in   \mathcal {F}</tex>, then we have <tex>A \cap  B \in   \mathcal {F}</tex>.</p><p>Furthermore, a filter is proper if <tex>\emptyset \notin \mathcal {F}</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>37</crumb> <crumb>2</crumb></trail> <anchor>1750</anchor>  <taxon>Definition</taxon> <addr>BMT-d072</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d072.tree</source-path> <route>BMT-d072.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Definition of an Ultrafilter</title> </frontmatter> <mainmatter><p>Let <tex>I</tex> be any set. Then an ultrafilter <tex>\mathcal {U}</tex> on <tex>\mathcal {P}(I)</tex> is a proper <link href="BMT-d071.xml" type="local" title="Definition of a Filter">filter</link> on <tex>I</tex> with the additional property:</p><p>For every <tex>A \subseteq  I</tex>, either <tex>A \in \mathcal {U}</tex> or <tex>I \backslash  A \in \mathcal {U}</tex>.</p><p>Every proper filter can be extended into an ultrafilter.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>37</crumb> <crumb>3</crumb></trail> <anchor>1751</anchor>  <taxon>Example</taxon> <addr>BMT-e071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e071.tree</source-path> <route>BMT-e071.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Principal Ultrafilters</title> </frontmatter> <mainmatter><p>Fix any <tex>i \in  I</tex>. Then <tex>\mathcal {U}_i :=  \{ A \subseteq  I: i \in  A \}</tex> is an <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link>. This is referred to as the principal ultrafilter concentrated at <tex>i</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>37</crumb> <crumb>4</crumb></trail> <anchor>1752</anchor>  <taxon>Example</taxon> <addr>BMT-e072</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e072.tree</source-path> <route>BMT-e072.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>The Frchet Filter</title> </frontmatter> <mainmatter><p>For any set <tex>I</tex> of infinite cardinality, the family of cofinite sets forms a proper <link href="BMT-d071.xml" type="local" title="Definition of a Filter">filter</link>. This filter is referred to as the Frchet filter.</p><p>When extending the Frchet filter to an <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link>, the result is not <link href="BMT-e071.xml" type="local" title="Principal Ultrafilters">principal</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>37</crumb> <crumb>5</crumb></trail> <anchor>1753</anchor>  <taxon>Definition</taxon> <addr>BMT-d073</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d073.tree</source-path> <route>BMT-d073.xml</route> <date><year>2024</year> <month>3</month> <day>7</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Ultraproduct</title> </frontmatter> <mainmatter><p>Fix an index set <tex>I</tex> and a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>L</tex>. Let <tex>\{ \mathcal {A}_i: i \in  I \}</tex> be a family of <tex>L</tex>-<link href="BMT-d002.xml" type="local" title="Structure">structures</link>, and let <tex>\mathcal {U}</tex> be any <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link> on <tex>\mathcal {P}(I)</tex>. Then the ultraproduct is the <tex>L</tex>-structure <tex>\mathcal {A}_* :=  \prod \limits _{i \in  I} A_i / \mathcal {U}</tex>. </p><p>In <tex>\mathcal {A}_*</tex>, the elements of the universe of <tex>\mathcal {A}_*</tex> are functions <tex>\underline {a}</tex> with domain <tex>I</tex> and <tex>\underline {a}(i) \in  A_i</tex> under the equivalence class <tex>\sim _{ \mathcal {U}}</tex>, where <tex display="block">\underline {a} \sim _{ \mathcal {U}} \underline {b}  \text { if and only if } \{ i \in  I:  \underline {a}(i)= \underline {b}(i) \}   \in   \mathcal {U}.</tex></p><p>The constant symbols are interpreted by <tex>c^{ \mathcal {A}_*} :=  \prod \limits _{i \in  I} c^{ \mathcal {A}_i} / \mathcal {U}</tex>. </p><p>The function symbols are interpreted by <tex>f^{ \mathcal {A}_i}( \underline {a}_1, \dots ,  \underline {a}_n) :=  \prod \limits _{i \in  I} f^{ \mathcal {A}_i}( \underline {a}_1(i), \dots , \underline {a}_n(i)) /  \mathcal {U} </tex>. </p><p>The relation symbols are interpreted by <tex>\mathcal {A}_* \models  R^{ \mathcal {A}_*}( \underline {a}_1, \dots ,  \underline {a}_n)</tex> if and only if <tex>\{ i \in  I:  \mathcal {A}_i \models  R^{ \mathcal {A}_i}( \underline {a}_1(i), \dots ,  \underline {a}_n(i)) \} \in   \mathcal {U}</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>37</crumb> <crumb>6</crumb></trail> <anchor>1754</anchor>  <taxon>Theorem</taxon> <addr>BMT-t071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t071.tree</source-path> <route>BMT-t071.xml</route> <date><year>2024</year> <month>3</month> <day>7</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>O's Theorem</title> </frontmatter> <mainmatter><p>Let <tex>\mathcal {A}_* =  \prod \limits _{i \in  I}  \mathcal {A}_i /  \mathcal {U}</tex> be an <link href="BMT-d073.xml" type="local" title="Ultraproduct">ultraproduct</link>. Then for any <tex>L</tex>-formula <tex>\phi (x_1, \dots ,x_n)</tex>, we have <tex display="block">\mathcal {A}_* \models   \phi ( \underline {a}_1, \dots , \underline {a}_n)  \text { if and only if }  \{ i \in  I: A_i \models \phi ( \underline {a}_1(i), \dots ,  \underline {a}_n(i)) \} \in \mathcal {U}.</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>37</crumb> <crumb>7</crumb></trail> <anchor>1755</anchor>  <taxon>Theorem</taxon> <addr>BMT-t072</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t072.tree</source-path> <route>BMT-t072.xml</route> <date><year>2024</year> <month>3</month> <day>14</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Compactness Theorem</title> </frontmatter> <mainmatter><p>Let <tex>L</tex> be any language, and <tex>T</tex> be any <tex>L</tex>-theory. Then <tex>T</tex> is satisfiable if and only if every finite subset <tex>T_0 \subseteq  T</tex> is satisfiable.</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>38</crumb></trail> <anchor>1756</anchor>  <taxon>Section</taxon> <addr>BMT-s008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s008.tree</source-path> <route>BMT-s008.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Model Completenes</title> </frontmatter> <mainmatter><p>An <em>Elimination Set</em> for a language <tex>\mathcal {L}</tex> and class <tex>K</tex> of <tex>\mathcal {L}</tex>-structures, then a set <tex>\Gamma</tex> of formulas <tex>\phi</tex> is an elimination set for <tex>K</tex> if for every formula <tex>\phi ( \bar {x})</tex> of <tex>\mathcal {L}</tex> there is a formula <tex>\phi ^*( \bar {x})</tex> which is a boolean combinations of formulas in <tex>\Gamma</tex> and <tex>\phi</tex> is equivalent to <tex>\phi ^*</tex> in every structure in <tex>K</tex></p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>39</crumb></trail> <anchor>1757</anchor>  <taxon>Section</taxon> <addr>BMT-s009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s009.tree</source-path> <route>BMT-s009.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>Categoricity</title> </frontmatter> <mainmatter><p>In this section, we give the basic definitions for <tex>\kappa</tex>-categoricity. We then establish some classical characterisations of <tex>\aleph _0</tex>-categoricity.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>39</crumb> <crumb>1</crumb></trail> <anchor>1758</anchor>  <taxon>Definition</taxon> <addr>BMT-d201</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d201.tree</source-path> <route>BMT-d201.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title><tex>\kappa</tex>-categoricity</title> </frontmatter> <mainmatter><p>
    Given a cardinal <tex>\kappa</tex> and a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, an <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory</link> is <em><tex>\kappa</tex>-categorical</em> if whenever <tex>\mathcal {M}</tex> and <tex>\mathcal {N}</tex> are <tex>\mathcal {L}</tex>-structures with <tex>| \mathcal {M}|=| \mathcal {M}|= \kappa</tex>, then <tex>\mathcal {M}  \cong   \mathcal {N}</tex>. 
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>39</crumb> <crumb>2</crumb></trail> <anchor>1759</anchor>  <taxon>Definition</taxon> <addr>BMT-d202</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d202.tree</source-path> <route>BMT-d202.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>Tarski-Lindenbaum Algebra</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and an <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory</link>, <tex>T</tex>, the <em><tex>n</tex>'th Tarski-Lindenbaum algebra of <tex>T</tex></em> is the set of <link href="BMT-d009.xml" type="local" title="{L}-Formula"><tex>\mathcal {L}</tex>-formulas</link> quotiented by the relation of <link href="BMT-d018.xml" type="local" title="Definition of T-equivalence of formulas"><tex>T</tex>-equivalence</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>39</crumb> <crumb>3</crumb></trail> <anchor>1760</anchor>  <taxon>Theorem</taxon> <addr>BMT-t003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t003.tree</source-path> <route>BMT-t003.xml</route> <date><year>2024</year> <month>4</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>(Ryll-Nardjewski) Characterisations of <tex>\omega</tex>-categoricity</title> </frontmatter> <mainmatter><p>For <tex>\aleph _0</tex>-categoricity, there are a number of useful characterisations. The following are due to Ryll and Nardjewski.</p><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and an <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory</link> <tex>T</tex>, the following are equivalent:</p><p>1 <tex>T</tex> is <tex>\aleph _0</tex>-categorical.</p><p>For every <tex>n \in   \omega</tex>, there are finitely many <link href="BMT-d009.xml" type="local" title="{L}-Formula"><tex>\mathcal {L}</tex>-formulas</link> in <tex>n</tex>-variables up to <link href="BMT-d018.xml" type="local" title="Definition of T-equivalence of formulas"><tex>T</tex>-equivalence</link>.</p><p>For every <tex>n \in   \omega</tex>, the <link href="BMT-d202.xml" type="local" title="Tarski-Lindenbaum Algebra"><tex>n</tex>'th Tarski-Lindenbaum algebra of <tex>T</tex></link> is finite. 
Every <link href="BMT-d019.xml" type="local" title="Definition of a type">type</link> over <tex>T</tex> is <link href="BMT-d020.xml" type="local" title="Definition of an isolated/principal type">isolated</link>. </p></mainmatter> </tree></mainmatter> </tree>
</mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1761</anchor>  <taxon>Definition</taxon> <addr>BMT-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d004.tree</source-path> <route>BMT-d004.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Embedding of <tex>L</tex>-structures</title> </frontmatter> <mainmatter><p>Given two structures in a language <tex>\mathcal {L}</tex> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex>, an <em>embedding</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a <link href="BMT-d003.xml" type="local" title="Homomorphism">homomorphism</link> such that:</p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Leftrightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>This is stronger than a homomorphism because we now require a two way implication in the above property.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1762</anchor>  <taxon>Section</taxon> <addr>BMT-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s002.tree</source-path> <route>BMT-s002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Formulas and Models</title> </frontmatter> <mainmatter><p>In this section we define formulas, elementary equivalence, elementary substructures, theories, and models</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>40</crumb></trail> <anchor>1763</anchor>  <taxon>Definition</taxon> <addr>BMT-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d007.tree</source-path> <route>BMT-d007.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Term</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, we define a <em>term</em> to be any of the following:</p><p>If <tex>c \in   \mathcal {L}</tex> is a constant symbol, then <tex>c</tex> is a term</p><p>If <tex>x</tex> is a variable symbol, then <tex>x</tex> is a term. We generally assume we have countably infinitely many variable symbols</p><p>If <tex>t_1,..., t_n</tex> are terms, and <tex>f \in   \mathcal {L}</tex> is an <tex>n</tex>-ary function, then <tex>f(t_1,..., t_n)</tex> is a term.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>41</crumb></trail> <anchor>1764</anchor>  <taxon>Definition</taxon> <addr>BMT-d008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d008.tree</source-path> <route>BMT-d008.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <em>atomic formula</em> is defined as follows:</p><p>If <tex>R \in   \mathcal {L}</tex> is an n-ary relation symbol, and <tex>t_1, \dots , t_n</tex> are <link href="BMT-d007.xml" type="local" title="Term">terms</link>, then <tex>R(t_1, \dots , t_n)</tex> is an atomic formula.</p><p>If <tex>t_1</tex> and <tex>t_2</tex> are <tex>\mathcal {L}</tex>-terms, then <tex>t_1 = t_2</tex> is an atomic formula. </p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>42</crumb></trail> <anchor>1765</anchor>  <taxon>Definition</taxon> <addr>BMT-d009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d009.tree</source-path> <route>BMT-d009.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>\mathcal {L}</tex>-Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-formula is defined inductively as follows:</p><p><ul><li>
            If <tex>\phi</tex> is an <tex>\mathcal {L}</tex>-<link href="BMT-d008.xml" type="local" title="Atomic Formula">atomic formula</link> then <tex>\phi</tex> is a formula.
        </li>
        <li>
            If <tex>\phi</tex> and <tex>\psi</tex> are both formulas, then <tex>\neg \phi</tex>, <tex>\phi   \land   \psi</tex>, and 
            <tex>\phi \lor \phi</tex> are formulas, where <tex>\lor , \neg , \land</tex> are the usual <link href="BMT-d010.xml" type="local" title="Definition of Logical Connectives">logical connectives</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li></ul></p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1766</anchor>  <taxon>Definition</taxon> <addr>BMT-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d003.tree</source-path> <route>BMT-d003.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Homomorphism</title> </frontmatter> <mainmatter><p>Given two <link href="BMT-d002.xml" type="local" title="Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, a <em>homomorphism</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a function between the universes <tex>A</tex> and <tex>B</tex> of <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> respectively such that:</p><p> For every n-ary function <tex>f \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n \in  A</tex>, <tex>\varphi (f^{ \mathcal {A}}(a_1, \dots , a_n)) = f^{ \mathcal {B}}( \varphi (a_1), \dots ,  \varphi (a_n))</tex></p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Rightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>For every constant symbol <tex>c  \in   \mathcal {L}</tex>, <tex>\varphi (c^{ \mathcal {A}}) =c^{ \mathcal {B}}</tex></p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1767</anchor>  <taxon>Part</taxon> <addr>inf-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Infinitary Logic/inf-p001.tree</source-path> <route>inf-p001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Infinitary Model Theory</title> </frontmatter> <mainmatter><p>We present the fundamentals of infinitary model theory. The main reference will be David Marker's book Lectures on Infinitary Logic</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1768</anchor>  <taxon>Definition</taxon> <addr>BMT-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d005.tree</source-path> <route>BMT-d005.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Isomorphism</title> </frontmatter> <mainmatter><p>An <link href="BMT-d004.xml" type="local" title="Embedding of L-structures">embedding</link> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex> between <tex>\mathcal {L}</tex>-structures is a <em>isomorphism</em> if it is surjective.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1769</anchor>  <taxon>Definition</taxon> <addr>BMT-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d001.tree</source-path> <route>BMT-d001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Language</title> </frontmatter> <mainmatter><p>A language, also called a vocabulary or signature by different authors, is a set <tex>\mathcal {L}</tex> consisting of symbols for constants, relations, and functions, 
often denoted by <tex>c</tex>, <tex>R</tex>, and <tex>f</tex> respectively. Languages may have any cardinality.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1770</anchor>  <taxon>Definition</taxon> <addr>BMT-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d002.tree</source-path> <route>BMT-d002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Structure</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-structure <tex>\mathcal {M}</tex> in this language has a universe <tex>M</tex> (often, the structure and its universe 
are written the same, by abuse of notation). The structure <tex>\mathcal {M}</tex> &quot;interprets&quot; the symbols of <tex>\mathcal {L}</tex> as follows:</p><p>For a constant symbol <tex>c \in   \mathcal {L}</tex>, the interpretation of <tex>c</tex> in <tex>\mathcal {M}</tex>, denoted <tex>c^{ \mathcal {M}}</tex> represents a fixed 
element of <tex>M</tex></p><p>For an <tex>n</tex>-ary function symbol <tex>f \in   \mathcal {L}</tex>, the interpretation of <tex>f</tex> in <tex>\mathcal {M}</tex>, denoted <tex>f^{ \mathcal {M}}</tex>,
is a function from <tex>M^n</tex> to <tex>M</tex></p><p>For an <tex>n</tex>-ary relation symbol <tex>R \in   \mathcal {L}</tex>, the interpretation of <tex>R</tex> in <tex>\mathcal {M}</tex>, denoted <tex>R^{ \mathcal {M}}</tex>,
is a subset <tex>M^n</tex></p><p>Often, we are interested in the cardinality of a structure, denoted <tex>| \mathcal {M}|</tex>, which is defined to be the cardinality of its universe.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1771</anchor>  <taxon>Section</taxon> <addr>BMT-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s001.tree</source-path> <route>BMT-s001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Structures, Isomorphisms, Substructures</title> </frontmatter> <mainmatter><p>In this section we give the basic notions and theorems for structures, isomorphisms, and substructures</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>43</crumb></trail> <anchor>1772</anchor>  <taxon>Definition</taxon> <addr>BMT-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d001.tree</source-path> <route>BMT-d001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Language</title> </frontmatter> <mainmatter><p>A language, also called a vocabulary or signature by different authors, is a set <tex>\mathcal {L}</tex> consisting of symbols for constants, relations, and functions, 
often denoted by <tex>c</tex>, <tex>R</tex>, and <tex>f</tex> respectively. Languages may have any cardinality.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>44</crumb></trail> <anchor>1773</anchor>  <taxon>Definition</taxon> <addr>BMT-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d002.tree</source-path> <route>BMT-d002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Structure</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-structure <tex>\mathcal {M}</tex> in this language has a universe <tex>M</tex> (often, the structure and its universe 
are written the same, by abuse of notation). The structure <tex>\mathcal {M}</tex> &quot;interprets&quot; the symbols of <tex>\mathcal {L}</tex> as follows:</p><p>For a constant symbol <tex>c \in   \mathcal {L}</tex>, the interpretation of <tex>c</tex> in <tex>\mathcal {M}</tex>, denoted <tex>c^{ \mathcal {M}}</tex> represents a fixed 
element of <tex>M</tex></p><p>For an <tex>n</tex>-ary function symbol <tex>f \in   \mathcal {L}</tex>, the interpretation of <tex>f</tex> in <tex>\mathcal {M}</tex>, denoted <tex>f^{ \mathcal {M}}</tex>,
is a function from <tex>M^n</tex> to <tex>M</tex></p><p>For an <tex>n</tex>-ary relation symbol <tex>R \in   \mathcal {L}</tex>, the interpretation of <tex>R</tex> in <tex>\mathcal {M}</tex>, denoted <tex>R^{ \mathcal {M}}</tex>,
is a subset <tex>M^n</tex></p><p>Often, we are interested in the cardinality of a structure, denoted <tex>| \mathcal {M}|</tex>, which is defined to be the cardinality of its universe.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>45</crumb></trail> <anchor>1774</anchor>  <taxon>Definition</taxon> <addr>BMT-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d003.tree</source-path> <route>BMT-d003.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Homomorphism</title> </frontmatter> <mainmatter><p>Given two <link href="BMT-d002.xml" type="local" title="Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, a <em>homomorphism</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a function between the universes <tex>A</tex> and <tex>B</tex> of <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> respectively such that:</p><p> For every n-ary function <tex>f \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n \in  A</tex>, <tex>\varphi (f^{ \mathcal {A}}(a_1, \dots , a_n)) = f^{ \mathcal {B}}( \varphi (a_1), \dots ,  \varphi (a_n))</tex></p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Rightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>For every constant symbol <tex>c  \in   \mathcal {L}</tex>, <tex>\varphi (c^{ \mathcal {A}}) =c^{ \mathcal {B}}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>46</crumb></trail> <anchor>1775</anchor>  <taxon>Definition</taxon> <addr>BMT-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d004.tree</source-path> <route>BMT-d004.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Embedding of <tex>L</tex>-structures</title> </frontmatter> <mainmatter><p>Given two structures in a language <tex>\mathcal {L}</tex> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex>, an <em>embedding</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a <link href="BMT-d003.xml" type="local" title="Homomorphism">homomorphism</link> such that:</p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Leftrightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>This is stronger than a homomorphism because we now require a two way implication in the above property.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>47</crumb></trail> <anchor>1776</anchor>  <taxon>Definition</taxon> <addr>BMT-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d005.tree</source-path> <route>BMT-d005.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Isomorphism</title> </frontmatter> <mainmatter><p>An <link href="BMT-d004.xml" type="local" title="Embedding of L-structures">embedding</link> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex> between <tex>\mathcal {L}</tex>-structures is a <em>isomorphism</em> if it is surjective.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>48</crumb></trail> <anchor>1777</anchor>  <taxon>Definition</taxon> <addr>BMT-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d006.tree</source-path> <route>BMT-d006.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Substructure</title> </frontmatter> <mainmatter><p>Given a <tex>\mathcal {L}</tex>-structure <tex>\mathcal {A}</tex>, a subset <tex>B  \subseteq  A</tex> is called a <em>substructure</em> of <tex>\mathcal {A}</tex> if:</p><p>For every constant <tex>c \in   \mathcal {L}</tex>, <tex>c^{ \mathcal {A}}  \in  B</tex></p><p>For every n-ary function <tex>f \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, <tex>f^{ \mathcal {A}}(b_1, \dots ,b_n)  \in  B</tex></p><p>For every n-ary relation, <tex>R \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, we write <tex>R^B = R^{ \mathcal {A}} \cap   \mathcal {P}(B^n)</tex> and require that
<tex>R^{B}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{B}</tex>)  if and only if <tex>R^{ \mathcal {A}}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{ \mathcal {A}}</tex>) 
Note that this condition is vacuously true, so only the first two conditions need to be checked when verifying a substructure.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1778</anchor>  <taxon>Definition</taxon> <addr>BMT-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d006.tree</source-path> <route>BMT-d006.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Substructure</title> </frontmatter> <mainmatter><p>Given a <tex>\mathcal {L}</tex>-structure <tex>\mathcal {A}</tex>, a subset <tex>B  \subseteq  A</tex> is called a <em>substructure</em> of <tex>\mathcal {A}</tex> if:</p><p>For every constant <tex>c \in   \mathcal {L}</tex>, <tex>c^{ \mathcal {A}}  \in  B</tex></p><p>For every n-ary function <tex>f \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, <tex>f^{ \mathcal {A}}(b_1, \dots ,b_n)  \in  B</tex></p><p>For every n-ary relation, <tex>R \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, we write <tex>R^B = R^{ \mathcal {A}} \cap   \mathcal {P}(B^n)</tex> and require that
<tex>R^{B}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{B}</tex>)  if and only if <tex>R^{ \mathcal {A}}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{ \mathcal {A}}</tex>) 
Note that this condition is vacuously true, so only the first two conditions need to be checked when verifying a substructure.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="false"><frontmatter> <anchor>1779</anchor>  <taxon>Definition</taxon> <addr>BMT-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d007.tree</source-path> <route>BMT-d007.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Term</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, we define a <em>term</em> to be any of the following:</p><p>If <tex>c \in   \mathcal {L}</tex> is a constant symbol, then <tex>c</tex> is a term</p><p>If <tex>x</tex> is a variable symbol, then <tex>x</tex> is a term. We generally assume we have countably infinitely many variable symbols</p><p>If <tex>t_1,..., t_n</tex> are terms, and <tex>f \in   \mathcal {L}</tex> is an <tex>n</tex>-ary function, then <tex>f(t_1,..., t_n)</tex> is a term.</p></mainmatter> </tree><tree expanded="false" show-heading="true" show-metadata="true" toc="false" root="true"><frontmatter> <anchor>1780</anchor>   <addr>mon-0001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/mon-0001.tree</source-path> <route>index.xml</route>  <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author><author><link href="gpeters.xml" type="local">Garrett Peters</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>The Model Companion</title> </frontmatter> <mainmatter><p>This is the potential start of a new online resource on model theory, replacing the (now defunct) model theory wiki.</p><p>This website is made with the software Forester (http://www.jonmsterling.com/jms-005P.xml). Forester allows you to explore the site in many interesting ways, we have provided a structured starting off points as in below but you may search for any page using Command K</p><p>The site is nonlinear in its arrangement of information. At the high level, the website is broken into parts which are comprised of sections. Currently parts correspond to large themes or subjects in model theory and the sections subdivide these themes further. These parts and sections may not be disjoint but the nature of forester is well suited to navigating these overlaps since definitions and theorems can be transcluded easily. </p><p>In the future it would be nice to have parts which organize the material as one would encounter it as a course or set of lecture notes intended for self study but for now, we intend to set up the backbone as a wikipedia or stacks project reference document and then reassemble the information after a critical mass has been achieved. </p><strong>Here are the parts which currently exist or are being worked on</strong>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb></trail> <anchor>1781</anchor>  <taxon>Part</taxon> <addr>BMT-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-p001.tree</source-path> <route>BMT-p001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> <contributor><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></contributor><contributor><link href="francis-westhead.xml" type="local">Francis Westhead</link></contributor><contributor><link href="gpeters.xml" type="local">Garrett Peters</link></contributor><contributor><link href="oscarc.xml" type="local">Oscar Coppola</link></contributor></authors> <title>Basic Model Theory</title> </frontmatter> <mainmatter><p>We give the common definitions and theorems for basic/introductory model theory</p>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>1</crumb></trail> <anchor>1782</anchor>  <taxon>Section</taxon> <addr>BMT-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s001.tree</source-path> <route>BMT-s001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Structures, Isomorphisms, Substructures</title> </frontmatter> <mainmatter><p>In this section we give the basic notions and theorems for structures, isomorphisms, and substructures</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>1</crumb> <crumb>1</crumb></trail> <anchor>1783</anchor>  <taxon>Definition</taxon> <addr>BMT-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d001.tree</source-path> <route>BMT-d001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Language</title> </frontmatter> <mainmatter><p>A language, also called a vocabulary or signature by different authors, is a set <tex>\mathcal {L}</tex> consisting of symbols for constants, relations, and functions, 
often denoted by <tex>c</tex>, <tex>R</tex>, and <tex>f</tex> respectively. Languages may have any cardinality.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>1</crumb> <crumb>2</crumb></trail> <anchor>1784</anchor>  <taxon>Definition</taxon> <addr>BMT-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d002.tree</source-path> <route>BMT-d002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Structure</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-structure <tex>\mathcal {M}</tex> in this language has a universe <tex>M</tex> (often, the structure and its universe 
are written the same, by abuse of notation). The structure <tex>\mathcal {M}</tex> &quot;interprets&quot; the symbols of <tex>\mathcal {L}</tex> as follows:</p><p>For a constant symbol <tex>c \in   \mathcal {L}</tex>, the interpretation of <tex>c</tex> in <tex>\mathcal {M}</tex>, denoted <tex>c^{ \mathcal {M}}</tex> represents a fixed 
element of <tex>M</tex></p><p>For an <tex>n</tex>-ary function symbol <tex>f \in   \mathcal {L}</tex>, the interpretation of <tex>f</tex> in <tex>\mathcal {M}</tex>, denoted <tex>f^{ \mathcal {M}}</tex>,
is a function from <tex>M^n</tex> to <tex>M</tex></p><p>For an <tex>n</tex>-ary relation symbol <tex>R \in   \mathcal {L}</tex>, the interpretation of <tex>R</tex> in <tex>\mathcal {M}</tex>, denoted <tex>R^{ \mathcal {M}}</tex>,
is a subset <tex>M^n</tex></p><p>Often, we are interested in the cardinality of a structure, denoted <tex>| \mathcal {M}|</tex>, which is defined to be the cardinality of its universe.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>1</crumb> <crumb>3</crumb></trail> <anchor>1785</anchor>  <taxon>Definition</taxon> <addr>BMT-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d003.tree</source-path> <route>BMT-d003.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Homomorphism</title> </frontmatter> <mainmatter><p>Given two <link href="BMT-d002.xml" type="local" title="Structure">structures</link> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> in a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, a <em>homomorphism</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a function between the universes <tex>A</tex> and <tex>B</tex> of <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex> respectively such that:</p><p> For every n-ary function <tex>f \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n \in  A</tex>, <tex>\varphi (f^{ \mathcal {A}}(a_1, \dots , a_n)) = f^{ \mathcal {B}}( \varphi (a_1), \dots ,  \varphi (a_n))</tex></p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Rightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>For every constant symbol <tex>c  \in   \mathcal {L}</tex>, <tex>\varphi (c^{ \mathcal {A}}) =c^{ \mathcal {B}}</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>1</crumb> <crumb>4</crumb></trail> <anchor>1786</anchor>  <taxon>Definition</taxon> <addr>BMT-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d004.tree</source-path> <route>BMT-d004.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Embedding of <tex>L</tex>-structures</title> </frontmatter> <mainmatter><p>Given two structures in a language <tex>\mathcal {L}</tex> <tex>\mathcal {A}</tex> and <tex>\mathcal {B}</tex>, an <em>embedding</em> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex>
is a <link href="BMT-d003.xml" type="local" title="Homomorphism">homomorphism</link> such that:</p><p>For every n-ary relation <tex>R \in   \mathcal {L}</tex>, for all <tex>a_1, \dots , a_n  \in  A</tex>, <tex>\varphi (R^{ \mathcal {A}}(a_1, \dots , a_n))  \text { holds }  \Leftrightarrow  R^{ \mathcal {B}}( \varphi (a_1),  \dots ,  \varphi (a_n))</tex> holds</p><p>This is stronger than a homomorphism because we now require a two way implication in the above property.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>1</crumb> <crumb>5</crumb></trail> <anchor>1787</anchor>  <taxon>Definition</taxon> <addr>BMT-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d005.tree</source-path> <route>BMT-d005.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Isomorphism</title> </frontmatter> <mainmatter><p>An <link href="BMT-d004.xml" type="local" title="Embedding of L-structures">embedding</link> <tex>\varphi :  \mathcal {A}  \rightarrow   \mathcal {B}</tex> between <tex>\mathcal {L}</tex>-structures is a <em>isomorphism</em> if it is surjective.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>1</crumb> <crumb>6</crumb></trail> <anchor>1788</anchor>  <taxon>Definition</taxon> <addr>BMT-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d006.tree</source-path> <route>BMT-d006.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Substructure</title> </frontmatter> <mainmatter><p>Given a <tex>\mathcal {L}</tex>-structure <tex>\mathcal {A}</tex>, a subset <tex>B  \subseteq  A</tex> is called a <em>substructure</em> of <tex>\mathcal {A}</tex> if:</p><p>For every constant <tex>c \in   \mathcal {L}</tex>, <tex>c^{ \mathcal {A}}  \in  B</tex></p><p>For every n-ary function <tex>f \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, <tex>f^{ \mathcal {A}}(b_1, \dots ,b_n)  \in  B</tex></p><p>For every n-ary relation, <tex>R \in   \mathcal {L}</tex>, for any <tex>b_1, \dots , b_n  \in  B</tex>, we write <tex>R^B = R^{ \mathcal {A}} \cap   \mathcal {P}(B^n)</tex> and require that
<tex>R^{B}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{B}</tex>)  if and only if <tex>R^{ \mathcal {A}}(b_1, \dots , b_n)</tex> holds (i.e., <tex>(b_1, \dots , b_n)  \in  R^{ \mathcal {A}}</tex>) 
Note that this condition is vacuously true, so only the first two conditions need to be checked when verifying a substructure.</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>2</crumb></trail> <anchor>1789</anchor>  <taxon>Section</taxon> <addr>BMT-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s002.tree</source-path> <route>BMT-s002.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Formulas and Models</title> </frontmatter> <mainmatter><p>In this section we define formulas, elementary equivalence, elementary substructures, theories, and models</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>2</crumb> <crumb>1</crumb></trail> <anchor>1790</anchor>  <taxon>Definition</taxon> <addr>BMT-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d007.tree</source-path> <route>BMT-d007.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Term</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, we define a <em>term</em> to be any of the following:</p><p>If <tex>c \in   \mathcal {L}</tex> is a constant symbol, then <tex>c</tex> is a term</p><p>If <tex>x</tex> is a variable symbol, then <tex>x</tex> is a term. We generally assume we have countably infinitely many variable symbols</p><p>If <tex>t_1,..., t_n</tex> are terms, and <tex>f \in   \mathcal {L}</tex> is an <tex>n</tex>-ary function, then <tex>f(t_1,..., t_n)</tex> is a term.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>2</crumb> <crumb>2</crumb></trail> <anchor>1791</anchor>  <taxon>Definition</taxon> <addr>BMT-d008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d008.tree</source-path> <route>BMT-d008.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <em>atomic formula</em> is defined as follows:</p><p>If <tex>R \in   \mathcal {L}</tex> is an n-ary relation symbol, and <tex>t_1, \dots , t_n</tex> are <link href="BMT-d007.xml" type="local" title="Term">terms</link>, then <tex>R(t_1, \dots , t_n)</tex> is an atomic formula.</p><p>If <tex>t_1</tex> and <tex>t_2</tex> are <tex>\mathcal {L}</tex>-terms, then <tex>t_1 = t_2</tex> is an atomic formula. </p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>2</crumb> <crumb>3</crumb></trail> <anchor>1792</anchor>  <taxon>Definition</taxon> <addr>BMT-d009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d009.tree</source-path> <route>BMT-d009.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>\mathcal {L}</tex>-Formula</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, an <tex>\mathcal {L}</tex>-formula is defined inductively as follows:</p><p><ul><li>
            If <tex>\phi</tex> is an <tex>\mathcal {L}</tex>-<link href="BMT-d008.xml" type="local" title="Atomic Formula">atomic formula</link> then <tex>\phi</tex> is a formula.
        </li>
        <li>
            If <tex>\phi</tex> and <tex>\psi</tex> are both formulas, then <tex>\neg \phi</tex>, <tex>\phi   \land   \psi</tex>, and 
            <tex>\phi \lor \phi</tex> are formulas, where <tex>\lor , \neg , \land</tex> are the usual <link href="BMT-d010.xml" type="local" title="Definition of Logical Connectives">logical connectives</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li>
        <li>
            If <tex>\phi</tex> is a formula, then <tex>\exists  x  \phi</tex> and <tex>\forall  x  \phi</tex> are formulas, 
            where <tex>\exists</tex> and <tex>\forall</tex> are <link href="BMT-d011.xml" type="local" title="Definition of Quantifiers">quantifiers</link>.
        </li></ul></p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>3</crumb></trail> <anchor>1793</anchor>  <taxon>Section</taxon> <addr>BMT-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s003.tree</source-path> <route>BMT-s003.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Quantifier Elimination</title> </frontmatter> <mainmatter><p>Quantifier Elimination is a part of a broader technique in Model Theory where for a structure in a given language, an arbitrary formula can be written as a boolean combination of perhaps simpler formulas</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>3</crumb> <crumb>1</crumb></trail> <anchor>1794</anchor>  <taxon>Definition</taxon> <addr>BMT-d014</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d014.tree</source-path> <route>BMT-d014.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Elimination Set</title> </frontmatter> <mainmatter><p>An <em>Elimination Set</em> for a language <tex>\mathcal {L}</tex> and class <tex>K</tex> of <tex>\mathcal {L}</tex>-structures, then a set <tex>\Gamma</tex> of formulas <tex>\phi</tex> is an elimination set for <tex>K</tex> if for every formula <tex>\phi ( \bar {x})</tex> of <tex>\mathcal {L}</tex> there is a formula <tex>\phi ^*( \bar {x})</tex> which is a boolean combinations of formulas in <tex>\Gamma</tex> and <tex>\phi</tex> is equivalent to <tex>\phi ^*</tex> in every structure in <tex>K</tex></p></mainmatter> </tree><p>In particular, we will be most interested in elimination sets that are comprised of the set of quantifier free formulas. It is worth noting that, in some cases it is not possible to have a full quantifier elimination down to the level of a quantifier free set but perhaps we can restrict ourself to some reasonable set of formulas.</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>4</crumb></trail> <anchor>1795</anchor>  <taxon>Section</taxon> <addr>BMT-s004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s004.tree</source-path> <route>BMT-s004.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Back and Forth</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for quantifier Elimination</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>5</crumb></trail> <anchor>1796</anchor>  <taxon>Section</taxon> <addr>BMT-s005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s005.tree</source-path> <route>BMT-s005.xml</route> <date><year>2024</year> <month>3</month> <day>14</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> <contributor><link href="francis-westhead.xml" type="local">Francis Westhead</link></contributor></authors> <title>Types</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for types.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>5</crumb> <crumb>1</crumb></trail> <anchor>1797</anchor>  <taxon>Definition</taxon> <addr>BMT-d019</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d019.tree</source-path> <route>BMT-d019.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>Definition of a type</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory <tex>T</tex></link>, a <em>partial type</em> of <tex>T</tex> is a <link href="BMT-d022.xml" type="local" title="Satisfiability">finitely satisfiable</link> set of formulas in a fixed tuple of variables <tex>x</tex>.</p><p>A partial type <tex>p(x)</tex> (meaning that the denoted type consists of formulas each in the variables <tex>x</tex>) is <em>complete</em> if for every <tex>\mathcal {L}</tex>-formula in the variables <tex>x</tex>, <tex>\varphi (x) \in  p(x)</tex>, either <tex>\varphi (x) \in  p(x)</tex> or <tex>\neg   \varphi (x) \in  p(x)</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>5</crumb> <crumb>2</crumb></trail> <anchor>1798</anchor>  <taxon>Definition</taxon> <addr>BMT-d020</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d020.tree</source-path> <route>BMT-d020.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>Definition of an isolated/principal type</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory <tex>T</tex></link>, a partial type of T, {p(x)}, <em>principal</em> if there is an <tex>\mathcal {L}</tex>-formula, <tex>\varphi (x)</tex>, such that <tex>\models   \exists  x  \varphi (x)</tex> and for every <tex>\varpsi (x)  \in  p(x)</tex> we have that <tex>\models   \forall  x ( \varphi (x)  \rightarrow   \varpsi (x))</tex>. In the case that <tex>p(x)</tex> is complete, we must have that <tex>\varphi (x) \in  p(x)</tex> and the first condition is redundant.</p><p>A complete type of T, {p(x)} is <em>isolated</em> if it is principal as a partial type. Equivalently, {p(x)} is <em>isolated</em> if <tex>\{ p(x) \}</tex> is open <link href="BMT-d021.xml" type="local" title="The Stone Space #[S_n(T)]">S_n(T)</link>. This coincides with the usual topological terminology.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>5</crumb> <crumb>3</crumb></trail> <anchor>1799</anchor>  <taxon>Definition</taxon> <addr>BMT-d021</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d021.tree</source-path> <route>BMT-d021.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>The Stone Space #[S_n(T)]</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and a <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory <tex>T</tex></link>,
<tex>S_n(T)</tex> denotes a topological space whose underlying set is the set of all complete <tex>n-types</tex> of <tex>T</tex>.
The topology on <tex>S_n(T)</tex> has a basis of open sets given by all sets of the form <tex>[ \varphi (x)] :=  \{ p(x) \in  S_n(T):
 \varphi (x)  \in  p(x) \}</tex> (for <tex>\varphi (x)</tex> an <tex>\mathcal {L}</tex>-formula).
This space is a Stone Space in the usual sense and the Boolean Algebra associated to it via Stone Duality is
the <tex>n</tex>th Tarski-Lindenbaum Algebra of <tex>T</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>5</crumb> <crumb>4</crumb></trail> <anchor>1800</anchor>  <taxon>Definition</taxon> <addr>BMT-d023</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d023.tree</source-path> <route>BMT-d023.xml</route> <date><year>2024</year> <month>4</month> <day>4</day></date> <authors><author><link href="oscarc.xml" type="local">Oscar Coppola</link></author> </authors> <title>Finite Satisfiability</title> </frontmatter> <mainmatter><p>
    An <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal  L</tex>-theory</link> <tex>T</tex> is <em>finitely satisfiable</em> when every finite subset of <tex>T</tex> is satisfiable.
</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>6</crumb></trail> <anchor>1801</anchor>  <taxon>Section</taxon> <addr>BMT-s006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s006.tree</source-path> <route>BMT-s006.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Saturation</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for saturation of models.</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>7</crumb></trail> <anchor>1802</anchor>  <taxon>Section</taxon> <addr>BMT-s007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s007.tree</source-path> <route>BMT-s007.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> <contributor><link href="gpeters.xml" type="local">Garrett Peters</link></contributor></authors> <title>Ultraproducts</title> </frontmatter> <mainmatter><p>In this section we give the basic definitions and theorems for the use of ultraproducts in model theory.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>7</crumb> <crumb>1</crumb></trail> <anchor>1803</anchor>  <taxon>Definition</taxon> <addr>BMT-d071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d071.tree</source-path> <route>BMT-d071.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Definition of a Filter</title> </frontmatter> <mainmatter><p>Let <tex>I</tex> be any set. Then a filter <tex>\mathcal {F}</tex> on the power set <tex>\mathcal {P}(I)</tex> is a collection of subsets of <tex>I</tex> with the following properties:</p><p>1: <tex>I \in \mathcal {F}</tex>.</p><p>2: If <tex>A \in   \mathcal {F}</tex> and <tex>A \subseteq  B</tex>, then <tex>B \in   \mathcal {F}</tex>.</p><p>3: If <tex>A,B  \in   \mathcal {F}</tex>, then we have <tex>A \cap  B \in   \mathcal {F}</tex>.</p><p>Furthermore, a filter is proper if <tex>\emptyset \notin \mathcal {F}</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>7</crumb> <crumb>2</crumb></trail> <anchor>1804</anchor>  <taxon>Definition</taxon> <addr>BMT-d072</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d072.tree</source-path> <route>BMT-d072.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Definition of an Ultrafilter</title> </frontmatter> <mainmatter><p>Let <tex>I</tex> be any set. Then an ultrafilter <tex>\mathcal {U}</tex> on <tex>\mathcal {P}(I)</tex> is a proper <link href="BMT-d071.xml" type="local" title="Definition of a Filter">filter</link> on <tex>I</tex> with the additional property:</p><p>For every <tex>A \subseteq  I</tex>, either <tex>A \in \mathcal {U}</tex> or <tex>I \backslash  A \in \mathcal {U}</tex>.</p><p>Every proper filter can be extended into an ultrafilter.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>7</crumb> <crumb>3</crumb></trail> <anchor>1805</anchor>  <taxon>Example</taxon> <addr>BMT-e071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e071.tree</source-path> <route>BMT-e071.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Principal Ultrafilters</title> </frontmatter> <mainmatter><p>Fix any <tex>i \in  I</tex>. Then <tex>\mathcal {U}_i :=  \{ A \subseteq  I: i \in  A \}</tex> is an <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link>. This is referred to as the principal ultrafilter concentrated at <tex>i</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>7</crumb> <crumb>4</crumb></trail> <anchor>1806</anchor>  <taxon>Example</taxon> <addr>BMT-e072</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-e072.tree</source-path> <route>BMT-e072.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>The Frchet Filter</title> </frontmatter> <mainmatter><p>For any set <tex>I</tex> of infinite cardinality, the family of cofinite sets forms a proper <link href="BMT-d071.xml" type="local" title="Definition of a Filter">filter</link>. This filter is referred to as the Frchet filter.</p><p>When extending the Frchet filter to an <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link>, the result is not <link href="BMT-e071.xml" type="local" title="Principal Ultrafilters">principal</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>7</crumb> <crumb>5</crumb></trail> <anchor>1807</anchor>  <taxon>Definition</taxon> <addr>BMT-d073</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d073.tree</source-path> <route>BMT-d073.xml</route> <date><year>2024</year> <month>3</month> <day>7</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Ultraproduct</title> </frontmatter> <mainmatter><p>Fix an index set <tex>I</tex> and a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>L</tex>. Let <tex>\{ \mathcal {A}_i: i \in  I \}</tex> be a family of <tex>L</tex>-<link href="BMT-d002.xml" type="local" title="Structure">structures</link>, and let <tex>\mathcal {U}</tex> be any <link href="BMT-d072.xml" type="local" title="Definition of an Ultrafilter">ultrafilter</link> on <tex>\mathcal {P}(I)</tex>. Then the ultraproduct is the <tex>L</tex>-structure <tex>\mathcal {A}_* :=  \prod \limits _{i \in  I} A_i / \mathcal {U}</tex>. </p><p>In <tex>\mathcal {A}_*</tex>, the elements of the universe of <tex>\mathcal {A}_*</tex> are functions <tex>\underline {a}</tex> with domain <tex>I</tex> and <tex>\underline {a}(i) \in  A_i</tex> under the equivalence class <tex>\sim _{ \mathcal {U}}</tex>, where <tex display="block">\underline {a} \sim _{ \mathcal {U}} \underline {b}  \text { if and only if } \{ i \in  I:  \underline {a}(i)= \underline {b}(i) \}   \in   \mathcal {U}.</tex></p><p>The constant symbols are interpreted by <tex>c^{ \mathcal {A}_*} :=  \prod \limits _{i \in  I} c^{ \mathcal {A}_i} / \mathcal {U}</tex>. </p><p>The function symbols are interpreted by <tex>f^{ \mathcal {A}_i}( \underline {a}_1, \dots ,  \underline {a}_n) :=  \prod \limits _{i \in  I} f^{ \mathcal {A}_i}( \underline {a}_1(i), \dots , \underline {a}_n(i)) /  \mathcal {U} </tex>. </p><p>The relation symbols are interpreted by <tex>\mathcal {A}_* \models  R^{ \mathcal {A}_*}( \underline {a}_1, \dots ,  \underline {a}_n)</tex> if and only if <tex>\{ i \in  I:  \mathcal {A}_i \models  R^{ \mathcal {A}_i}( \underline {a}_1(i), \dots ,  \underline {a}_n(i)) \} \in   \mathcal {U}</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>7</crumb> <crumb>6</crumb></trail> <anchor>1808</anchor>  <taxon>Theorem</taxon> <addr>BMT-t071</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t071.tree</source-path> <route>BMT-t071.xml</route> <date><year>2024</year> <month>3</month> <day>7</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>O's Theorem</title> </frontmatter> <mainmatter><p>Let <tex>\mathcal {A}_* =  \prod \limits _{i \in  I}  \mathcal {A}_i /  \mathcal {U}</tex> be an <link href="BMT-d073.xml" type="local" title="Ultraproduct">ultraproduct</link>. Then for any <tex>L</tex>-formula <tex>\phi (x_1, \dots ,x_n)</tex>, we have <tex display="block">\mathcal {A}_* \models   \phi ( \underline {a}_1, \dots , \underline {a}_n)  \text { if and only if }  \{ i \in  I: A_i \models \phi ( \underline {a}_1(i), \dots ,  \underline {a}_n(i)) \} \in \mathcal {U}.</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>7</crumb> <crumb>7</crumb></trail> <anchor>1809</anchor>  <taxon>Theorem</taxon> <addr>BMT-t072</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t072.tree</source-path> <route>BMT-t072.xml</route> <date><year>2024</year> <month>3</month> <day>14</day></date> <authors><author><link href="gpeters.xml" type="local">Garrett Peters</link></author> </authors> <title>Compactness Theorem</title> </frontmatter> <mainmatter><p>Let <tex>L</tex> be any language, and <tex>T</tex> be any <tex>L</tex>-theory. Then <tex>T</tex> is satisfiable if and only if every finite subset <tex>T_0 \subseteq  T</tex> is satisfiable.</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>8</crumb></trail> <anchor>1810</anchor>  <taxon>Section</taxon> <addr>BMT-s008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s008.tree</source-path> <route>BMT-s008.xml</route> <date><year>2024</year> <month>2</month> <day>27</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Model Completenes</title> </frontmatter> <mainmatter><p>An <em>Elimination Set</em> for a language <tex>\mathcal {L}</tex> and class <tex>K</tex> of <tex>\mathcal {L}</tex>-structures, then a set <tex>\Gamma</tex> of formulas <tex>\phi</tex> is an elimination set for <tex>K</tex> if for every formula <tex>\phi ( \bar {x})</tex> of <tex>\mathcal {L}</tex> there is a formula <tex>\phi ^*( \bar {x})</tex> which is a boolean combinations of formulas in <tex>\Gamma</tex> and <tex>\phi</tex> is equivalent to <tex>\phi ^*</tex> in every structure in <tex>K</tex></p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>9</crumb></trail> <anchor>1811</anchor>  <taxon>Section</taxon> <addr>BMT-s009</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-s009.tree</source-path> <route>BMT-s009.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>Categoricity</title> </frontmatter> <mainmatter><p>In this section, we give the basic definitions for <tex>\kappa</tex>-categoricity. We then establish some classical characterisations of <tex>\aleph _0</tex>-categoricity.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>9</crumb> <crumb>1</crumb></trail> <anchor>1812</anchor>  <taxon>Definition</taxon> <addr>BMT-d201</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d201.tree</source-path> <route>BMT-d201.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title><tex>\kappa</tex>-categoricity</title> </frontmatter> <mainmatter><p>
    Given a cardinal <tex>\kappa</tex> and a <link href="BMT-d001.xml" type="local" title="Language">language</link> <tex>\mathcal {L}</tex>, an <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory</link> is <em><tex>\kappa</tex>-categorical</em> if whenever <tex>\mathcal {M}</tex> and <tex>\mathcal {N}</tex> are <tex>\mathcal {L}</tex>-structures with <tex>| \mathcal {M}|=| \mathcal {M}|= \kappa</tex>, then <tex>\mathcal {M}  \cong   \mathcal {N}</tex>. 
</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>9</crumb> <crumb>2</crumb></trail> <anchor>1813</anchor>  <taxon>Definition</taxon> <addr>BMT-d202</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-d202.tree</source-path> <route>BMT-d202.xml</route> <date><year>2024</year> <month>3</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>Tarski-Lindenbaum Algebra</title> </frontmatter> <mainmatter><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and an <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory</link>, <tex>T</tex>, the <em><tex>n</tex>'th Tarski-Lindenbaum algebra of <tex>T</tex></em> is the set of <link href="BMT-d009.xml" type="local" title="{L}-Formula"><tex>\mathcal {L}</tex>-formulas</link> quotiented by the relation of <link href="BMT-d018.xml" type="local" title="Definition of T-equivalence of formulas"><tex>T</tex>-equivalence</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>49</crumb> <crumb>9</crumb> <crumb>3</crumb></trail> <anchor>1814</anchor>  <taxon>Theorem</taxon> <addr>BMT-t003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Basic Model Theory/BMT-t003.tree</source-path> <route>BMT-t003.xml</route> <date><year>2024</year> <month>4</month> <day>10</day></date> <authors><author><link href="francis-westhead.xml" type="local">Francis Westhead</link></author> </authors> <title>(Ryll-Nardjewski) Characterisations of <tex>\omega</tex>-categoricity</title> </frontmatter> <mainmatter><p>For <tex>\aleph _0</tex>-categoricity, there are a number of useful characterisations. The following are due to Ryll and Nardjewski.</p><p>Given a <link href="BMT-d001.xml" type="local" title="Language">language</link>, <tex>\mathcal {L}</tex>, and an <link href="BMT-d017.xml" type="local" title="Definition of an {L}-theory"><tex>\mathcal {L}</tex>-theory</link> <tex>T</tex>, the following are equivalent:</p><p>1 <tex>T</tex> is <tex>\aleph _0</tex>-categorical.</p><p>For every <tex>n \in   \omega</tex>, there are finitely many <link href="BMT-d009.xml" type="local" title="{L}-Formula"><tex>\mathcal {L}</tex>-formulas</link> in <tex>n</tex>-variables up to <link href="BMT-d018.xml" type="local" title="Definition of T-equivalence of formulas"><tex>T</tex>-equivalence</link>.</p><p>For every <tex>n \in   \omega</tex>, the <link href="BMT-d202.xml" type="local" title="Tarski-Lindenbaum Algebra"><tex>n</tex>'th Tarski-Lindenbaum algebra of <tex>T</tex></link> is finite. 
Every <link href="BMT-d019.xml" type="local" title="Definition of a type">type</link> over <tex>T</tex> is <link href="BMT-d020.xml" type="local" title="Definition of an isolated/principal type">isolated</link>. </p></mainmatter> </tree></mainmatter> </tree>
</mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb></trail> <anchor>1815</anchor>  <taxon>Part</taxon> <addr>Fra-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-p001.tree</source-path> <route>Fra-p001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse Classes and Variants</title> </frontmatter> <mainmatter><p>We present Fraisse Classes, Smooth classes, and related results and variants.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>1</crumb></trail> <anchor>1816</anchor>  <taxon>Section</taxon> <addr>Fra-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s001.tree</source-path> <route>Fra-s001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse Classes</title> </frontmatter> <mainmatter><p>We define Fraisse constructions and their properties. Most of the concepts can be referred to in <link href="Ref-0001.xml" type="local" title="Model Theory by Wilfred Hodges">Wilfred Hodges' Model Theory</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>1</crumb> <crumb>1</crumb></trail> <anchor>1817</anchor>  <taxon>Definition</taxon> <addr>Fra-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d001.tree</source-path> <route>Fra-d001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Class of Structures</title> </frontmatter> <mainmatter><p>Given a language <tex>\mathcal {L}</tex>, a class <tex>K</tex> is defined to be a set of <tex>\mathcal {L}</tex>-structures</p><p>Often, we want there to be a relation <tex>\leq</tex> acting on the structures in <tex>K</tex>, and when we do, we write the class and relation as a pair <tex>(K,  \leq )</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>1</crumb> <crumb>2</crumb></trail> <anchor>1818</anchor>  <taxon>Definition</taxon> <addr>Fra-d002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d002.tree</source-path> <route>Fra-d002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Age</title> </frontmatter> <mainmatter><p>Given a structure <tex>A</tex> in a language <tex>\mathcal {L}</tex>, the <em>Age</em> (pronounced ah-zh) of <tex>A</tex> is <tex display="block">\{ B \subseteq  A: B  \text { is finitely generated } \}</tex></p><p>The age of a structure is itself a class, often under the relation of substructure</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>1</crumb> <crumb>3</crumb></trail> <anchor>1819</anchor>  <taxon>Definition</taxon> <addr>Fra-d003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d003.tree</source-path> <route>Fra-d003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Amalgamation Property (AP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex> and <tex>h_2(f(A)) = h_1(g(A))</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>1</crumb> <crumb>4</crumb></trail> <anchor>1820</anchor>  <taxon>Definition</taxon> <addr>Fra-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d004.tree</source-path> <route>Fra-d004.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Joint Embedding Property (JEP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Amalgamation Property</em> if for every <tex>A,B  \in  K</tex>, there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex></p><p><link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">Amalgamation Property</link> does NOT necessarily imply JEP, unless the empty set <tex>\emptyset</tex> is in <tex>K</tex> and for all <tex>A \in  K</tex>, we have that <tex>\emptyset   \leq  A</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>1</crumb> <crumb>5</crumb></trail> <anchor>1821</anchor>  <taxon>Definition</taxon> <addr>Fra-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d005.tree</source-path> <route>Fra-d005.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Hereditary Property (HP)</title> </frontmatter> <mainmatter><p>A class <tex>(K, \leq )</tex> has the hereditary property if for every <tex>A \in  K</tex>, and any <tex>B \subseteq  A</tex> finitely generated, then there is some <tex>C \in  K</tex> such that <tex>C \cong  B</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>1</crumb> <crumb>6</crumb></trail> <anchor>1822</anchor>  <taxon>Theorem</taxon> <addr>Fra-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t001.tree</source-path> <route>Fra-t001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \subset )</tex> a class of finitely generated structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link>, the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, and the <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">hereditary property</link>, 
Then there is a unique, countable structure <tex>\mathcal {M}</tex> whose <link href="Fra-d002.xml" type="local" title="Age">age</link> is <tex>K</tex> with the property that any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \subseteq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>The structure <tex>\mathcal {M}</tex> is the <em>Fraisse limit</em> of <tex>K</tex>.</p><p>We call a class <tex>(K, \subseteq )</tex> satisfying AP, HP, and JEP a Fraisse class</p><p>When a structure has the above isomorphism extension property, we say it is <em>ultrahomogeneous</em> (or <em>homogeneous</em>). 
The converse of Fraisse's Theorem is also true in the sense that if we have a structure which is ultrahomogeneous with respect to its age, then its age is a Fraisse class.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>1</crumb> <crumb>7</crumb></trail> <anchor>1823</anchor>  <taxon>Theorem</taxon> <addr>Fra-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-t002.tree</source-path> <route>Fra-t002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Properties of a Fraisse Limit</title> </frontmatter> <mainmatter><p>If <tex>M</tex> is the <link href="Fra-t001.xml" type="local" title="Fraisse's Theorem">Fraisse Limit</link> of a class <tex>(K,  \leq )</tex>, then <tex>Th(M)</tex> has quantifier elimination and is <tex>\omega</tex>-categorical</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>1</crumb> <crumb>8</crumb></trail> <anchor>1824</anchor>  <taxon>Example</taxon> <addr>Fra-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e001.tree</source-path> <route>Fra-e001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>The Random Graph</title> </frontmatter> <mainmatter><p>Rado's famous random graph is indeed the Fraisse Limit of the class of finite graphs in the language <tex>\mathcal {L} =  \{ E \}</tex> where <tex>E</tex> is a binary relation representing &quot;there is an edge&quot; between two points.</p><p>More precisely, a graph is an <tex>\mathcal {L}-</tex>structure for which <tex>E</tex> is anti-reflexive and symmetric.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>1</crumb> <crumb>9</crumb></trail> <anchor>1825</anchor>  <taxon>Example</taxon> <addr>Fra-e002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-e002.tree</source-path> <route>Fra-e002.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title><tex>( \mathbb {Q},  \leq )</tex></title> </frontmatter> <mainmatter><p>The Dense Linear Order <tex>( \mathbb {Q},  \leq )</tex> is the Fraisse Limit of the class of all finite linear orders</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>2</crumb></trail> <anchor>1826</anchor>  <taxon>Section</taxon> <addr>Fra-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s002.tree</source-path> <route>Fra-s002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Other Properties of Classes</title> </frontmatter> <mainmatter><p>We define other common properties and variants of the set up shown in the <link href="Fra-s001.xml" type="local" title="Fraisse Classes">Fraisse section</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>2</crumb> <crumb>1</crumb></trail> <anchor>1827</anchor>  <taxon>Definition</taxon> <addr>Fra-d006</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d006.tree</source-path> <route>Fra-d006.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Disjoint Amalgamation Property (dAP)</title> </frontmatter> <mainmatter><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the <em>Disjoint Amalgamation Property</em> if for every <tex>A,B,C  \in  K</tex> such that <tex>B \cap  C =A</tex>, if there 
exists an embedding <tex>f:A \rightarrow  B</tex> such that <tex>f(A)  \leq  B</tex> and and embedding <tex>g:A \rightarrow  C</tex> such that <tex>A \leq  B</tex>, then there exists a structure <tex>D</tex> 
and embeddings <tex>h_1:C \rightarrow  D</tex> and <tex>h_2:B \rightarrow  D</tex> such that <tex>h_1(C) \leq  D</tex> and <tex>h_2(B)  \leq  D</tex>, <tex>h_2(f(A)) = h_1(g(A))</tex>, and <tex>h_2(C)  \cap  h_1(B) = h_1(A)</tex></p><p>An example of a class which has the dAP is the <link href="Fra-e001.xml" type="local" title="The Random Graph">Fraisse class of finite graphs</link></p><p>An example of a smooth class which does not have the dAP is <link href="Smc-e001.xml" type="local" title="Initial Segments">The class of initial segments</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>2</crumb> <crumb>2</crumb></trail> <anchor>1828</anchor>  <taxon>Definition</taxon> <addr>Fra-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-d007.tree</source-path> <route>Fra-d007.xml</route> <date><year>2024</year> <month>3</month> <day>1</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Ramsey Class</title> </frontmatter> <mainmatter><p>For structures <tex>A,B</tex>, let <tex display="block">\binom {B}{A} =  \{ A_0: A_0 \leq  B &amp; ; A_0 \cong  B \}</tex></p><p>Given a class and relation <tex>(K, \leq )</tex>, we say that <tex>K</tex> has the Ramsey property if for every <tex>A \leq  B  \in  K</tex>, there is some <tex>C \in  K</tex> with <tex>B \leq  C</tex>
such that for every <tex>k</tex>-coloring <tex>c:  \binom {C}{A} \rightarrow  k</tex>, there is some <tex>B'  \in   \binom {C}{B}</tex> with <tex display="block">c|_{ \binom {B'}{A}}</tex> constant.</p><p>Ramsey classes are highly related to descriptive set theory, in particular, extremely amenable sets.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>3</crumb></trail> <anchor>1829</anchor>  <taxon>Section</taxon> <addr>Smc-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-s001.tree</source-path> <route>Smc-s001.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes</title> </frontmatter> <mainmatter><p>We define Smooth class constructions and their properties. Sources for this section are the papers <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic Structures</link> and <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Stable generic structures</link></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>3</crumb> <crumb>1</crumb></trail> <anchor>1830</anchor>  <taxon>Definition</taxon> <addr>Smc-d001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-d001.tree</source-path> <route>Smc-d001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Class</title> </frontmatter> <mainmatter><p>We assume the language <tex>\mathcal {L}</tex> is countable and only relational.</p><p>A class <tex>(K, \leq )</tex> of finite <tex>\mathcal {L}</tex>-structures (closed under isomorphism) is called <em>a smooth class</em> if <tex>\leq</tex> is transitive, <tex>A \leq  B  \Rightarrow  A \subsetq  B</tex>, and for each <tex>A \in  K</tex>, there is a set of universal formulas <tex>\Phi _A</tex> such that:
<tex display="block">A \leq  B  \Leftrightarrow  B \models   \Phi _A(A)</tex>
and we require that <tex>A \cong  A'  \Leftrightarrow   \Phi _A =  \Phi _{A'}</tex></p><p>This definition comes from <link href="Smc-r001.xml" type="local" title="On Generic Structures">On Generic structures</link></p><p>An alternative definition, or characterization, from <link href="Smc-r002.xml" type="local" title="Stable Generic Structures">Baldwin and Shi</link>, is a class that satisfies the following:</p><p>If <tex>A \in  K</tex>, <tex>A \leq  A</tex></p><p>If <tex>A \leq  B</tex>, then <tex>A \subseteq  B</tex></p><p><tex>\leq</tex> is transitive</p><p>If <tex>A \leq  C</tex>, and <tex>A \subseteq  B \subseteq  C</tex>, then <tex>A \leq  B</tex> for <tex>A,B,C  \in  K</tex></p><p><tex>\emptyset \in  K</tex> and <tex>\emptyset   \leq  A</tex> for all <tex>A \in  K</tex></p><p>The only difference between these two characterizations is that in the first definition, we essentially stipulate that <tex>\leq</tex> is definable/determined by a 
set of universal formulas. This turns out to be an advantage in working with these classes. Certainly, classes satisfying the first definition will satisfy Baldwin-Shi's. In this way,
it is perhaps wiser to regard the second definition as a characterization as opposed to an actual definition.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>3</crumb> <crumb>2</crumb></trail> <anchor>1831</anchor>  <taxon>Example</taxon> <addr>Smc-e001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-e001.tree</source-path> <route>Smc-e001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Initial Segments</title> </frontmatter> <mainmatter><p> Let <tex>(K, \leq _*)</tex> be the class of be finite, initial segements of the linear order <tex>( \omega , \leq )</tex>, where <tex>A \leq _* B</tex> is &quot;<tex>A</tex> is an initial segment of <tex>B</tex>&quot;.</p><p>It is clear that <tex>\leq</tex> fits into the definition of a smooth class, simply by the universal formula <tex>\Phi _A(y_1, \dots , y_n) =  \forall  x(( x=y_1 \lor \dots \lor  x=y_n)  \lor   \bigwedge _i^n x \geq  y_i)</tex></p><p>This class has <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">AP</link> and <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">JEP</link>, but not <link href="Fra-d005.xml" type="local" title="Hereditary Property (HP)">HP</link> or <link href="Fra-d006.xml" type="local" title="Disjoint Amalgamation Property (dAP)">dAP</link></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>3</crumb> <crumb>3</crumb></trail> <anchor>1832</anchor>  <taxon>Theorem</taxon> <addr>Smc-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t001.tree</source-path> <route>Smc-t001.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Extension of Fraisse's Theorem</title> </frontmatter> <mainmatter><p>If <tex>\mathcal {L}</tex> is countable, and <tex>(K, \leq )</tex> is a smooth class of finite structures has the <link href="Fra-d003.xml" type="local" title="Amalgamation Property (AP)">amalgamation property</link> and the <link href="Fra-d004.xml" type="local" title="Joint Embedding Property (JEP)">joint embedding property</link>, 
then there is a unique, countable structure <tex>\mathcal {M}</tex>  with the following properties:</p><p>1. Any isomorphism <tex>f:A \rightarrow  B</tex> with <tex>A,B \leq   \mathcal {M}</tex> and <tex>A,B \in  K</tex> extends to
an automorphism of <tex>\mathcal {M}</tex>.</p><p>2. <tex>\mathcal {M} =  \bigcup ^ \omega _n A_n</tex> where <tex>A_n  \leq  A_{n+1}</tex> and for all <tex>n</tex>, <tex>A_n \in  K</tex></p><p>3. For every <tex>A \in  K</tex>, there is an embedding <tex>f:A \rightarrow  M</tex> of <tex>A</tex> into <tex>M</tex> such that <tex>f(A)  \leq  M</tex></p><p>The structure <tex>\mathcal {M}</tex> is the <em>generic</em>, or sometimes, the <em>limit</em> of <tex>K</tex>.</p><p>An equivalent characterization of a generic is properties 2 and 3 and the following property:</p><p>4. If <tex>A \leq  M</tex> and <tex>A \leq  B</tex> for <tex>B \in  K</tex>, then there is an isomorphism <tex>f: B \rightarrow  M</tex> extending the identity map <tex>id: A \rightarrow  M</tex> 
such that <tex>f(B)  \leq  M</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>3</crumb> <crumb>4</crumb></trail> <anchor>1833</anchor>  <taxon>Theorem</taxon> <addr>Smc-t002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t002.tree</source-path> <route>Smc-t002.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Smooth Classes and Saturation</title> </frontmatter> <mainmatter><p>The following theorem first appears in <link href="" type="external">this paper</link> by Laskowski and Kueker</p><p>Let <tex>(K,  \leq )</tex> be a smooth class with a <link href="" type="external">generic</link> <tex>\mathcal {A}</tex>. If <tex>\mathcal {A}</tex> is weakly saturated, then <tex>\mathcal {A}</tex> is indeed saturated</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>3</crumb> <crumb>5</crumb></trail> <anchor>1834</anchor>  <taxon>Theorem</taxon> <addr>Smc-t003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Smc-t003.tree</source-path> <route>Smc-t003.xml</route> <date><year>2024</year> <month>2</month> <day>17</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Atomic Generic of Smooth Class (Kueker &amp; Laskowski)</title> </frontmatter> <mainmatter><p>Let <tex>(K, \leq )</tex> be a smooth class with a generic <tex>\mathcal {A}</tex>. If for every <tex>A  \in  K</tex>, <tex>\Phi _A</tex> (see <link href="Smc-d001.xml" type="local" title="Smooth Class">here</link>) consists of a single universal formula,
then <tex>\mathcal {A}</tex> is an atomic model.</p></mainmatter> </tree></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>50</crumb> <crumb>4</crumb></trail> <anchor>1835</anchor>  <taxon>Section</taxon> <addr>Fra-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Fraisse and Smooth Classes/Fra-s003.tree</source-path> <route>Fra-s003.xml</route> <date><year>2024</year> <month>2</month> <day>13</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Abstract Elementary Classes (AEC)s</title> </frontmatter> <mainmatter><p>We define AEC constructions and their properties</p></mainmatter> </tree></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>51</crumb></trail> <anchor>1836</anchor>  <taxon>Part</taxon> <addr>mon-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-p001.tree</source-path> <route>mon-p001.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> <contributor><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></contributor></authors> <title>Dividing lines</title> </frontmatter> <mainmatter><p>Dividing lines play a fundamental role in model theory. They form the basis of Shelah's approach to classification theory and have been a central influence on model theory since their conception. Here is an interactive (though not complete) map of the <link href="https://forkinganddividing.com" type="external">model theoretic universe</link>, maintained by Gabriel Conant. Important examples of dividing lines include stability, NIP, and o-minimality.</p>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>51</crumb> <crumb>1</crumb></trail> <anchor>1837</anchor>  <taxon>Section</taxon> <addr>mon-s002</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/Stability/mon-s002.tree</source-path> <route>mon-s002.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Stability Theory</title> </frontmatter> <mainmatter><p><strong>Stable theories</strong></p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>51</crumb> <crumb>1</crumb> <crumb>1</crumb></trail> <anchor>1838</anchor>  <taxon>Subsection</taxon> <addr>mon-s003</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/Stability/mon-s003.tree</source-path> <route>mon-s003.xml</route> <date><year>2024</year> <month>2</month> <day>10</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Forking and Dividing</title> </frontmatter> <mainmatter><p><strong>Forking and Dividing</strong></p></mainmatter> </tree></mainmatter> </tree>

    
    <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>51</crumb> <crumb>2</crumb></trail> <anchor>1839</anchor>  <taxon>Section</taxon> <addr>mon-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-s001.tree</source-path> <route>mon-s001.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>NIP Theories</title> </frontmatter> <mainmatter><p><strong>NIP theories</strong> are a class of theories generalizing stable
theories, but allowing for an ordering. Aside from stable theories,
important examples are real closed fields, ACVF, <tex>p</tex>-adically closed
fields, and o-minimal theories</p><p>Fix a complete theory <tex>T</tex> with monster model <tex>\mathbb {M}</tex>.
Also fix a formula <tex>\varphi (x;y)</tex> with a fixed partitioning into
the two tuples <tex>x</tex> and <tex>y</tex>.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>51</crumb> <crumb>2</crumb> <crumb>1</crumb></trail> <anchor>1840</anchor>  <taxon>Definition</taxon> <addr>mon-d004</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d004.tree</source-path> <route>mon-d004.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Definition of the independence property</title> </frontmatter> <mainmatter><p>The formula <tex>\varphi (x;y)</tex> has the <em>independence property</em> if there
are sequences of tuples <tex>(a_i : i  \in   \omega )</tex> and
<tex>(b_S : S  \subseteq   \omega )</tex> such that for every subset <tex>S  \subseteq   \omega</tex>
<tex display="block">i  \in  S  \Longleftrightarrow   \mathbb {M}  \models   \varphi (a_i; b_S).</tex></p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>51</crumb> <crumb>2</crumb> <crumb>2</crumb></trail> <anchor>1841</anchor>  <taxon>Definition</taxon> <addr>mon-d005</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d005.tree</source-path> <route>mon-d005.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Definition of NIP</title> </frontmatter> <mainmatter><p>The formula <tex>\varphi (x;y)</tex> is said to be <em>NIP</em> if it does not have
the <link href="mon-0004" type="external">independence property</link>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>51</crumb> <crumb>2</crumb> <crumb>3</crumb></trail> <anchor>1842</anchor>  <taxon>Theorem</taxon> <addr>mon-t001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-t001.tree</source-path> <route>mon-t001.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Characterizations of NIP for a formula</title> </frontmatter> <mainmatter><p>The following conditions are equivalent:
<ol><li> The formula <tex>\varphi (x;y)</tex> has the independence property.</li>
  <li> The formula <tex>\varphi ^{ \vee }(y;x)</tex> has the independence property,
	where <tex>\varphi ^{ \vee }(y;x)</tex> is the formula <tex>\varphi (x;y)</tex> with the
	opposite partition.</li>
	<li> For any two finite sets <tex>U</tex> and <tex>V</tex>, and any subset <tex>R  \subseteq  U  \times  V</tex>, there are <tex>(a_i : i  \in  U)</tex> and <tex>(b_j : j  \in  U)</tex> such that <tex>\mathbb   \models   \varphi (a_i;b_j)  \Longleftrightarrow  (i,j)  \in  R</tex>.</li>
	<li> There is an indiscernible sequence <tex>(a_i : i  \in   \omega )</tex>
	and some <tex>b</tex> such that <tex>\mathbb  M  \models   \varphi (a_i;b)  \Longleftrightarrow  i</tex>
	is even.</li></ol></p><p>We are also interested in the following characterization, which is more amenable to computations.</p><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>51</crumb> <crumb>2</crumb> <crumb>3</crumb> <crumb>1</crumb></trail> <anchor>1843</anchor>  <taxon>Definition</taxon> <addr>mon-d007</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d007.tree</source-path> <route>mon-d007.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Alternation Number</title> </frontmatter> <mainmatter><p>The <em>alternation number</em> of a formula <tex>\varphi (x;y)</tex>, denoted <tex>\operatorname {alt}( \varphi (x;y))</tex> is the maximal number <tex>n  \in   \omega</tex> (if it exists) such that there is an indiscernible sequence <tex>(a_i : i  \in   \omega )</tex>, some <tex>b</tex>, and indices <tex>i_0 &lt;  \dots  &lt; i_n</tex> with <tex>\mathbb  M  \models   \varphi (a_i,b)  \Longleftrightarrow  i  \text { is even}</tex>. If no such maximum exists, we let <tex>\operatorname {alt}( \varphi (x;y)) =  \infty</tex>.</p></mainmatter> </tree><tree expanded="true" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>51</crumb> <crumb>2</crumb> <crumb>3</crumb> <crumb>2</crumb></trail> <anchor>1844</anchor>  <taxon>Lemma</taxon> <addr>mon-d008</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Dividing Lines/mon-d008.tree</source-path> <route>mon-d008.xml</route> <date><year>2024</year> <month>2</month> <day>2</day></date> <authors><author><link href="adam-melrod.xml" type="local">Adam Melrod</link></author> </authors> <title>Alternation Lemma</title> </frontmatter> <mainmatter><p>A formula <tex>\varphi (x;y)</tex> is NIP if and only if <tex>\operatorname {alt}( \varphi (x;y)) &lt;  \infty</tex>.</p></mainmatter> </tree></mainmatter> </tree></mainmatter> </tree>
</mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>52</crumb></trail> <anchor>1845</anchor>  <taxon>Part</taxon> <addr>inf-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Infinitary Logic/inf-p001.tree</source-path> <route>inf-p001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="mbryant.xml" type="local">Morgan Bryant</link></author> </authors> <title>Infinitary Model Theory</title> </frontmatter> <mainmatter><p>We present the fundamentals of infinitary model theory. The main reference will be David Marker's book Lectures on Infinitary Logic</p></mainmatter> </tree>

  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>53</crumb></trail> <anchor>1846</anchor>  <taxon>Part</taxon> <addr>moe-p001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Monadic Expansions/moe-p001.tree</source-path> <route>moe-p001.xml</route> <date><year>2024</year> <month>2</month> <day>8</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Monadic Expansions</title> </frontmatter> <mainmatter><p>Model Theory of Monadic Expansions</p>
  
  <tree expanded="false" show-heading="true" show-metadata="false" toc="true" root="false"><frontmatter><trail><crumb>53</crumb> <crumb>1</crumb></trail> <anchor>1847</anchor>  <taxon>Section</taxon> <addr>moe-s001</addr> <source-path>/Users/connorlockhart/Documents/GitHub/ModelTheoryWiki/monster-main/trees/Monadic Expansions/Mutually Algebraic Theories/moe-s001.tree</source-path> <route>moe-s001.xml</route> <date><year>2024</year> <month>2</month> <day>9</day></date> <authors><author><link href="connor-lockhart.xml" type="local">Connor Lockhart</link></author> </authors> <title>Definition of </title> </frontmatter> <mainmatter/> </tree>
</mainmatter> </tree>
</mainmatter> </tree></contributions> <context/> <related/> <backlinks/> <references/></backmatter></tree>